From 6d63596bf9ed679edd37387a99b8fe37427a9f4e Mon Sep 17 00:00:00 2001
From: Erik Bengtsson <erik.bengtsson@flir.se>
Date: Thu, 3 Oct 2019 14:43:43 +0200
Subject: [PATCH] Add support for ec201 rev.C. Change led driver to lp5562,
 change accel to kxtj3. Get accel driver from newer linux kernel to enable
 devicetree support.

---
 arch/arm/boot/dts/imx7ulp-ec201-b.dtsi   |  86 +++++++
 arch/arm/boot/dts/imx7ulp-ec201.dtsi     |  63 ++---
 arch/arm/boot/dts/imx7ulp-sherlock-a.dts |   3 +-
 arch/arm/boot/dts/imx7ulp-sherlock-b.dts |  21 ++
 drivers/iio/accel/kxcjk-1013.c           | 387 ++++++++++++++++++++-----------
 5 files changed, 391 insertions(+), 169 deletions(-)
 create mode 100644 arch/arm/boot/dts/imx7ulp-ec201-b.dtsi
 create mode 100644 arch/arm/boot/dts/imx7ulp-sherlock-b.dts

diff --git a/arch/arm/boot/dts/imx7ulp-ec201-b.dtsi b/arch/arm/boot/dts/imx7ulp-ec201-b.dtsi
new file mode 100644
index 0000000..1e030f5
--- /dev/null
+++ b/arch/arm/boot/dts/imx7ulp-ec201-b.dtsi
@@ -0,0 +1,86 @@
+
+/*
+ * Copyright 2019 FLIR
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+ 
+/* This device tree is for board ec201 revision b  */
+/ {
+	regulators {
+		vcam_en_reg_avdd: vcam_en_reg_avdd {
+			status = "disabled";
+		};
+		vcam_en_reg_dovdd: vcam_en_reg_dovdd {
+			status = "diabled";
+		};
+
+		vcam_en_reg: vcam_en_reg {
+			compatible = "regulator-fixed";
+			regulator-name = "vcam_en";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			gpio = <&gpio_ptf 17 GPIO_ACTIVE_HIGH>;
+			startup-delay-us = <0>;
+			enable-active-high;
+			regulator-boot-on;
+			regulator-always-on;
+		};
+
+	};
+};
+
+&lpi2c6 {
+
+	ov5640: ov5640@3c {
+		/delete-property/ DOVDD-supply; /* 1.8v */
+		/delete-property/ AVDD-supply;  /* 2.8v */
+		clk-gpios = <&gpio_ptf 16 GPIO_ACTIVE_HIGH>;
+	};
+
+	acc_mma8452: acc_mma8452@1D {
+		compatible = "fsl,mma8452";
+		reg = <0x1D>;
+		interrupt-parent = <&gpio_ptc>;
+		interrupts = <10 IRQ_TYPE_LEVEL_HIGH>;
+	};
+
+	acc_kxtj3: acc_kxtj3@0F {
+		status = "disabled";
+	};
+
+	touchpad_leds: touchpad_leds@30 {
+		status = "disabled";
+	};
+
+	touchpad_leds2: touchpad_leds2@32 {
+		compatible = "national,lp5521";
+		reg = <0x32>;
+		
+		label = "touchpad-leds";
+		clock-mode = <1>;	/* Internal clock */
+		enable-gpio = <&gpio_ptc 11 GPIO_ACTIVE_HIGH>;
+
+		tp_led1 {
+			chan-name = "tp-camera";
+			led-cur = /bits/ 8 <0x32>;
+			max-cur = /bits/ 8 <0x32>;
+			linux,default-trigger = "none";
+		};
+		tp_led2 {
+			chan-name = "tp-settings";
+			led-cur = /bits/ 8 <0x32>;
+			max-cur = /bits/ 8 <0x32>;
+			linux,default-trigger = "none";
+		};
+		tp_led3 {
+			chan-name = "tp-gallery";
+			led-cur = /bits/ 8 <0x32>;
+			max-cur = /bits/ 8 <0x32>;
+			linux,default-trigger = "none";
+		};
+	};
+};
\ No newline at end of file
diff --git a/arch/arm/boot/dts/imx7ulp-ec201.dtsi b/arch/arm/boot/dts/imx7ulp-ec201.dtsi
index 882c6e2..bde1cdc 100644
--- a/arch/arm/boot/dts/imx7ulp-ec201.dtsi
+++ b/arch/arm/boot/dts/imx7ulp-ec201.dtsi
@@ -56,17 +56,26 @@
 			regulator-always-on;
 		};
 
-		vcam_en_reg: vcam_en_reg {
+		vcam_en_reg_dovdd: vcam_en_reg_dovdd {
 			compatible = "regulator-fixed";
-			regulator-name = "vcam_en";
+			regulator-name = "vcam_en_reg_dovdd";
 			regulator-min-microvolt = <1800000>;
 			regulator-max-microvolt = <1800000>;
+			gpio = <&gpio_ptf 16 GPIO_ACTIVE_HIGH>;
+			startup-delay-us = <0>;
+			enable-active-high;
+		};
+		
+		vcam_en_reg_avdd: vcam_en_reg_avdd {
+			compatible = "regulator-fixed";
+			regulator-name = "vcam_en_reg_avdd";
+			regulator-min-microvolt = <2700000>;
+			regulator-max-microvolt = <2700000>;
 			gpio = <&gpio_ptf 17 GPIO_ACTIVE_HIGH>;
 			startup-delay-us = <0>;
 			enable-active-high;
-			regulator-boot-on;
-			regulator-always-on;
 		};
+
 	};
 
 	gpio_keys {
@@ -172,14 +181,6 @@
 
 &iomuxc1 {
 	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_hog_1>;
-
-	pinctrl_hog_1: hoggrp-1 {
-    	fsl,pins = <
- 			IMX7ULP_PAD_PTC0__PTC0      0x20002  /* SHUTTER_IN */
- 			IMX7ULP_PAD_PTC1__PTC1      0x20002  /* SHUTTER_OUT */
- 			>;
-	};
 
 	pinctrl_pwm0: pwm0grp {
 		fsl,pins = <
@@ -280,10 +281,6 @@
 
 	pinctrl_camera: camera_grp {
 		fsl,pins = <
-			IMX7ULP_PAD_PTF16__PTF16    0x20043  /* CAMERA CLK ENABLE*/
-			IMX7ULP_PAD_PTF15__PTF15    0x20043  /* CAMERA PWDN */
-			IMX7ULP_PAD_PTF14__PTF14    0x20043  /* CAMERA RESET */
-			IMX7ULP_PAD_PTF17__PTF17    0x20043  /* CAMERA ENABLE */
 			IMX7ULP_PAD_PTF3__VIU_PCLK  0x10043
 			IMX7ULP_PAD_PTF6__VIU_D2    0x43
 			IMX7ULP_PAD_PTF7__VIU_D3    0x43
@@ -293,6 +290,11 @@
 			IMX7ULP_PAD_PTF11__VIU_D7   0x43
 			IMX7ULP_PAD_PTF12__VIU_D8   0x43
 			IMX7ULP_PAD_PTF13__VIU_D9   0x43
+			IMX7ULP_PAD_PTF14__PTF14    0x20043  /* CAMERA RESET */
+			IMX7ULP_PAD_PTF15__PTF15    0x20043  /* CAMERA PWDN */
+			IMX7ULP_PAD_PTF16__PTF16    0x20043  /* CAMERA 1V8 ENABLE*/
+			IMX7ULP_PAD_PTF17__PTF17    0x20043  /* CAMERA 2V8 ENABLE */
+			IMX7ULP_PAD_PTC0__PTC0    	0x3  	 /* CAMERA DUMMY CLK ENABLE */
 			>;
 	};
 };
@@ -410,14 +412,15 @@
 		pinctrl-0 = <&pinctrl_camera>;
 		clocks = <&clks IMX7ULP_CLK_DUMMY>;
 		clock-names = "csi_mclk";
-		pwn-gpios = <&gpio_ptf 15 GPIO_ACTIVE_HIGH>;
+		DOVDD-supply = <&vcam_en_reg_dovdd>; /* 1.8v */
+		AVDD-supply = <&vcam_en_reg_avdd>;  /* 2.8v */
+        pwn-gpios = <&gpio_ptf 15 GPIO_ACTIVE_HIGH>;
 		rst-gpios = <&gpio_ptf 14 GPIO_ACTIVE_HIGH>;
-		clk-gpios = <&gpio_ptf 16 GPIO_ACTIVE_HIGH>;
+		clk-gpios = <&gpio_ptc 0 GPIO_ACTIVE_HIGH>;
 		csi_id = <0>;
 		mclk = <24000000>;
 		mclk_source = <0>;
 		status = "okay";
-
 		port {
 			ov5640_ep: endpoint {
 				remote-endpoint = <&viu_ep>;
@@ -425,9 +428,9 @@
 		};
 	};
 
-	acc_mma8452: acc_mma8452@1D {
-		compatible = "fsl,mma8452";
-		reg = <0x1D>;
+	acc_kxtj3: acc_kxtj3@0F {
+		compatible = "kionix,kxtj21009";
+		reg = <0x0F>;
 		interrupt-parent = <&gpio_ptc>;
 		interrupts = <10 IRQ_TYPE_LEVEL_HIGH>;
 	};
@@ -437,7 +440,6 @@
 		reg = <0x48>;
 	};
 
-
 	eeprom_24c02: eeprom_24c02@57 {
 		compatible = "atmel,24c02";
 		reg = <0x57>;
@@ -446,8 +448,7 @@
 	
 	torch: torch@63 {
 		compatible = "leds-lm3642";
-		reg = <0x63>;
-		
+		reg = <0x63>;		
 		flash-ramp = <3>;       /* 011b = 2 ms */
 		flash-time-out = <7>;   /* 111b = 800 ms */ 
 		torch-max-current = <3>;/* 011b = 375 mA */
@@ -458,9 +459,9 @@
 		strobe-gpios = <&gpio_ptc 16 GPIO_ACTIVE_HIGH>;
 	};
 	
-	touchpad_leds: toucpad_leds@32 {
-		compatible = "national,lp5521";
-		reg = <0x32>;
+	touchpad_leds: touchpad_leds@30 {
+		compatible = "national,lp5562";
+		reg = <0x30>;
 		
 		label = "touchpad-leds";
 		clock-mode = <1>;	/* Internal clock */
@@ -484,6 +485,12 @@
 			max-cur = /bits/ 8 <0x32>;
 			linux,default-trigger = "none";
 		};
+		tp_led4 {
+			chan-name = "tp-NA";
+			led-cur = /bits/ 8 <0x32>;
+			max-cur = /bits/ 8 <0x32>;
+			linux,default-trigger = "none";
+		};
 	};
 };
 
diff --git a/arch/arm/boot/dts/imx7ulp-sherlock-a.dts b/arch/arm/boot/dts/imx7ulp-sherlock-a.dts
index 241f58d..e443c5c 100644
--- a/arch/arm/boot/dts/imx7ulp-sherlock-a.dts
+++ b/arch/arm/boot/dts/imx7ulp-sherlock-a.dts
@@ -13,9 +13,10 @@
 #include <dt-bindings/input/input.h>
 #include "imx7ulp.dtsi"
 #include "imx7ulp-ec201.dtsi"
+#include "imx7ulp-ec201-b.dtsi"
 #include "imx7ulp-ec201-a.dtsi"
 
 / {
 	model = "FLIR i.MX7ULP Sherlock rev a board";
-	compatible = "flir,imx7ulp-sherlock", "flir,imx7ulp-ec201-a","flir,imx7ulp-ec201", "fsl,imx7ulp", "Generic DT based system";
+	compatible = "flir,imx7ulp-sherlock", "flir,imx7ulp-ec201-a", "flir,imx7ulp-ec201-b", "flir,imx7ulp-ec201", "fsl,imx7ulp", "Generic DT based system";
 };
diff --git a/arch/arm/boot/dts/imx7ulp-sherlock-b.dts b/arch/arm/boot/dts/imx7ulp-sherlock-b.dts
new file mode 100644
index 0000000..3a7c3de
--- /dev/null
+++ b/arch/arm/boot/dts/imx7ulp-sherlock-b.dts
@@ -0,0 +1,21 @@
+/*
+ * Copyright 2019 FLIR
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/dts-v1/;
+
+/* This device tree is for board ec201 revision b  */
+
+#include <dt-bindings/input/input.h>
+#include "imx7ulp.dtsi"
+#include "imx7ulp-ec201.dtsi"
+#include "imx7ulp-ec201-b.dtsi"
+
+/ {
+	model = "FLIR i.MX7ULP Sherlock rev b board";
+	compatible = "flir,imx7ulp-sherlock", "flir,imx7ulp-ec201-b","flir,imx7ulp-ec201", "fsl,imx7ulp", "Generic DT based system";
+};
diff --git a/drivers/iio/accel/kxcjk-1013.c b/drivers/iio/accel/kxcjk-1013.c
index 3f968c4..f583aad 100644
--- a/drivers/iio/accel/kxcjk-1013.c
+++ b/drivers/iio/accel/kxcjk-1013.c
@@ -1,15 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * KXCJK-1013 3-axis accelerometer driver
  * Copyright (c) 2014, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
  */
 
 #include <linux/module.h>
@@ -34,6 +26,13 @@
 #define KXCJK1013_DRV_NAME "kxcjk1013"
 #define KXCJK1013_IRQ_NAME "kxcjk1013_event"
 
+#define KXTF9_REG_HP_XOUT_L		0x00
+#define KXTF9_REG_HP_XOUT_H		0x01
+#define KXTF9_REG_HP_YOUT_L		0x02
+#define KXTF9_REG_HP_YOUT_H		0x03
+#define KXTF9_REG_HP_ZOUT_L		0x04
+#define KXTF9_REG_HP_ZOUT_H		0x05
+
 #define KXCJK1013_REG_XOUT_L		0x06
 /*
  * From low byte X axis register, all the other addresses of Y and Z can be
@@ -48,17 +47,33 @@
 
 #define KXCJK1013_REG_DCST_RESP		0x0C
 #define KXCJK1013_REG_WHO_AM_I		0x0F
-#define KXCJK1013_REG_INT_SRC1		0x16
+#define KXTF9_REG_TILT_POS_CUR		0x10
+#define KXTF9_REG_TILT_POS_PREV		0x11
+#define KXTF9_REG_INT_SRC1		0x15
+#define KXCJK1013_REG_INT_SRC1		0x16	/* compatible, but called INT_SRC2 in KXTF9 ds */
 #define KXCJK1013_REG_INT_SRC2		0x17
 #define KXCJK1013_REG_STATUS_REG	0x18
 #define KXCJK1013_REG_INT_REL		0x1A
 #define KXCJK1013_REG_CTRL1		0x1B
-#define KXCJK1013_REG_CTRL2		0x1D
+#define KXTF9_REG_CTRL2			0x1C
+#define KXCJK1013_REG_CTRL2		0x1D	/* mostly compatible, CTRL_REG3 in KTXF9 ds */
 #define KXCJK1013_REG_INT_CTRL1		0x1E
 #define KXCJK1013_REG_INT_CTRL2		0x1F
+#define KXTF9_REG_INT_CTRL3		0x20
 #define KXCJK1013_REG_DATA_CTRL		0x21
+#define KXTF9_REG_TILT_TIMER		0x28
 #define KXCJK1013_REG_WAKE_TIMER	0x29
+#define KXTF9_REG_TDT_TIMER		0x2B
+#define KXTF9_REG_TDT_THRESH_H		0x2C
+#define KXTF9_REG_TDT_THRESH_L		0x2D
+#define KXTF9_REG_TDT_TAP_TIMER		0x2E
+#define KXTF9_REG_TDT_TOTAL_TIMER	0x2F
+#define KXTF9_REG_TDT_LATENCY_TIMER	0x30
+#define KXTF9_REG_TDT_WINDOW_TIMER	0x31
 #define KXCJK1013_REG_SELF_TEST		0x3A
+#define KXTF9_REG_WAKE_THRESH		0x5A
+#define KXTF9_REG_TILT_ANGLE		0x5C
+#define KXTF9_REG_HYST_SET		0x5F
 #define KXCJK1013_REG_WAKE_THRES	0x6A
 
 #define KXCJK1013_REG_CTRL1_BIT_PC1	BIT(7)
@@ -67,14 +82,33 @@
 #define KXCJK1013_REG_CTRL1_BIT_GSEL1	BIT(4)
 #define KXCJK1013_REG_CTRL1_BIT_GSEL0	BIT(3)
 #define KXCJK1013_REG_CTRL1_BIT_WUFE	BIT(1)
-#define KXCJK1013_REG_INT_REG1_BIT_IEA	BIT(4)
-#define KXCJK1013_REG_INT_REG1_BIT_IEN	BIT(5)
+
+#define KXCJK1013_REG_INT_CTRL1_BIT_IEU	BIT(2)	/* KXTF9 */
+#define KXCJK1013_REG_INT_CTRL1_BIT_IEL	BIT(3)
+#define KXCJK1013_REG_INT_CTRL1_BIT_IEA	BIT(4)
+#define KXCJK1013_REG_INT_CTRL1_BIT_IEN	BIT(5)
+
+#define KXTF9_REG_TILT_BIT_LEFT_EDGE	BIT(5)
+#define KXTF9_REG_TILT_BIT_RIGHT_EDGE	BIT(4)
+#define KXTF9_REG_TILT_BIT_LOWER_EDGE	BIT(3)
+#define KXTF9_REG_TILT_BIT_UPPER_EDGE	BIT(2)
+#define KXTF9_REG_TILT_BIT_FACE_DOWN	BIT(1)
+#define KXTF9_REG_TILT_BIT_FACE_UP	BIT(0)
 
 #define KXCJK1013_DATA_MASK_12_BIT	0x0FFF
 #define KXCJK1013_MAX_STARTUP_TIME_US	100000
 
 #define KXCJK1013_SLEEP_DELAY_MS	2000
 
+#define KXCJK1013_REG_INT_SRC1_BIT_TPS	BIT(0)	/* KXTF9 */
+#define KXCJK1013_REG_INT_SRC1_BIT_WUFS	BIT(1)
+#define KXCJK1013_REG_INT_SRC1_MASK_TDTS	(BIT(2) | BIT(3))	/* KXTF9 */
+#define KXCJK1013_REG_INT_SRC1_TAP_NONE		0
+#define KXCJK1013_REG_INT_SRC1_TAP_SINGLE		BIT(2)
+#define KXCJK1013_REG_INT_SRC1_TAP_DOUBLE		BIT(3)
+#define KXCJK1013_REG_INT_SRC1_BIT_DRDY	BIT(4)
+
+/* KXCJK: INT_SOURCE2: motion detect, KXTF9: INT_SRC_REG1: tap detect */
 #define KXCJK1013_REG_INT_SRC2_BIT_ZP	BIT(0)
 #define KXCJK1013_REG_INT_SRC2_BIT_ZN	BIT(1)
 #define KXCJK1013_REG_INT_SRC2_BIT_YP	BIT(2)
@@ -88,6 +122,7 @@ enum kx_chipset {
 	KXCJK1013,
 	KXCJ91008,
 	KXTJ21009,
+	KXTF9,
 	KX_MAX_CHIPS /* this must be last */
 };
 
@@ -128,15 +163,42 @@ enum kxcjk1013_range {
 	KXCJK1013_RANGE_8G,
 };
 
-static const struct {
+struct kx_odr_map {
 	int val;
 	int val2;
 	int odr_bits;
-} samp_freq_table[] = { {0, 781000, 0x08}, {1, 563000, 0x09},
-			{3, 125000, 0x0A}, {6, 250000, 0x0B}, {12, 500000, 0},
-			{25, 0, 0x01}, {50, 0, 0x02}, {100, 0, 0x03},
-			{200, 0, 0x04}, {400, 0, 0x05}, {800, 0, 0x06},
-			{1600, 0, 0x07} };
+	int wuf_bits;
+};
+
+static const struct kx_odr_map samp_freq_table[] = {
+	{ 0, 781000, 0x08, 0x00 },
+	{ 1, 563000, 0x09, 0x01 },
+	{ 3, 125000, 0x0A, 0x02 },
+	{ 6, 250000, 0x0B, 0x03 },
+	{ 12, 500000, 0x00, 0x04 },
+	{ 25, 0, 0x01, 0x05 },
+	{ 50, 0, 0x02, 0x06 },
+	{ 100, 0, 0x03, 0x06 },
+	{ 200, 0, 0x04, 0x06 },
+	{ 400, 0, 0x05, 0x06 },
+	{ 800, 0, 0x06, 0x06 },
+	{ 1600, 0, 0x07, 0x06 },
+};
+
+static const char *const kxcjk1013_samp_freq_avail =
+	"0.781000 1.563000 3.125000 6.250000 12.500000 25 50 100 200 400 800 1600";
+
+static const struct kx_odr_map kxtf9_samp_freq_table[] = {
+	{ 25, 0, 0x01, 0x00 },
+	{ 50, 0, 0x02, 0x01 },
+	{ 100, 0, 0x03, 0x01 },
+	{ 200, 0, 0x04, 0x01 },
+	{ 400, 0, 0x05, 0x01 },
+	{ 800, 0, 0x06, 0x01 },
+};
+
+static const char *const kxtf9_samp_freq_avail =
+	"25 50 100 200 400 800";
 
 /* Refer to section 4 of the specification */
 static const struct {
@@ -188,6 +250,15 @@ static const struct {
 		{0x06, 3000},
 		{0x07, 2000},
 	},
+	/* KXTF9 */
+	{
+		{0x01, 81000},
+		{0x02, 41000},
+		{0x03, 21000},
+		{0x04, 11000},
+		{0x05, 5100},
+		{0x06, 2700},
+	},
 };
 
 static const struct {
@@ -198,23 +269,6 @@ static const struct {
 			      {19163, 1, 0},
 			      {38326, 0, 1} };
 
-static const struct {
-	int val;
-	int val2;
-	int odr_bits;
-} wake_odr_data_rate_table[] = { {0, 781000, 0x00},
-				 {1, 563000, 0x01},
-				 {3, 125000, 0x02},
-				 {6, 250000, 0x03},
-				 {12, 500000, 0x04},
-				 {25, 0, 0x05},
-				 {50, 0, 0x06},
-				 {100, 0, 0x06},
-				 {200, 0, 0x06},
-				 {400, 0, 0x06},
-				 {800, 0, 0x06},
-				 {1600, 0, 0x06} };
-
 static int kxcjk1013_set_mode(struct kxcjk1013_data *data,
 			      enum kxcjk1013_mode mode)
 {
@@ -341,9 +395,9 @@ static int kxcjk1013_chip_init(struct kxcjk1013_data *data)
 	}
 
 	if (data->active_high_intr)
-		ret |= KXCJK1013_REG_INT_REG1_BIT_IEA;
+		ret |= KXCJK1013_REG_INT_CTRL1_BIT_IEA;
 	else
-		ret &= ~KXCJK1013_REG_INT_REG1_BIT_IEA;
+		ret &= ~KXCJK1013_REG_INT_CTRL1_BIT_IEA;
 
 	ret = i2c_smbus_write_byte_data(data->client, KXCJK1013_REG_INT_CTRL1,
 					ret);
@@ -389,7 +443,7 @@ static int kxcjk1013_set_power_state(struct kxcjk1013_data *data, bool on)
 	}
 	if (ret < 0) {
 		dev_err(&data->client->dev,
-			"Failed: kxcjk1013_set_power_state for %d\n", on);
+			"Failed: %s for %d\n", __func__, on);
 		if (on)
 			pm_runtime_put_noidle(&data->client->dev);
 		return ret;
@@ -401,7 +455,7 @@ static int kxcjk1013_set_power_state(struct kxcjk1013_data *data, bool on)
 
 static int kxcjk1013_chip_update_thresholds(struct kxcjk1013_data *data)
 {
-	int ret;
+	int waketh_reg, ret;
 
 	ret = i2c_smbus_write_byte_data(data->client,
 					KXCJK1013_REG_WAKE_TIMER,
@@ -412,8 +466,9 @@ static int kxcjk1013_chip_update_thresholds(struct kxcjk1013_data *data)
 		return ret;
 	}
 
-	ret = i2c_smbus_write_byte_data(data->client,
-					KXCJK1013_REG_WAKE_THRES,
+	waketh_reg = data->chipset == KXTF9 ?
+		KXTF9_REG_WAKE_THRESH : KXCJK1013_REG_WAKE_THRES;
+	ret = i2c_smbus_write_byte_data(data->client, waketh_reg,
 					data->wake_thres);
 	if (ret < 0) {
 		dev_err(&data->client->dev, "Error writing reg_wake_thres\n");
@@ -449,9 +504,9 @@ static int kxcjk1013_setup_any_motion_interrupt(struct kxcjk1013_data *data,
 	}
 
 	if (status)
-		ret |= KXCJK1013_REG_INT_REG1_BIT_IEN;
+		ret |= KXCJK1013_REG_INT_CTRL1_BIT_IEN;
 	else
-		ret &= ~KXCJK1013_REG_INT_REG1_BIT_IEN;
+		ret &= ~KXCJK1013_REG_INT_CTRL1_BIT_IEN;
 
 	ret = i2c_smbus_write_byte_data(data->client, KXCJK1013_REG_INT_CTRL1,
 					ret);
@@ -509,9 +564,9 @@ static int kxcjk1013_setup_new_data_interrupt(struct kxcjk1013_data *data,
 	}
 
 	if (status)
-		ret |= KXCJK1013_REG_INT_REG1_BIT_IEN;
+		ret |= KXCJK1013_REG_INT_CTRL1_BIT_IEN;
 	else
-		ret &= ~KXCJK1013_REG_INT_REG1_BIT_IEN;
+		ret &= ~KXCJK1013_REG_INT_CTRL1_BIT_IEN;
 
 	ret = i2c_smbus_write_byte_data(data->client, KXCJK1013_REG_INT_CTRL1,
 					ret);
@@ -547,28 +602,30 @@ static int kxcjk1013_setup_new_data_interrupt(struct kxcjk1013_data *data,
 	return 0;
 }
 
-static int kxcjk1013_convert_freq_to_bit(int val, int val2)
+static const struct kx_odr_map *kxcjk1013_find_odr_value(
+	const struct kx_odr_map *map, size_t map_size, int val, int val2)
 {
 	int i;
 
-	for (i = 0; i < ARRAY_SIZE(samp_freq_table); ++i) {
-		if (samp_freq_table[i].val == val &&
-			samp_freq_table[i].val2 == val2) {
-			return samp_freq_table[i].odr_bits;
-		}
+	for (i = 0; i < map_size; ++i) {
+		if (map[i].val == val && map[i].val2 == val2)
+			return &map[i];
 	}
 
-	return -EINVAL;
+	return ERR_PTR(-EINVAL);
 }
 
-static int kxcjk1013_convert_wake_odr_to_bit(int val, int val2)
+static int kxcjk1013_convert_odr_value(const struct kx_odr_map *map,
+				       size_t map_size, int odr_bits,
+				       int *val, int *val2)
 {
 	int i;
 
-	for (i = 0; i < ARRAY_SIZE(wake_odr_data_rate_table); ++i) {
-		if (wake_odr_data_rate_table[i].val == val &&
-			wake_odr_data_rate_table[i].val2 == val2) {
-			return wake_odr_data_rate_table[i].odr_bits;
+	for (i = 0; i < map_size; ++i) {
+		if (map[i].odr_bits == odr_bits) {
+			*val = map[i].val;
+			*val2 = map[i].val2;
+			return IIO_VAL_INT_PLUS_MICRO;
 		}
 	}
 
@@ -578,16 +635,24 @@ static int kxcjk1013_convert_wake_odr_to_bit(int val, int val2)
 static int kxcjk1013_set_odr(struct kxcjk1013_data *data, int val, int val2)
 {
 	int ret;
-	int odr_bits;
 	enum kxcjk1013_mode store_mode;
+	const struct kx_odr_map *odr_setting;
 
 	ret = kxcjk1013_get_mode(data, &store_mode);
 	if (ret < 0)
 		return ret;
 
-	odr_bits = kxcjk1013_convert_freq_to_bit(val, val2);
-	if (odr_bits < 0)
-		return odr_bits;
+	if (data->chipset == KXTF9)
+		odr_setting = kxcjk1013_find_odr_value(kxtf9_samp_freq_table,
+						       ARRAY_SIZE(kxtf9_samp_freq_table),
+						       val, val2);
+	else
+		odr_setting = kxcjk1013_find_odr_value(samp_freq_table,
+						       ARRAY_SIZE(samp_freq_table),
+						       val, val2);
+
+	if (IS_ERR(odr_setting))
+		return PTR_ERR(odr_setting);
 
 	/* To change ODR, the chip must be set to STANDBY as per spec */
 	ret = kxcjk1013_set_mode(data, STANDBY);
@@ -595,20 +660,16 @@ static int kxcjk1013_set_odr(struct kxcjk1013_data *data, int val, int val2)
 		return ret;
 
 	ret = i2c_smbus_write_byte_data(data->client, KXCJK1013_REG_DATA_CTRL,
-					odr_bits);
+					odr_setting->odr_bits);
 	if (ret < 0) {
 		dev_err(&data->client->dev, "Error writing data_ctrl\n");
 		return ret;
 	}
 
-	data->odr_bits = odr_bits;
-
-	odr_bits = kxcjk1013_convert_wake_odr_to_bit(val, val2);
-	if (odr_bits < 0)
-		return odr_bits;
+	data->odr_bits = odr_setting->odr_bits;
 
 	ret = i2c_smbus_write_byte_data(data->client, KXCJK1013_REG_CTRL2,
-					odr_bits);
+					odr_setting->wuf_bits);
 	if (ret < 0) {
 		dev_err(&data->client->dev, "Error writing reg_ctrl2\n");
 		return ret;
@@ -625,17 +686,14 @@ static int kxcjk1013_set_odr(struct kxcjk1013_data *data, int val, int val2)
 
 static int kxcjk1013_get_odr(struct kxcjk1013_data *data, int *val, int *val2)
 {
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(samp_freq_table); ++i) {
-		if (samp_freq_table[i].odr_bits == data->odr_bits) {
-			*val = samp_freq_table[i].val;
-			*val2 = samp_freq_table[i].val2;
-			return IIO_VAL_INT_PLUS_MICRO;
-		}
-	}
-
-	return -EINVAL;
+	if (data->chipset == KXTF9)
+		return kxcjk1013_convert_odr_value(kxtf9_samp_freq_table,
+						   ARRAY_SIZE(kxtf9_samp_freq_table),
+						   data->odr_bits, val, val2);
+	else
+		return kxcjk1013_convert_odr_value(samp_freq_table,
+						   ARRAY_SIZE(samp_freq_table),
+						   data->odr_bits, val, val2);
 }
 
 static int kxcjk1013_get_acc_reg(struct kxcjk1013_data *data, int axis)
@@ -886,13 +944,29 @@ static int kxcjk1013_buffer_postdisable(struct iio_dev *indio_dev)
 	return kxcjk1013_set_power_state(data, false);
 }
 
-static IIO_CONST_ATTR_SAMP_FREQ_AVAIL(
-	"0.781000 1.563000 3.125000 6.250000 12.500000 25 50 100 200 400 800 1600");
+static ssize_t kxcjk1013_get_samp_freq_avail(struct device *dev,
+					     struct device_attribute *attr,
+					     char *buf)
+{
+	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
+	struct kxcjk1013_data *data = iio_priv(indio_dev);
+	const char *str;
+
+	if (data->chipset == KXTF9)
+		str = kxtf9_samp_freq_avail;
+	else
+		str = kxcjk1013_samp_freq_avail;
+
+	return sprintf(buf, "%s\n", str);
+}
+
+static IIO_DEVICE_ATTR(in_accel_sampling_frequency_available, S_IRUGO,
+		       kxcjk1013_get_samp_freq_avail, NULL, 0);
 
 static IIO_CONST_ATTR(in_accel_scale_available, "0.009582 0.019163 0.038326");
 
 static struct attribute *kxcjk1013_attributes[] = {
-	&iio_const_attr_sampling_frequency_available.dev_attr.attr,
+	&iio_dev_attr_in_accel_sampling_frequency_available.dev_attr.attr,
 	&iio_const_attr_in_accel_scale_available.dev_attr.attr,
 	NULL,
 };
@@ -950,7 +1024,6 @@ static const struct iio_info kxcjk1013_info = {
 	.write_event_value	= kxcjk1013_write_event,
 	.write_event_config	= kxcjk1013_write_event_config,
 	.read_event_config	= kxcjk1013_read_event_config,
-	.driver_module		= THIS_MODULE,
 };
 
 static const unsigned long kxcjk1013_scan_masks[] = {0x7, 0};
@@ -1036,9 +1109,74 @@ static int kxcjk1013_data_rdy_trigger_set_state(struct iio_trigger *trig,
 static const struct iio_trigger_ops kxcjk1013_trigger_ops = {
 	.set_trigger_state = kxcjk1013_data_rdy_trigger_set_state,
 	.try_reenable = kxcjk1013_trig_try_reen,
-	.owner = THIS_MODULE,
 };
 
+static void kxcjk1013_report_motion_event(struct iio_dev *indio_dev)
+{
+	struct kxcjk1013_data *data = iio_priv(indio_dev);
+
+	int ret = i2c_smbus_read_byte_data(data->client,
+					   KXCJK1013_REG_INT_SRC2);
+	if (ret < 0) {
+		dev_err(&data->client->dev, "Error reading reg_int_src2\n");
+		return;
+	}
+
+	if (ret & KXCJK1013_REG_INT_SRC2_BIT_XN)
+		iio_push_event(indio_dev,
+			       IIO_MOD_EVENT_CODE(IIO_ACCEL,
+						  0,
+						  IIO_MOD_X,
+						  IIO_EV_TYPE_THRESH,
+						  IIO_EV_DIR_FALLING),
+			       data->timestamp);
+
+	if (ret & KXCJK1013_REG_INT_SRC2_BIT_XP)
+		iio_push_event(indio_dev,
+			       IIO_MOD_EVENT_CODE(IIO_ACCEL,
+						  0,
+						  IIO_MOD_X,
+						  IIO_EV_TYPE_THRESH,
+						  IIO_EV_DIR_RISING),
+			       data->timestamp);
+
+	if (ret & KXCJK1013_REG_INT_SRC2_BIT_YN)
+		iio_push_event(indio_dev,
+			       IIO_MOD_EVENT_CODE(IIO_ACCEL,
+						  0,
+						  IIO_MOD_Y,
+						  IIO_EV_TYPE_THRESH,
+						  IIO_EV_DIR_FALLING),
+			       data->timestamp);
+
+	if (ret & KXCJK1013_REG_INT_SRC2_BIT_YP)
+		iio_push_event(indio_dev,
+			       IIO_MOD_EVENT_CODE(IIO_ACCEL,
+						  0,
+						  IIO_MOD_Y,
+						  IIO_EV_TYPE_THRESH,
+						  IIO_EV_DIR_RISING),
+			       data->timestamp);
+
+	if (ret & KXCJK1013_REG_INT_SRC2_BIT_ZN)
+		iio_push_event(indio_dev,
+			       IIO_MOD_EVENT_CODE(IIO_ACCEL,
+						  0,
+						  IIO_MOD_Z,
+						  IIO_EV_TYPE_THRESH,
+						  IIO_EV_DIR_FALLING),
+			       data->timestamp);
+
+	if (ret & KXCJK1013_REG_INT_SRC2_BIT_ZP)
+		iio_push_event(indio_dev,
+			       IIO_MOD_EVENT_CODE(IIO_ACCEL,
+						  0,
+						  IIO_MOD_Z,
+						  IIO_EV_TYPE_THRESH,
+						  IIO_EV_DIR_RISING),
+			       data->timestamp);
+}
+
 static irqreturn_t kxcjk1013_event_handler(int irq, void *private)
 {
 	struct iio_dev *indio_dev = private;
@@ -1051,66 +1189,17 @@ static irqreturn_t kxcjk1013_event_handler(int irq, void *private)
 		goto ack_intr;
 	}
 
-	if (ret & 0x02) {
-		ret = i2c_smbus_read_byte_data(data->client,
-					       KXCJK1013_REG_INT_SRC2);
-		if (ret < 0) {
-			dev_err(&data->client->dev,
-				"Error reading reg_int_src2\n");
-			goto ack_intr;
-		}
-
-		if (ret & KXCJK1013_REG_INT_SRC2_BIT_XN)
+	if (ret & KXCJK1013_REG_INT_SRC1_BIT_WUFS) {
+		if (data->chipset == KXTF9)
 			iio_push_event(indio_dev,
 				       IIO_MOD_EVENT_CODE(IIO_ACCEL,
 				       0,
-				       IIO_MOD_X,
-				       IIO_EV_TYPE_THRESH,
-				       IIO_EV_DIR_FALLING),
-				       data->timestamp);
-		if (ret & KXCJK1013_REG_INT_SRC2_BIT_XP)
-			iio_push_event(indio_dev,
-				       IIO_MOD_EVENT_CODE(IIO_ACCEL,
-				       0,
-				       IIO_MOD_X,
-				       IIO_EV_TYPE_THRESH,
-				       IIO_EV_DIR_RISING),
-				       data->timestamp);
-
-
-		if (ret & KXCJK1013_REG_INT_SRC2_BIT_YN)
-			iio_push_event(indio_dev,
-				       IIO_MOD_EVENT_CODE(IIO_ACCEL,
-				       0,
-				       IIO_MOD_Y,
-				       IIO_EV_TYPE_THRESH,
-				       IIO_EV_DIR_FALLING),
-				       data->timestamp);
-		if (ret & KXCJK1013_REG_INT_SRC2_BIT_YP)
-			iio_push_event(indio_dev,
-				       IIO_MOD_EVENT_CODE(IIO_ACCEL,
-				       0,
-				       IIO_MOD_Y,
-				       IIO_EV_TYPE_THRESH,
-				       IIO_EV_DIR_RISING),
-				       data->timestamp);
-
-		if (ret & KXCJK1013_REG_INT_SRC2_BIT_ZN)
-			iio_push_event(indio_dev,
-				       IIO_MOD_EVENT_CODE(IIO_ACCEL,
-				       0,
-				       IIO_MOD_Z,
-				       IIO_EV_TYPE_THRESH,
-				       IIO_EV_DIR_FALLING),
-				       data->timestamp);
-		if (ret & KXCJK1013_REG_INT_SRC2_BIT_ZP)
-			iio_push_event(indio_dev,
-				       IIO_MOD_EVENT_CODE(IIO_ACCEL,
-				       0,
-				       IIO_MOD_Z,
+				       IIO_MOD_X_AND_Y_AND_Z,
 				       IIO_EV_TYPE_THRESH,
 				       IIO_EV_DIR_RISING),
 				       data->timestamp);
+		else
+			kxcjk1013_report_motion_event(indio_dev);
 	}
 
 ack_intr:
@@ -1340,6 +1429,8 @@ static int kxcjk1013_resume(struct device *dev)
 
 	mutex_lock(&data->mutex);
 	ret = kxcjk1013_set_mode(data, OPERATION);
+	if (ret == 0)
+		ret = kxcjk1013_set_range(data, data->range);
 	mutex_unlock(&data->mutex);
 
 	return ret;
@@ -1392,8 +1483,13 @@ static const struct acpi_device_id kx_acpi_match[] = {
 	{"KXCJ1013", KXCJK1013},
 	{"KXCJ1008", KXCJ91008},
 	{"KXCJ9000", KXCJ91008},
+	{"KIOX0008", KXCJ91008},
+	{"KIOX0009", KXTJ21009},
 	{"KIOX000A", KXCJ91008},
+	{"KIOX010A", KXCJ91008}, /* KXCJ91008 in the display of a yoga 2-in-1 */
+	{"KIOX020A", KXCJ91008}, /* KXCJ91008 in the base of a yoga 2-in-1 */
 	{"KXTJ1009", KXTJ21009},
+	{"KXJ2109",  KXTJ21009},
 	{"SMO8500",  KXCJ91008},
 	{ },
 };
@@ -1403,16 +1499,27 @@ static const struct i2c_device_id kxcjk1013_id[] = {
 	{"kxcjk1013", KXCJK1013},
 	{"kxcj91008", KXCJ91008},
 	{"kxtj21009", KXTJ21009},
+	{"kxtf9",     KXTF9},
 	{"SMO8500",   KXCJ91008},
 	{}
 };
 
 MODULE_DEVICE_TABLE(i2c, kxcjk1013_id);
 
+static const struct of_device_id kxcjk1013_of_match[] = {
+	{ .compatible = "kionix,kxcjk1013", },
+	{ .compatible = "kionix,kxcj91008", },
+	{ .compatible = "kionix,kxtj21009", },
+	{ .compatible = "kionix,kxtf9", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, kxcjk1013_of_match);
+
 static struct i2c_driver kxcjk1013_driver = {
 	.driver = {
 		.name	= KXCJK1013_DRV_NAME,
 		.acpi_match_table = ACPI_PTR(kx_acpi_match),
+		.of_match_table = kxcjk1013_of_match,
 		.pm	= &kxcjk1013_pm_ops,
 	},
 	.probe		= kxcjk1013_probe,
@@ -1423,4 +1530,4 @@ module_i2c_driver(kxcjk1013_driver);
 
 MODULE_AUTHOR("Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>");
 MODULE_LICENSE("GPL v2");
-MODULE_DESCRIPTION("KXCJK1013 accelerometer driver");
+MODULE_DESCRIPTION("KXCJK1013 accelerometer driver");
\ No newline at end of file
-- 
2.7.4

