From c54e5f4464cfa7e3298c8026504cb6ebaba3a4b2 Mon Sep 17 00:00:00 2001
From: Peter Fitger <peter.fitger@flir.se>
Date: Wed, 20 Mar 2019 12:52:22 +0100
Subject: [PATCH] Add LM3642 Torch and Flash driver

---
 arch/arm/boot/dts/imx7ulp-ec201.dtsi |  42 +++---
 drivers/leds/leds-lm3642.c           | 202 +++++++++++++++++++--------
 2 files changed, 163 insertions(+), 81 deletions(-)

diff --git a/arch/arm/boot/dts/imx7ulp-ec201.dtsi b/arch/arm/boot/dts/imx7ulp-ec201.dtsi
index 77cd344332b4..447cd39e1463 100644
--- a/arch/arm/boot/dts/imx7ulp-ec201.dtsi
+++ b/arch/arm/boot/dts/imx7ulp-ec201.dtsi
@@ -40,26 +40,6 @@
 		};
 	};
 
-//  /* Torch PWM, LPTPM7 (PTC15) */
-//  pwm1: tpm@40280000 {
-//      compatible = "nxp,tpm-pwm";
-//      reg = <0x40280000 0x1000>;
-//      nxp,pwm-number = <6>;
-//      assigned-clocks = <&clks IMX7ULP_CLK_LPTPM7>;
-//      assigned-clock-parents = <&clks IMX7ULP_CLK_SOSC_BUS_CLK>;
-//      clocks = <&clks IMX7ULP_CLK_LPTPM7>;
-//      #pwm-cells = <2>;
-//      pinctrl-names = "default", "sleep";
-//      pinctrl-0 = <&pinctrl_pwm1>;
-//      pinctrl-1 = <&pinctrl_pwm1>;
-//  };
-//
-//  pwm1_torch {
-//      compatible = "pwm-backlight";
-//      pwms = <&pwm1 0 200000>; // 0.2ms
-//      brightness-levels = <0 10 20 30 40 50 60 70 80 90 100>;
-//  };
-
 	gpio_keys {
 		compatible = "gpio-keys";
 		pinctrl-names = "default";
@@ -197,12 +177,6 @@
 			>;
 		};
 
-//	pinctrl_pwm1: pwm1_grp {
-//		fsl,pins = <
-//			IMX7ULP_PAD_PTC15__TPM7_CH1  0x3
-//			>;
-//	};
-
 	pinctrl_lpi2c5: lpi2c5grp {
 		fsl,pins = <
 			IMX7ULP_PAD_PTC4__LPI2C5_SCL    0x27
@@ -217,6 +191,8 @@
 			IMX7ULP_PAD_PTC8__LPI2C6_SCL    0x27
 			IMX7ULP_PAD_PTC9__LPI2C6_SDA    0x27
 			IMX7ULP_PAD_PTC10__PTC10        0x2 /* ACC_INT_n */
+			IMX7ULP_PAD_PTC15__PTC15  	0x3 /* TORCH */
+			IMX7ULP_PAD_PTC16__PTC16  	0x3 /* STROBE */
 			>;
 	};
 
@@ -437,6 +413,20 @@
 		reg = <0x57>;
 		pagesize = <16>;
 	};
+	
+	torch: torch@63 {
+		compatible = "leds-lm3642";
+		reg = <0x63>;
+		
+		flash-ramp = <3>;       /* 010b = 2 ms */
+		flash-time-out = <7>;   /* 111b = 800 ms */ 
+		torch-max-current = <3>;/* 011b = 375 mA */
+		flash-max-current = <7>;/* 0111b = 750 mA */
+		ivfm = <3>;		/* 011b = 3.2 V */
+		torch-ramp = <5>;	/* 101b = 512 ms */
+		torch-gpios = <&gpio_ptc 15 GPIO_ACTIVE_HIGH>;
+		strobe-gpios = <&gpio_ptc 16 GPIO_ACTIVE_HIGH>;
+	};
 };
 
 /* Touch screen */
diff --git a/drivers/leds/leds-lm3642.c b/drivers/leds/leds-lm3642.c
index cada0848db7b..6235fb1d27a7 100644
--- a/drivers/leds/leds-lm3642.c
+++ b/drivers/leds/leds-lm3642.c
@@ -16,6 +16,8 @@
 #include <linux/fs.h>
 #include <linux/regmap.h>
 #include <linux/platform_data/leds-lm3642.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
 
 #define	REG_FILT_TIME			(0x0)
 #define	REG_IVFM_MODE			(0x1)
@@ -76,11 +78,20 @@ struct lm3642_chip_data {
 	u8 br_torch;
 	u8 br_indicator;
 
+	u8 max_torch_current;
+	u8 max_flash_current;
+	u8 max_indicator_current;
+
+	u8 opmode;
+
 	enum lm3642_torch_pin_enable torch_pin;
 	enum lm3642_strobe_pin_enable strobe_pin;
 	enum lm3642_tx_pin_enable tx_pin;
 
-	struct lm3642_platform_data *pdata;
+	int tx_gpio;
+	int torch_gpio;
+	int strobe_gpio;
+
 	struct regmap *regmap;
 	struct mutex lock;
 
@@ -91,11 +102,10 @@ struct lm3642_chip_data {
 static int lm3642_chip_init(struct lm3642_chip_data *chip)
 {
 	int ret;
-	struct lm3642_platform_data *pdata = chip->pdata;
 
 	/* set enable register */
 	ret = regmap_update_bits(chip->regmap, REG_ENABLE, EX_PIN_ENABLE_MASK,
-				 pdata->tx_pin);
+				 chip->tx_pin);
 	if (ret < 0)
 		dev_err(chip->dev, "Failed to update REG_ENABLE Register\n");
 	return ret;
@@ -117,52 +127,75 @@ static int lm3642_control(struct lm3642_chip_data *chip,
 		dev_info(chip->dev, "Last FLAG is 0x%x\n", chip->last_flag);
 
 	/* brightness 0 means off-state */
-	if (!brightness)
-		opmode = MODES_STASNDBY;
-
-	switch (opmode) {
-	case MODES_TORCH:
-		ret = regmap_update_bits(chip->regmap, REG_I_CTRL,
-					 TORCH_I_MASK << TORCH_I_SHIFT,
-					 (brightness - 1) << TORCH_I_SHIFT);
-
-		if (chip->torch_pin)
-			opmode |= (TORCH_PIN_EN_MASK << TORCH_PIN_EN_SHIFT);
-		break;
-
-	case MODES_FLASH:
-		ret = regmap_update_bits(chip->regmap, REG_I_CTRL,
-					 FLASH_I_MASK << FLASH_I_SHIFT,
-					 (brightness - 1) << FLASH_I_SHIFT);
-
-		if (chip->strobe_pin)
-			opmode |= (STROBE_PIN_EN_MASK << STROBE_PIN_EN_SHIFT);
-		break;
-
-	case MODES_INDIC:
-		ret = regmap_update_bits(chip->regmap, REG_I_CTRL,
-					 TORCH_I_MASK << TORCH_I_SHIFT,
-					 (brightness - 1) << TORCH_I_SHIFT);
-		break;
-
-	case MODES_STASNDBY:
-
-		break;
-
-	default:
-		return ret;
+	if (!brightness) {
+		chip->opmode &= EX_PIN_ENABLE_MASK;	/* Set standby mode */
+
+		switch (opmode) {
+		case MODES_TORCH:
+			chip->opmode &= ~(TORCH_PIN_EN_MASK << TORCH_PIN_EN_SHIFT);
+			if (chip->torch_gpio)
+				gpio_set_value(chip->torch_gpio, 0);
+			break;
+
+		case MODES_FLASH:
+			chip->opmode &= ~(STROBE_PIN_EN_MASK << STROBE_PIN_EN_SHIFT);
+			if (chip->strobe_gpio)
+				gpio_set_value(chip->strobe_gpio, 0);
+			break;
+
+		case MODES_INDIC:
+			chip->opmode &= ~(TX_PIN_EN_MASK << TX_PIN_EN_SHIFT);
+			if (chip->tx_gpio)
+				gpio_set_value(chip->tx_gpio, 0);
+			break;
+
+		default:
+			goto out;
+		}
+	} else {
+		switch (opmode) {
+		case MODES_TORCH:
+			ret = regmap_update_bits(chip->regmap, REG_I_CTRL,
+						 TORCH_I_MASK << TORCH_I_SHIFT,
+						 (brightness - 1) << TORCH_I_SHIFT);
+			if (chip->torch_pin)
+				chip->opmode |= (TORCH_PIN_EN_MASK << TORCH_PIN_EN_SHIFT) | opmode;
+			if (chip->torch_gpio)
+				gpio_set_value(chip->torch_gpio, 1);
+			break;
+
+		case MODES_FLASH:
+			ret = regmap_update_bits(chip->regmap, REG_I_CTRL,
+						 FLASH_I_MASK << FLASH_I_SHIFT,
+						 (brightness - 1) << FLASH_I_SHIFT);
+			if (chip->strobe_pin)
+				chip->opmode |= (STROBE_PIN_EN_MASK << STROBE_PIN_EN_SHIFT) | opmode;
+			if (chip->strobe_gpio)
+				gpio_set_value(chip->strobe_gpio, 1);
+			break;
+
+		case MODES_INDIC:
+			ret = regmap_update_bits(chip->regmap, REG_I_CTRL,
+						 TORCH_I_MASK << TORCH_I_SHIFT,
+						 (brightness - 1) << TORCH_I_SHIFT);
+			if (chip->tx_pin)
+				chip->opmode |= (TX_PIN_EN_MASK << TX_PIN_EN_SHIFT) | opmode;
+			if (chip->tx_gpio)
+				gpio_set_value(chip->tx_gpio, 1);
+			break;
+
+		default:
+			goto out;
+		}
 	}
 	if (ret < 0) {
 		dev_err(chip->dev, "Failed to write REG_I_CTRL Register\n");
 		goto out;
 	}
 
-	if (chip->tx_pin)
-		opmode |= (TX_PIN_EN_MASK << TX_PIN_EN_SHIFT);
-
 	ret = regmap_update_bits(chip->regmap, REG_ENABLE,
 				 MODE_BITS_MASK << MODE_BITS_SHIFT,
-				 opmode << MODE_BITS_SHIFT);
+				 chip->opmode << MODE_BITS_SHIFT);
 out:
 	return ret;
 }
@@ -305,9 +338,10 @@ ATTRIBUTE_GROUPS(lm3642_torch);
 static int lm3642_probe(struct i2c_client *client,
 				  const struct i2c_device_id *id)
 {
-	struct lm3642_platform_data *pdata = dev_get_platdata(&client->dev);
 	struct lm3642_chip_data *chip;
-
+	struct device_node *np = client->dev.of_node;
+	u32 value;
+	int gpio;
 	int err;
 
 	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
@@ -315,22 +349,15 @@ static int lm3642_probe(struct i2c_client *client,
 		return -EOPNOTSUPP;
 	}
 
-	if (pdata == NULL) {
-		dev_err(&client->dev, "needs Platform Data.\n");
-		return -ENODATA;
-	}
-
 	chip = devm_kzalloc(&client->dev,
 			    sizeof(struct lm3642_chip_data), GFP_KERNEL);
 	if (!chip)
 		return -ENOMEM;
 
 	chip->dev = &client->dev;
-	chip->pdata = pdata;
 
-	chip->tx_pin = pdata->tx_pin;
-	chip->torch_pin = pdata->torch_pin;
-	chip->strobe_pin = pdata->strobe_pin;
+	if (!np)
+		return -EINVAL;
 
 	chip->regmap = devm_regmap_init_i2c(client, &lm3642_regmap);
 	if (IS_ERR(chip->regmap)) {
@@ -343,13 +370,78 @@ static int lm3642_probe(struct i2c_client *client,
 	mutex_init(&chip->lock);
 	i2c_set_clientdata(client, chip);
 
+	/* Read control values from device tree */
+	if (of_property_read_u32(np, "flash-ramp", &value) == 0) {
+		err = regmap_update_bits(chip->regmap, REG_FLASH,
+				FLASH_RAMP_TIME_MASK << FLASH_RAMP_TIME_SHIFT,
+				value << FLASH_RAMP_TIME_SHIFT);
+	}
+	if (of_property_read_u32(np, "flash-time-out", &value) == 0) {
+		err = regmap_update_bits(chip->regmap, REG_FLASH,
+				FLASH_TOUT_TIME_MASK << FLASH_TOUT_TIME_SHIFT,
+				value << FLASH_TOUT_TIME_SHIFT);
+	}
+	if (of_property_read_u32(np, "ivfm", &value) == 0) {
+		err = regmap_update_bits(chip->regmap, REG_IVFM_MODE,
+				IVM_D_TH_MASK << IVM_D_TH_SHIFT,
+				value << IVM_D_TH_SHIFT);
+	}
+	if (of_property_read_u32(np, "torch-ramp", &value) == 0) {
+		err = regmap_update_bits(chip->regmap, REG_TORCH_TIME,
+				TORCH_RAMP_UP_TIME_MASK << TORCH_RAMP_UP_TIME_SHIFT,
+				value << TORCH_RAMP_UP_TIME_SHIFT);
+		err |= regmap_update_bits(chip->regmap, REG_TORCH_TIME,
+				TORCH_RAMP_DN_TIME_MASK << TORCH_RAMP_DN_TIME_SHIFT,
+				value << TORCH_RAMP_DN_TIME_SHIFT);
+	}
+
+	/* Read maximum currents from device tree */
+	chip->max_indicator_current = 8;
+	chip->max_torch_current = 8;
+	chip->max_flash_current = 16;
+	if (of_property_read_u32(np, "indicator-max-current", &value) == 0) {
+		chip->max_indicator_current = value + 1;
+	}
+	if (of_property_read_u32(np, "torch-max-current", &value) == 0) {
+		chip->max_torch_current = value + 1;
+	}
+	if (of_property_read_u32(np, "flash-max-current", &value) == 0) {
+		chip->max_flash_current = value + 1;
+	}
+
+	/* Read gpio signals from device tree */
+	gpio = of_get_named_gpio(np, "tx-gpios", 0);
+	if (gpio_is_valid(gpio)) {
+		err = devm_gpio_request_one(chip->dev, gpio, GPIOF_OUT_INIT_LOW, "tx-gpio");
+		if (err < 0)
+			goto err_out;
+		chip->tx_pin = LM3642_TX_PIN_ENABLE;
+		chip->tx_gpio = gpio;
+	}
+	gpio = of_get_named_gpio(np, "torch-gpios", 0);
+	if (gpio_is_valid(gpio)) {
+		err = devm_gpio_request_one(chip->dev, gpio, GPIOF_OUT_INIT_LOW, "torch-gpio");
+		if (err < 0)
+			goto err_out;
+		chip->torch_pin = LM3642_TORCH_PIN_ENABLE;
+		chip->torch_gpio = gpio;
+	}
+	gpio = of_get_named_gpio(np, "strobe-gpios", 0);
+	if (gpio_is_valid(gpio)) {
+		err = devm_gpio_request_one(chip->dev, gpio, GPIOF_OUT_INIT_LOW, "strobe-gpio");
+		if (err < 0)
+			goto err_out;
+		chip->strobe_pin = LM3642_STROBE_PIN_ENABLE;
+		chip->strobe_gpio = gpio;
+	}
+
 	err = lm3642_chip_init(chip);
 	if (err < 0)
 		goto err_out;
 
 	/* flash */
 	chip->cdev_flash.name = "flash";
-	chip->cdev_flash.max_brightness = 16;
+	chip->cdev_flash.max_brightness = chip->max_flash_current;
 	chip->cdev_flash.brightness_set_blocking = lm3642_strobe_brightness_set;
 	chip->cdev_flash.default_trigger = "flash";
 	chip->cdev_flash.groups = lm3642_flash_groups,
@@ -362,7 +454,7 @@ static int lm3642_probe(struct i2c_client *client,
 
 	/* torch */
 	chip->cdev_torch.name = "torch";
-	chip->cdev_torch.max_brightness = 8;
+	chip->cdev_torch.max_brightness = chip->max_torch_current;
 	chip->cdev_torch.brightness_set_blocking = lm3642_torch_brightness_set;
 	chip->cdev_torch.default_trigger = "torch";
 	chip->cdev_torch.groups = lm3642_torch_groups,
@@ -375,7 +467,7 @@ static int lm3642_probe(struct i2c_client *client,
 
 	/* indicator */
 	chip->cdev_indicator.name = "indicator";
-	chip->cdev_indicator.max_brightness = 8;
+	chip->cdev_indicator.max_brightness = chip->max_indicator_current;
 	chip->cdev_indicator.brightness_set_blocking =
 						lm3642_indicator_brightness_set;
 	err = led_classdev_register((struct device *)
-- 
2.17.1

