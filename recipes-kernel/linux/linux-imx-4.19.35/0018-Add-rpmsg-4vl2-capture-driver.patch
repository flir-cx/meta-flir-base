From 8bab46bdf081dbe2218012c44bc868aed3778877 Mon Sep 17 00:00:00 2001
From: Peter Fitger <peter.fitger@flir.se>
Date: Fri, 22 Feb 2019 16:12:46 +0100
Subject: [PATCH] Add rpmsg 4vl2 capture driver

Based on mxc_viu and ov5640_v2
---
 drivers/media/platform/mxc/capture/Kconfig    |   14 +-
 drivers/media/platform/mxc/capture/Makefile   |    5 +
 drivers/media/platform/mxc/capture/m4_rpmsg.c |  531 +++++++++
 .../media/platform/mxc/capture/mxc_rpmsg.c    | 1059 +++++++++++++++++
 4 files changed, 1608 insertions(+), 1 deletion(-)
 create mode 100644 drivers/media/platform/mxc/capture/m4_rpmsg.c
 create mode 100644 drivers/media/platform/mxc/capture/mxc_rpmsg.c

diff --git a/drivers/media/platform/mxc/capture/Kconfig b/drivers/media/platform/mxc/capture/Kconfig
index efd4ea6d5aba..c8f6fd0ef7f6 100644
--- a/drivers/media/platform/mxc/capture/Kconfig
+++ b/drivers/media/platform/mxc/capture/Kconfig
@@ -27,6 +27,12 @@ config MXC_VIU
 	---help---
 		This is a V4l2 capture driver based on VIU module.
 
+config VIDEO_MXC_RPMSG_CAMERA
+	tristate "mxc RPMSG support"
+	depends on VIDEO_MXC_CAPTURE
+	---help---
+		FLIR specific V4l2 capture driver based on RPMSG from M4.
+
 menu "MXC Camera/V4L2 PRP Features support"
 config VIDEO_MXC_IPU_CAMERA
 	tristate "MXC IPU Camera"
@@ -42,11 +48,17 @@ config MXC_CAMERA_OV5640
           If you plan to use the ov5640 Camera with your MXC system, say Y here.
 
 config MXC_CAMERA_OV5640_V2
-	tristate "OmniVision ov5640 camera support"
+	tristate "OmniVision ov5640 camera support v2"
 	depends on VIDEO_MXC_CAPTURE && I2C
 	help
 	  If you plan to use the ov5640 Camera with your MXC system, say Y here.
 
+config MXC_CAMERA_LEPTON_M4
+        tristate "Lepton-M4 camera support"
+	depends on VIDEO_MXC_RPMSG_CAMERA
+        ---help---
+          If you plan to use the Lepton-M4 Camera with your MXC system, say Y here.
+
 config MXC_CAMERA_OV5642
 	tristate "OmniVision ov5642 camera support"
 	depends on !VIDEO_MXC_EMMA_CAMERA && I2C
diff --git a/drivers/media/platform/mxc/capture/Makefile b/drivers/media/platform/mxc/capture/Makefile
index bae4a5adb71b..8d76256cf38b 100644
--- a/drivers/media/platform/mxc/capture/Makefile
+++ b/drivers/media/platform/mxc/capture/Makefile
@@ -39,3 +39,8 @@ adv7180_tvin-objs := adv7180.o
 obj-$(CONFIG_MXC_TVIN_ADV7180) += adv7180_tvin.o
 
 obj-$(CONFIG_VIDEO_V4L2_MXC_INT_DEVICE) += v4l2-int-device.o
+
+obj-$(CONFIG_VIDEO_MXC_RPMSG_CAMERA) += rpmsg_capture.o
+rpmsg_capture-objs := mxc_rpmsg.o
+
+obj-$(CONFIG_MXC_CAMERA_LEPTON_M4) += m4_rpmsg.o
diff --git a/drivers/media/platform/mxc/capture/m4_rpmsg.c b/drivers/media/platform/mxc/capture/m4_rpmsg.c
new file mode 100644
index 000000000000..a95a4426b0ce
--- /dev/null
+++ b/drivers/media/platform/mxc/capture/m4_rpmsg.c
@@ -0,0 +1,531 @@
+/*
+ * Copyright (C) 2012-2015 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+/* This file is based on rpmsg_v2.c */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/v4l2-mediabus.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ctrls.h>
+#include <linux/rpmsg.h>
+#include <linux/dma-mapping.h>
+
+#define MIN_FPS 9
+#define MAX_FPS 9
+#define DEFAULT_FPS 9
+
+enum ovRpmsg_mode {
+	ovRpmsg_mode_MIN = 0,
+	ovRpmsg_mode_QQVGA_160_120 = 0,
+	ovRpmsg_mode_MAX = 0
+};
+
+enum ovRpmsg_frame_rate {
+	ovRpmsg_9_fps,
+};
+
+struct ovRpmsg_datafmt {
+	u32	code;
+	enum v4l2_colorspace		colorspace;
+};
+
+struct ovRpmsg_mode_info {
+	enum ovRpmsg_mode mode;
+	u32 width;
+	u32 height;
+	struct reg_value *init_data_ptr;
+	u32 init_data_size;
+};
+
+// static struct sensor_data ovRpmsg_data;
+
+enum rxtypes {
+	RX_LUT,
+	RX_BUF_0,
+	RX_BUF_1,
+	RX_BUF_2,
+	RX_BUF_3,
+};
+
+struct csi_rx_msg {
+	uint32_t type;
+	uint32_t addr;
+};
+
+struct ovRpmsg {
+	struct v4l2_subdev		subdev;
+	struct v4l2_pix_format pix;
+	const struct ovRpmsg_datafmt	*fmt;
+	struct v4l2_captureparm streamcap;
+	struct rpmsg_device *rpmsg_dev;
+	void (*callback)(uint32_t addr, uint32_t buf_num, void *ptr);
+	void *callback_dev;
+	bool on;
+};
+
+/*!
+ * Maintains the information on the current state of the sesor.
+ */
+static struct ovRpmsg ovRpmsg_data;
+
+static const struct ovRpmsg_datafmt ovRpmsg_colour_fmts[] = {
+	{MEDIA_BUS_FMT_ARGB8888_1X32, V4L2_COLORSPACE_JPEG},
+};
+
+/* Find a data format by a pixel code in an array */
+static const struct ovRpmsg_datafmt
+			*rpmsg_find_datafmt(u32 code)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(ovRpmsg_colour_fmts); i++)
+		if (ovRpmsg_colour_fmts[i].code == code)
+			return ovRpmsg_colour_fmts + i;
+
+	return NULL;
+}
+
+/* change to or back to subsampling mode set the mode directly
+ * image size below 1280 * 960 is subsampling mode */
+static int rpmsg_change_mode_direct(enum ovRpmsg_frame_rate frame_rate,
+			    enum ovRpmsg_mode mode)
+{
+	pr_info("%s: width = %d, height = %d\n",
+		__func__, ovRpmsg_data.pix.width, ovRpmsg_data.pix.height);
+
+	pr_info("%s: mode = %d, frame_rate = %d bp2\n", __func__, mode, frame_rate);
+
+
+	if (mode != ovRpmsg_mode_QQVGA_160_120 || frame_rate != ovRpmsg_9_fps) {
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int rpmsg_change_mode(enum ovRpmsg_frame_rate frame_rate,
+			    enum ovRpmsg_mode mode)
+{
+	int retval = 0;
+
+	if (mode > ovRpmsg_mode_MAX || mode < ovRpmsg_mode_MIN) {
+		pr_err("Wrong rpmsg mode detected!\n");
+		return -1;
+	}
+
+	/* change back to subsampling modem download firmware directly
+	 * image size below 1280 * 960 is subsampling mode */
+	retval = rpmsg_change_mode_direct(frame_rate, mode);
+
+	return retval;
+}
+
+/*!
+ * rpmsg_s_power - V4L2 sensor interface handler for VIDIOC_S_POWER ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @on: indicates power mode (on or off)
+ *
+ * Turns the power on or off, depending on the value of on and returns the
+ * appropriate error code.
+ */
+static int rpmsg_s_power(struct v4l2_subdev *sd, int on)
+{
+	return 0;
+}
+
+/*!
+ * rpmsg_g_parm - V4L2 sensor interface handler for VIDIOC_G_PARM ioctl
+ * @s: pointer to standard V4L2 sub device structure
+ * @a: pointer to standard V4L2 VIDIOC_G_PARM ioctl structure
+ *
+ * Returns the sensor's video CAPTURE parameters.
+ */
+static int rpmsg_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
+{
+	struct v4l2_captureparm *cparm = &a->parm.capture;
+	int ret = 0;
+
+	switch (a->type) {
+	/* This is the only case currently handled. */
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+		memset(a, 0, sizeof(*a));
+		a->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		cparm->capability = 0;
+		cparm->timeperframe.denominator = DEFAULT_FPS;
+		cparm->timeperframe.numerator = 1;
+		cparm->capturemode = MEDIA_BUS_FMT_ARGB8888_1X32;
+		ret = 0;
+		break;
+
+	/* These are all the possible cases. */
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
+	case V4L2_BUF_TYPE_VBI_CAPTURE:
+	case V4L2_BUF_TYPE_VBI_OUTPUT:
+	case V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:
+	case V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:
+		ret = -EINVAL;
+		break;
+
+	default:
+		pr_debug("   type is unknown - %d\n", a->type);
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+/*!
+ * ov5460_s_parm - V4L2 sensor interface handler for VIDIOC_S_PARM ioctl
+ * @s: pointer to standard V4L2 sub device structure
+ * @a: pointer to standard V4L2 VIDIOC_S_PARM ioctl structure
+ *
+ * Configures the sensor to use the input parameters, if possible.  If
+ * not possible, reverts to the old parameters and returns the
+ * appropriate error code.
+ */
+static int rpmsg_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
+{
+	struct v4l2_fract *timeperframe = &a->parm.capture.timeperframe;
+	u32 tgt_fps;	/* target frames per secound */
+	enum ovRpmsg_frame_rate frame_rate;
+	int ret = 0;
+
+	switch (a->type) {
+	/* This is the only case currently handled. */
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+		/* Check that the new frame rate is allowed. */
+		if ((timeperframe->numerator == 0) ||
+		    (timeperframe->denominator == 0)) {
+			timeperframe->denominator = DEFAULT_FPS;
+			timeperframe->numerator = 1;
+		}
+
+		tgt_fps = timeperframe->denominator /
+			  timeperframe->numerator;
+
+		if (tgt_fps > MAX_FPS) {
+			timeperframe->denominator = MAX_FPS;
+			timeperframe->numerator = 1;
+		} else if (tgt_fps < MIN_FPS) {
+			timeperframe->denominator = MIN_FPS;
+			timeperframe->numerator = 1;
+		}
+
+		/* Actual frame rate we use */
+		tgt_fps = timeperframe->denominator /
+			  timeperframe->numerator;
+
+		if (tgt_fps == 9)
+			frame_rate = ovRpmsg_9_fps;
+		else {
+			pr_err(" The camera frame rate is not supported!\n");
+			goto error;
+		}
+
+		ret = rpmsg_change_mode(frame_rate,
+				a->parm.capture.capturemode);
+		if (ret < 0)
+			goto error;
+
+		break;
+
+	/* These are all the possible cases. */
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
+	case V4L2_BUF_TYPE_VBI_CAPTURE:
+	case V4L2_BUF_TYPE_VBI_OUTPUT:
+	case V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:
+	case V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:
+		pr_debug("   type is not " \
+			"V4L2_BUF_TYPE_VIDEO_CAPTURE but %d\n",
+			a->type);
+		ret = -EINVAL;
+		break;
+
+	default:
+		pr_debug("   type is unknown - %d\n", a->type);
+		ret = -EINVAL;
+		break;
+	}
+
+error:
+	return ret;
+}
+
+static int rpmsg_set_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_pad_config *cfg,
+			  struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+	const struct ovRpmsg_datafmt *fmt = rpmsg_find_datafmt(mf->code);
+
+	if (format->pad)
+		return -EINVAL;
+
+	if (!fmt) {
+		mf->code	= ovRpmsg_colour_fmts[0].code;
+		mf->colorspace	= ovRpmsg_colour_fmts[0].colorspace;
+	}
+
+	mf->field	= V4L2_FIELD_NONE;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		return 0;
+
+	return 0;
+}
+
+static int rpmsg_get_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_pad_config *cfg,
+			  struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+
+	if (format->pad)
+		return -EINVAL;
+
+	mf->code	= MEDIA_BUS_FMT_ARGB8888_1X32;
+	mf->colorspace	= V4L2_COLORSPACE_JPEG;
+	mf->field	= V4L2_FIELD_NONE;
+
+	return 0;
+}
+
+static int rpmsg_enum_code(struct v4l2_subdev *sd,
+			    struct v4l2_subdev_pad_config *cfg,
+			    struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->pad || code->index >= ARRAY_SIZE(ovRpmsg_colour_fmts))
+		return -EINVAL;
+
+	code->code = ovRpmsg_colour_fmts[code->index].code;
+	return 0;
+}
+
+/*!
+ * rpmsg_enum_framesizes - V4L2 sensor interface handler for
+ *			   VIDIOC_ENUM_FRAMESIZES ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @fsize: standard V4L2 VIDIOC_ENUM_FRAMESIZES ioctl structure
+ *
+ * Return 0 if successful, otherwise -EINVAL.
+ */
+static int rpmsg_enum_framesizes(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_pad_config *cfg,
+			       struct v4l2_subdev_frame_size_enum *fse)
+{
+	if (fse->index > ovRpmsg_mode_MAX)
+		return -EINVAL;
+
+	fse->max_width = 160;
+	fse->min_width = fse->max_width;
+	fse->max_height = 120;
+	fse->min_height = fse->max_height;
+	return 0;
+}
+
+/*!
+ * rpmsg_enum_frameintervals - V4L2 sensor interface handler for
+ *			       VIDIOC_ENUM_FRAMEINTERVALS ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @fival: standard V4L2 VIDIOC_ENUM_FRAMEINTERVALS ioctl structure
+ *
+ * Return 0 if successful, otherwise -EINVAL.
+ */
+static int rpmsg_enum_frameintervals(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_frame_interval_enum *fie)
+{
+	if (fie->index != 0)
+		return -EINVAL;
+
+	if (fie->width == 0 || fie->height == 0 ||
+	    fie->code == 0) {
+		pr_warning("Please assign pixel format, width and height.\n");
+		return -EINVAL;
+	}
+
+	fie->interval.numerator = 1;
+
+	if (fie->width == 160 && fie->height == 120) {
+		fie->interval.denominator = 9;
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static struct v4l2_subdev_video_ops rpmsg_subdev_video_ops = {
+	.g_parm = rpmsg_g_parm,
+	.s_parm = rpmsg_s_parm,
+};
+
+static const struct v4l2_subdev_pad_ops rpmsg_subdev_pad_ops = {
+	.enum_frame_size       = rpmsg_enum_framesizes,
+	.enum_frame_interval   = rpmsg_enum_frameintervals,
+	.enum_mbus_code        = rpmsg_enum_code,
+	.set_fmt               = rpmsg_set_fmt,
+	.get_fmt               = rpmsg_get_fmt,
+};
+
+static struct v4l2_subdev_ops ovRpsg_subdev_ops = {
+	.video	= &rpmsg_subdev_video_ops,
+	.pad	= &rpmsg_subdev_pad_ops,
+};
+
+/*
+ * rpmsg_send_buffer
+ *
+ * Tell M4 to generate colorized buffer
+ */
+
+int rpmsg_send_buffer(dma_addr_t eba)
+{
+	int err = 0;
+	struct csi_rx_msg msg;
+	static int buffer_num;
+
+	msg.type = RX_BUF_0 + buffer_num;
+	msg.addr = eba;
+
+	err = rpmsg_send(ovRpmsg_data.rpmsg_dev->ept, &msg, sizeof(msg));
+
+	buffer_num = (buffer_num + 1) & 3;
+
+	return err;
+}
+EXPORT_SYMBOL(rpmsg_send_buffer);
+
+/*
+ * rpmsg_lepton_callback
+ *
+ * Callback from RPMSG when buffer is received from M4
+ */
+
+static int rpmsg_lepton_callback(struct rpmsg_device *dev, void *data, int len,
+		void *priv, u32 src)
+{
+	struct {
+		uint32_t addr;
+		uint32_t buf_num;
+	} *msg = data;
+//	print_hex_dump(KERN_INFO, "incoming message:", DUMP_PREFIX_NONE, 16, 1, data, len, true);
+
+//	pr_info("Got %X %d\n", msg->addr, msg->buf_num);
+
+	if (ovRpmsg_data.callback) {
+		ovRpmsg_data.callback(msg->addr, msg->buf_num, ovRpmsg_data.callback_dev);
+	}
+
+	return 0;
+}
+
+int rpmsg_setup_callback(void (*func)(uint32_t addr, uint32_t buf_num, void *ptr), void *callback_dev)
+{
+	ovRpmsg_data.callback = func;
+	ovRpmsg_data.callback_dev = callback_dev;
+	return 0;
+}
+EXPORT_SYMBOL(rpmsg_setup_callback);
+
+
+static int rpmsg_lepton_probe(struct rpmsg_device *dev)
+{
+	int err;
+	void *vaddr;
+	dma_addr_t paddr;
+	struct csi_rx_msg msg;
+
+	dev_info(&dev->dev, "new channel: 0x%x -> 0x%x!\n", dev->src, dev->dst);
+
+	/* Send LUT to M4 */
+	vaddr = dma_alloc_coherent(0, 0x40000, &paddr, GFP_DMA | GFP_KERNEL);
+	msg.type = RX_LUT;
+	msg.addr = paddr;
+	err = rpmsg_send(dev->ept, &msg, sizeof(msg));
+	if (err) {
+		pr_err("rpmsg_send failed: %d\n", err);
+		return err;
+	}
+
+	/* Set initial values for the sensor struct. */
+	memset(&ovRpmsg_data, 0, sizeof(ovRpmsg_data));
+
+	ovRpmsg_data.pix.pixelformat = V4L2_PIX_FMT_RGB32;
+	ovRpmsg_data.pix.width = 160;
+	ovRpmsg_data.pix.height = 120;
+	ovRpmsg_data.streamcap.capturemode = 0;
+	ovRpmsg_data.streamcap.timeperframe.denominator = DEFAULT_FPS;
+	ovRpmsg_data.streamcap.timeperframe.numerator = 1;
+	ovRpmsg_data.rpmsg_dev = dev;
+
+	v4l2_subdev_init(&ovRpmsg_data.subdev, &ovRpsg_subdev_ops);
+	ovRpmsg_data.subdev.owner = dev->dev.driver->owner;
+	ovRpmsg_data.subdev.dev = &dev->dev;
+	ovRpmsg_data.subdev.dev->of_node = of_find_node_by_name(of_root, "m4_rpmsg");
+	v4l2_set_subdevdata(&ovRpmsg_data.subdev, dev);
+	strlcpy(ovRpmsg_data.subdev.name, dev->dev.driver->name, sizeof(ovRpmsg_data.subdev.name));
+
+	err = v4l2_async_register_subdev(&ovRpmsg_data.subdev);
+	if (err < 0)
+		dev_err(&dev->dev, "%s--Async register failed, ret=%d\n", __func__, err);
+
+	pr_info("camera ovRpmsg is found\n");
+
+	return err;
+}
+
+static void rpmsg_lepton_remove(struct rpmsg_device *dev)
+{
+	dev_info(&dev->dev, "rpmsg lepton-csi client driver is removed\n");
+
+	v4l2_async_unregister_subdev(&ovRpmsg_data.subdev);
+}
+
+static struct rpmsg_device_id rpmsg_driver_lepton_id_table[] = {
+	{ .name	= "rpmsg-client-lepton-csi" },
+	{ },
+};
+MODULE_DEVICE_TABLE(rpmsg, rpmsg_driver_lepton_id_table);
+
+static struct rpmsg_driver rpmsg_lepton_client = {
+	.drv.name	= KBUILD_MODNAME,
+	.id_table	= rpmsg_driver_lepton_id_table,
+	.probe		= rpmsg_lepton_probe,
+	.callback	= rpmsg_lepton_callback,
+	.remove		= rpmsg_lepton_remove,
+};
+
+module_rpmsg_driver(rpmsg_lepton_client);
+
+MODULE_AUTHOR("Peter Fitger, FLIR Systems AB");
+MODULE_DESCRIPTION("OVRPMSG Camera Driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.0");
+MODULE_ALIAS("CSI");
+
+
diff --git a/drivers/media/platform/mxc/capture/mxc_rpmsg.c b/drivers/media/platform/mxc/capture/mxc_rpmsg.c
new file mode 100644
index 000000000000..ed34c2c05661
--- /dev/null
+++ b/drivers/media/platform/mxc/capture/mxc_rpmsg.c
@@ -0,0 +1,1059 @@
+/*
+ * Copyright 2018 NXP
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/busfreq-imx.h>
+#include <linux/clk.h>
+#include <linux/completion.h>
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/of_device.h>
+#include <linux/of_graph.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/videodev2.h>
+#include <media/v4l2-async.h>
+#include <media/v4l2-dev.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fh.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-fwnode.h>
+#include <media/videobuf2-core.h>
+#include <media/videobuf2-dma-contig.h>
+#include <media/videobuf2-v4l2.h>
+
+#define IMX_RPMSG_DRV_NAME	"imx-rpmsg-v4l2"
+#define IMX_RPMSG_MAX_SUBDEV_NUM	4
+
+#define notifier_to_rpmsg_dev(n) container_of(n, struct imx_rpmsg_device, notifier)
+#define v4l2_dev_to_rpmsg_dev(d) container_of(d, struct imx_rpmsg_device, v4l2_dev)
+
+/* reg bit manipulation */
+#define REG_MASK(e, s) (((1 << ((e) - (s) + 1)) - 1) << (s))
+#define REG_PUT(x, e, s) (((x) << (s)) & REG_MASK(e, s))
+#define REG_GET(x, e, s) (((x) & REG_MASK(e, s)) >> (s))
+
+extern int rpmsg_send_buffer(dma_addr_t eba);
+extern int rpmsg_setup_callback(void (*func)(uint32_t addr, uint32_t buf_num, void *ptr), void *ptr);
+
+struct imx_rpmsg_input {
+	unsigned int index;
+	const char *name;
+	unsigned int type;
+	unsigned int caps;
+};
+
+struct imx_rpmsg_fh {
+	struct v4l2_fh fh;
+
+	/* TODO other fields added later */
+};
+
+struct imx_rpmsg_fmt {
+	char name[32];
+	u32  pix_fmt;
+	u32  fourcc;
+	u32  mbus_code;
+	int  bpp;
+};
+
+struct rpmsg_buf_internal {
+	struct list_head queue;
+	bool discard;
+};
+
+struct imx_rpmsg_buffer {
+	struct vb2_v4l2_buffer vb;
+	struct rpmsg_buf_internal internal;
+	uint32_t field;
+};
+
+struct imx_rpmsg_device {
+	struct device *dev;
+	struct v4l2_device v4l2_dev;
+	struct video_device *vdev;
+	struct vb2_queue queue;
+	struct v4l2_subdev *v4l2_sd;
+
+	spinlock_t slock;
+	struct list_head active_queue;
+	struct list_head discard;
+	uint32_t frame_count;
+	bool streaming;
+
+	void *discard_buffer;
+	dma_addr_t discard_buffer_dma;
+	size_t discard_size;
+	struct rpmsg_buf_internal	buf_discard;
+	struct mutex lock;
+	atomic_t use_count;
+	unsigned int curr_input;
+
+	struct imx_rpmsg_fmt rpmsg_fmt;
+	struct v4l2_pix_format v4l2_pix_fmt;
+	u32 buf_type;
+	u32 mbus_code;
+
+	/* async subdevs */
+	struct v4l2_async_subdev subdevs[IMX_RPMSG_MAX_SUBDEV_NUM];
+	struct v4l2_async_subdev *async_subdevs[IMX_RPMSG_MAX_SUBDEV_NUM];
+	struct v4l2_async_notifier notifier;
+};
+
+static const struct imx_rpmsg_fmt rpmsg_fmts[] = {
+	{
+		.name		= "BGRA-32",
+		.fourcc		= V4L2_PIX_FMT_RGB32,
+		.pix_fmt	= V4L2_PIX_FMT_RGB32,
+		.mbus_code	= MEDIA_BUS_FMT_ARGB8888_1X32,
+		.bpp		= 32,
+	},
+};
+
+static const struct imx_rpmsg_input inputs[] = {
+	{
+		.index = 0,
+		.name  = "Camera M4",
+		.type  = V4L2_INPUT_TYPE_CAMERA,
+		.caps  = 0,
+	},
+};
+
+static const struct imx_rpmsg_fmt *rpmsg_fmt_by_mbus(u32 code)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(rpmsg_fmts); i++) {
+		if (rpmsg_fmts[i].mbus_code == code)
+			return rpmsg_fmts + i;
+	}
+
+	pr_err("unknown mbus:0x%x\n", code);
+
+	return NULL;
+}
+
+static const struct imx_rpmsg_fmt *rpmsg_fmt_by_pix_fmt(u32 pixelformat)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(rpmsg_fmts); i++) {
+		if (rpmsg_fmts[i].pix_fmt == pixelformat)
+			return rpmsg_fmts + i;
+	}
+
+	pr_err("unknown pix_fmt:0x%x\n", pixelformat);
+
+	return NULL;
+}
+
+static struct imx_rpmsg_buffer *rpmsg_ibuf_to_buf(struct rpmsg_buf_internal *int_buf)
+{
+	return container_of(int_buf, struct imx_rpmsg_buffer, internal);
+}
+
+static int imx_rpmsg_set_fmt(struct imx_rpmsg_device *rpmsg_dev)
+{
+	struct imx_rpmsg_fmt *rpmsg_fmt = &rpmsg_dev->rpmsg_fmt;
+
+	switch (rpmsg_fmt->mbus_code) {
+	case MEDIA_BUS_FMT_ARGB8888_1X32:
+		/* BGRA8888 */
+		break;
+	default:
+		dev_err(rpmsg_dev->dev,
+			"%s: unsupported mbus fmt: %#x\n",
+			__func__, rpmsg_fmt->mbus_code);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int imx_rpmsg_config_dma(struct imx_rpmsg_device *rpmsg_dev,
+			      dma_addr_t dma_addr,
+			      unsigned int field)
+{
+	if (field > 1)
+		return -EINVAL;
+
+	rpmsg_send_buffer(dma_addr);
+
+	return 0;
+}
+
+static int imx_rpmsg_vidioc_querycap(struct file *file, void *fh,
+				   struct v4l2_capability *cap)
+{
+	struct imx_rpmsg_device *rpmsg_dev = video_drvdata(file);
+
+	strlcpy(cap->driver, IMX_RPMSG_DRV_NAME, sizeof(cap->driver));
+	strlcpy(cap->card, "V4L2 i.MX RPMSG", sizeof(cap->card));
+	snprintf(cap->bus_info, sizeof(cap->bus_info),
+		 "platform:%s", dev_name(rpmsg_dev->dev));
+
+	return 0;
+}
+
+static int imx_rpmsg_vidioc_enum_input(struct file *filp, void *fh,
+				     struct v4l2_input *inp)
+{
+	const struct imx_rpmsg_input *input;
+
+	if (inp->index >= ARRAY_SIZE(inputs))
+		return -EINVAL;
+
+	input = &inputs[inp->index];
+	WARN_ON(input->index != inp->index);
+
+	inp->type = input->type;
+	inp->capabilities = input->caps;
+	strlcpy(inp->name, input->name, sizeof(inp->name));
+	inp->std = (input->caps & V4L2_IN_CAP_STD) ?
+		   (V4L2_STD_NTSC_M | V4L2_STD_PAL) : 0;
+
+	return 0;
+}
+
+static int imx_rpmsg_vidioc_g_input(struct file *filp, void *fh, unsigned int *i)
+{
+	struct imx_rpmsg_device *rpmsg_dev = video_drvdata(filp);
+
+	*i = rpmsg_dev->curr_input;
+
+	return 0;
+}
+
+static int imx_rpmsg_vidioc_s_input(struct file *filp, void *fh, unsigned int i)
+{
+	struct imx_rpmsg_device *rpmsg_dev = video_drvdata(filp);
+
+	if (i >= ARRAY_SIZE(inputs))
+		return -EINVAL;
+
+	/* 's_input' need to be called at the beginning */
+	if (vb2_is_busy(&rpmsg_dev->queue))
+		return -EBUSY;
+
+	rpmsg_dev->curr_input = i;
+
+	return 0;
+}
+
+static int imx_rpmsg_vidioc_enum_fmt_vid_cap(struct file *filp, void *fh,
+					   struct v4l2_fmtdesc *f)
+{
+	int ret;
+	struct imx_rpmsg_device *rpmsg_dev = video_drvdata(filp);
+	struct v4l2_subdev *v4l2_sd = rpmsg_dev->v4l2_sd;
+	const struct imx_rpmsg_fmt *rpmsg_fmt;
+	struct v4l2_subdev_mbus_code_enum  code = {
+		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
+		/* format index during enumeration */
+		.index = f->index,
+	};
+
+	ret = v4l2_subdev_call(v4l2_sd, pad, enum_mbus_code, NULL, &code);
+	if (ret)
+		return -EINVAL;
+
+	rpmsg_fmt = rpmsg_fmt_by_mbus(code.code);
+	if (!rpmsg_fmt) {
+		dev_err(rpmsg_dev->dev, "mbus code %#x invalid\n", code.code);
+		return -EINVAL;
+	}
+
+	strlcpy(f->description, rpmsg_fmt->name, sizeof(f->description));
+	f->pixelformat = rpmsg_fmt->pix_fmt;
+
+	return 0;
+}
+
+static int imx_rpmsg_vidioc_try_fmt_vid_cap(struct file *filp, void *fh,
+					  struct v4l2_format *f)
+{
+	int ret;
+	struct imx_rpmsg_device *rpmsg_dev = video_drvdata(filp);
+	struct v4l2_subdev *v4l2_sd = rpmsg_dev->v4l2_sd;
+	struct v4l2_pix_format *v4l2_pix_fmt = &f->fmt.pix;
+	const struct imx_rpmsg_fmt *rpmsg_fmt;
+	struct v4l2_subdev_format v4l2_sd_fmt = {
+		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
+	};
+
+	rpmsg_fmt = rpmsg_fmt_by_pix_fmt(v4l2_pix_fmt->pixelformat);
+	if (!rpmsg_fmt)
+		return -EINVAL;
+
+	if (!v4l2_pix_fmt->width || !v4l2_pix_fmt->height) {
+		dev_err(rpmsg_dev->dev, "invalid with or height\n");
+		return -EINVAL;
+	}
+
+	v4l2_fill_mbus_format(&v4l2_sd_fmt.format,
+			      v4l2_pix_fmt,
+			      rpmsg_fmt->mbus_code);
+
+	ret = v4l2_subdev_call(v4l2_sd, pad, set_fmt, NULL, &v4l2_sd_fmt);
+	if (ret)
+		return -EINVAL;
+
+	v4l2_fill_pix_format(v4l2_pix_fmt, &v4l2_sd_fmt.format);
+
+	/* TODO: set field none */
+	v4l2_pix_fmt->field = V4L2_FIELD_NONE;
+
+
+	v4l2_pix_fmt->sizeimage = (32 >> 3) *
+				  v4l2_pix_fmt->height *
+				  v4l2_pix_fmt->width;
+	v4l2_pix_fmt->bytesperline = (32 >> 3) * v4l2_pix_fmt->width;
+
+	return 0;
+}
+
+static int imx_rpmsg_vidioc_g_fmt_vid_cap(struct file *filp, void *fh,
+					struct v4l2_format *f)
+{
+	struct imx_rpmsg_device *rpmsg_dev = video_drvdata(filp);
+
+	f->fmt.pix = rpmsg_dev->v4l2_pix_fmt;
+
+	return 0;
+}
+
+static int imx_rpmsg_vidioc_s_fmt_vid_cap(struct file *filp, void *fh,
+					struct v4l2_format *f)
+{
+	int ret;
+	struct imx_rpmsg_device *rpmsg_dev = video_drvdata(filp);
+	struct v4l2_pix_format *v4l2_pix_fmt = &f->fmt.pix;
+	const struct imx_rpmsg_fmt *rpmsg_fmt;
+
+	ret = imx_rpmsg_vidioc_try_fmt_vid_cap(filp, rpmsg_dev, f);
+	if (ret < 0)
+		return ret;
+
+	rpmsg_fmt = rpmsg_fmt_by_pix_fmt(v4l2_pix_fmt->pixelformat);
+	rpmsg_dev->rpmsg_fmt   = *rpmsg_fmt;
+	rpmsg_dev->mbus_code = rpmsg_fmt->mbus_code;
+	rpmsg_dev->v4l2_pix_fmt.pixelformat = v4l2_pix_fmt->pixelformat;
+	rpmsg_dev->v4l2_pix_fmt.width	= v4l2_pix_fmt->width;
+	rpmsg_dev->v4l2_pix_fmt.height	= v4l2_pix_fmt->height;
+	rpmsg_dev->v4l2_pix_fmt.sizeimage	= v4l2_pix_fmt->sizeimage;
+	rpmsg_dev->v4l2_pix_fmt.bytesperline = v4l2_pix_fmt->bytesperline;
+	rpmsg_dev->v4l2_pix_fmt.field	= v4l2_pix_fmt->field;
+	rpmsg_dev->buf_type		= f->type;
+
+	return 0;
+}
+
+static int imx_rpmsg_vidioc_g_parm(struct file *filp, void *fh,
+				 struct v4l2_streamparm *a)
+{
+	struct imx_rpmsg_device *rpmsg_dev = video_drvdata(filp);
+	struct v4l2_subdev *v4l2_sd = rpmsg_dev->v4l2_sd;
+
+	return v4l2_subdev_call(v4l2_sd, video, g_parm, a);
+}
+
+static int imx_rpmsg_vidioc_s_parm(struct file *filp, void *fh,
+				 struct v4l2_streamparm *a)
+{
+	struct imx_rpmsg_device *rpmsg_dev = video_drvdata(filp);
+	struct v4l2_subdev *v4l2_sd = rpmsg_dev->v4l2_sd;
+
+	return v4l2_subdev_call(v4l2_sd, video, s_parm, a);
+}
+
+static int imx_rpmsg_vidioc_enum_framesizes(struct file *filp, void *fh,
+					  struct v4l2_frmsizeenum *fsize)
+{
+	int ret;
+	struct imx_rpmsg_device *rpmsg_dev = video_drvdata(filp);
+	struct v4l2_subdev *v4l2_sd = rpmsg_dev->v4l2_sd;
+	const struct imx_rpmsg_fmt *rpmsg_fmt;
+	struct v4l2_subdev_frame_size_enum fse = {
+		.index = fsize->index,
+		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
+	};
+
+	rpmsg_fmt  = rpmsg_fmt_by_pix_fmt(fsize->pixel_format);
+	fse.code = rpmsg_fmt->mbus_code;
+
+	ret = v4l2_subdev_call(v4l2_sd, pad, enum_frame_size, NULL, &fse);
+	if (ret)
+		return ret;
+
+	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+	fsize->discrete.width  = fse.max_width;
+	fsize->discrete.height = fse.max_height;
+
+	return 0;
+}
+
+static int imx_rpmsg_vidioc_enum_frameintervals(struct file *filp, void *fh,
+					      struct v4l2_frmivalenum *fival)
+{
+	int ret;
+	struct imx_rpmsg_device *rpmsg_dev = video_drvdata(filp);
+	struct v4l2_subdev *v4l2_sd = rpmsg_dev->v4l2_sd;
+	const struct imx_rpmsg_fmt *rpmsg_fmt;
+	struct v4l2_subdev_frame_interval_enum fie = {
+		.index  = fival->index,
+		.width  = fival->width,
+		.height = fival->height,
+		.which  = V4L2_SUBDEV_FORMAT_ACTIVE,
+	};
+
+	rpmsg_fmt  = rpmsg_fmt_by_pix_fmt(fival->pixel_format);
+	fie.code = rpmsg_fmt->mbus_code;
+
+	ret = v4l2_subdev_call(v4l2_sd, pad, enum_frame_interval, NULL, &fie);
+	if (ret)
+		return ret;
+
+	fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+	fival->discrete = fie.interval;
+
+	return 0;
+}
+
+static const struct v4l2_ioctl_ops imx_rpmsg_ioctl_ops = {
+	.vidioc_querycap		= imx_rpmsg_vidioc_querycap,
+	.vidioc_enum_fmt_vid_cap	= imx_rpmsg_vidioc_enum_fmt_vid_cap,
+	.vidioc_try_fmt_vid_cap		= imx_rpmsg_vidioc_try_fmt_vid_cap,
+	.vidioc_g_fmt_vid_cap		= imx_rpmsg_vidioc_g_fmt_vid_cap,
+	.vidioc_s_fmt_vid_cap		= imx_rpmsg_vidioc_s_fmt_vid_cap,
+
+	.vidioc_enum_input		= imx_rpmsg_vidioc_enum_input,
+	.vidioc_g_input			= imx_rpmsg_vidioc_g_input,
+	.vidioc_s_input			= imx_rpmsg_vidioc_s_input,
+
+	.vidioc_reqbufs			= vb2_ioctl_reqbufs,
+	.vidioc_create_bufs		= vb2_ioctl_create_bufs,
+	.vidioc_querybuf		= vb2_ioctl_querybuf,
+	.vidioc_qbuf			= vb2_ioctl_qbuf,
+	.vidioc_dqbuf			= vb2_ioctl_dqbuf,
+	.vidioc_expbuf			= vb2_ioctl_expbuf,
+	.vidioc_streamon		= vb2_ioctl_streamon,
+	.vidioc_streamoff		= vb2_ioctl_streamoff,
+
+	.vidioc_g_parm			= imx_rpmsg_vidioc_g_parm,
+	.vidioc_s_parm			= imx_rpmsg_vidioc_s_parm,
+	.vidioc_enum_framesizes		= imx_rpmsg_vidioc_enum_framesizes,
+	.vidioc_enum_frameintervals	= imx_rpmsg_vidioc_enum_frameintervals,
+};
+
+static int imx_rpmsg_open(struct file *filp)
+{
+	struct imx_rpmsg_device *rpmsg_dev = video_drvdata(filp);
+	struct video_device *vdev = video_devdata(filp);
+	struct imx_rpmsg_fh *rpmsg_fh;
+
+	if (mutex_lock_interruptible(&rpmsg_dev->lock))
+		return -ERESTARTSYS;
+
+	rpmsg_fh = kzalloc(sizeof(*rpmsg_fh), GFP_KERNEL);
+	if (!rpmsg_fh) {
+		dev_err(rpmsg_dev->dev, "Cannot allocate 'rpmsg_fh' struct\n");
+		mutex_unlock(&rpmsg_dev->lock);
+		return -ENOMEM;
+	}
+
+	/* first open: RPMSG should be clean */
+	if (atomic_inc_return(&rpmsg_dev->use_count) == 1) {
+		pm_runtime_get_sync(rpmsg_dev->dev);
+		rpmsg_dev->frame_count = 0;
+	}
+
+	v4l2_fh_init(&rpmsg_fh->fh, vdev);
+	filp->private_data = &rpmsg_fh->fh;
+	v4l2_fh_add(&rpmsg_fh->fh);
+
+	mutex_unlock(&rpmsg_dev->lock);
+
+	return 0;
+}
+
+static int imx_rpmsg_release(struct file *filp)
+{
+	struct imx_rpmsg_device *rpmsg_dev = video_drvdata(filp);
+	struct v4l2_fh *fh = filp->private_data;
+	struct imx_rpmsg_fh *rpmsg_fh;
+
+	if (!fh) {
+		WARN_ON(1);
+		return 0;
+	}
+
+	mutex_lock(&rpmsg_dev->lock);
+
+	rpmsg_fh = container_of(fh, struct imx_rpmsg_fh, fh);
+
+	if (atomic_dec_and_test(&rpmsg_dev->use_count)) {
+		pm_runtime_put(rpmsg_dev->dev);
+		mutex_unlock(&rpmsg_dev->lock);
+		vb2_fop_release(filp);
+	} else
+		mutex_unlock(&rpmsg_dev->lock);
+
+	return 0;
+}
+
+static const struct v4l2_file_operations imx_rpmsg_fops = {
+	.owner	= THIS_MODULE,
+	.open	= imx_rpmsg_open,
+	.release = imx_rpmsg_release,
+	.unlocked_ioctl = video_ioctl2,
+	.read	= vb2_fop_read,
+	.mmap	= vb2_fop_mmap,
+	.poll	= vb2_fop_poll,
+};
+
+static int imx_rpmsg_queue_setup(struct vb2_queue *q,
+			       unsigned int *num_buffers,
+			       unsigned int *num_planes,
+			       unsigned int sizes[],
+			       struct device *alloc_devs[])
+{
+	struct imx_rpmsg_device *rpmsg_dev = vb2_get_drv_priv(q);
+	struct v4l2_pix_format *fmt = &rpmsg_dev->v4l2_pix_fmt;
+
+	/* TODO: don't support multiple plane format */
+
+	WARN_ON(*num_buffers < 3);
+
+	switch (fmt->pixelformat) {
+	case V4L2_PIX_FMT_UYVY:
+		if (!*num_planes || *num_planes > 1)
+			*num_planes = 1;
+		sizes[0] = fmt->sizeimage;
+		break;
+	case V4L2_PIX_FMT_YUYV:
+		if (!*num_planes || *num_planes > 1)
+			*num_planes = 1;
+		sizes[0] = fmt->sizeimage;
+		break;
+	case V4L2_PIX_FMT_ABGR32:
+		if (!*num_planes || *num_planes > 1)
+			*num_planes = 1;
+		sizes[0] = fmt->sizeimage;
+		break;
+	case V4L2_PIX_FMT_RGB32:
+		if (!*num_planes || *num_planes > 1)
+			*num_planes = 1;
+		sizes[0] = fmt->sizeimage;
+		break;
+	default:
+		/* unsupported format */
+		dev_err(rpmsg_dev->dev, "unsupported format %X\n", fmt->pixelformat);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int imx_rpmsg_buf_prepare(struct vb2_buffer *vb)
+{
+	struct imx_rpmsg_device *rpmsg_dev = vb2_get_drv_priv(vb->vb2_queue);
+	struct v4l2_pix_format *fmt = &rpmsg_dev->v4l2_pix_fmt;
+	unsigned int plane_no = 0;
+
+	if (WARN_ON(vb->num_planes != 1))
+		return -EINVAL;
+
+	if (vb2_plane_size(vb, plane_no) < fmt->sizeimage)
+		return -EINVAL;
+
+	vb2_set_plane_payload(vb, plane_no, fmt->sizeimage);
+
+	return 0;
+}
+
+static int imx_rpmsg_start_streaming(struct vb2_queue *q,
+				   unsigned int count)
+{
+	int ret = 0;
+	unsigned long flags;
+	struct imx_rpmsg_device *rpmsg_dev = vb2_get_drv_priv(q);
+	struct imx_rpmsg_buffer *rpmsg_buf;
+	struct vb2_buffer *vb;
+	dma_addr_t dma_addr;
+
+	if (WARN_ON(count < 3))
+		return -ENOBUFS;
+
+	/* discard buffers for no buffer available */
+	rpmsg_dev->discard_size = rpmsg_dev->v4l2_pix_fmt.sizeimage;
+	rpmsg_dev->discard_buffer = dma_alloc_coherent(rpmsg_dev->v4l2_dev.dev,
+					PAGE_ALIGN(rpmsg_dev->discard_size),
+					&rpmsg_dev->discard_buffer_dma,
+					GFP_DMA | GFP_KERNEL);
+	if (!rpmsg_dev->discard_buffer)
+		return -ENOMEM;
+
+	spin_lock_irqsave(&rpmsg_dev->slock, flags);
+
+	/* queue the discard buffer first */
+	rpmsg_dev->buf_discard.discard = true;
+	list_add_tail(&rpmsg_dev->buf_discard.queue,
+		      &rpmsg_dev->discard);
+
+	if (unlikely(list_empty(&rpmsg_dev->active_queue))) {
+		WARN_ON(1);
+		spin_unlock_irqrestore(&rpmsg_dev->slock, flags);
+		return -ENOBUFS;
+	}
+
+	rpmsg_buf = list_first_entry(&rpmsg_dev->active_queue,
+				   struct imx_rpmsg_buffer,
+				   internal.queue);
+
+	vb = &rpmsg_buf->vb.vb2_buf;
+	dma_addr = vb2_dma_contig_plane_dma_addr(vb, 0);
+
+	rpmsg_buf->field = 0;
+
+	spin_unlock_irqrestore(&rpmsg_dev->slock, flags);
+
+	ret = imx_rpmsg_set_fmt(rpmsg_dev);
+	if (ret)
+		return ret;
+
+	rpmsg_dev->streaming = true;
+
+	/* enable dma transfer */
+	ret = imx_rpmsg_config_dma(rpmsg_dev, dma_addr, 0);
+	if (ret)
+		return ret;
+
+	return ret;
+}
+
+static void imx_rpmsg_stop_streaming(struct vb2_queue *q)
+{
+	unsigned long flags;
+	struct imx_rpmsg_device *rpmsg_dev = vb2_get_drv_priv(q);
+	struct imx_rpmsg_buffer *pos, *tmp;
+	struct vb2_buffer *vb;
+	void *tmpbuf;
+
+	rpmsg_dev->streaming = false;
+
+	spin_lock_irqsave(&rpmsg_dev->slock, flags);
+
+	if (list_empty(&rpmsg_dev->active_queue))
+		WARN_ON(1);
+
+	list_for_each_entry_safe(pos, tmp,
+			&rpmsg_dev->active_queue, internal.queue) {
+
+		list_del_init(&pos->internal.queue);
+		vb = &pos->vb.vb2_buf;
+		if (vb->state == VB2_BUF_STATE_ACTIVE)
+			vb2_buffer_done(vb, VB2_BUF_STATE_ERROR);
+	}
+
+	INIT_LIST_HEAD(&rpmsg_dev->active_queue);
+	INIT_LIST_HEAD(&rpmsg_dev->discard);
+
+	tmpbuf = rpmsg_dev->discard_buffer;
+	rpmsg_dev->discard_buffer = NULL;
+
+	spin_unlock_irqrestore(&rpmsg_dev->slock, flags);
+
+	dma_free_coherent(rpmsg_dev->v4l2_dev.dev,
+				rpmsg_dev->discard_size, tmpbuf,
+				rpmsg_dev->discard_buffer_dma);
+}
+
+static void imx_rpmsg_buf_queue(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct imx_rpmsg_device *rpmsg_dev = vb2_get_drv_priv(vb->vb2_queue);
+	struct imx_rpmsg_buffer *rpmsg_buf = container_of(vbuf,
+						struct imx_rpmsg_buffer,
+						vb);
+	unsigned long flags;
+
+	spin_lock_irqsave(&rpmsg_dev->slock, flags);
+
+	/* the 'vb' is in active state, so add this
+	 * buffer to 'active_queue' to be fetched
+	 * when streamon called
+	 */
+	list_add_tail(&rpmsg_buf->internal.queue, &rpmsg_dev->active_queue);
+
+	spin_unlock_irqrestore(&rpmsg_dev->slock, flags);
+}
+
+static struct vb2_ops imx_rpmsg_vb2_ops = {
+	.queue_setup		= imx_rpmsg_queue_setup,
+	.wait_prepare		= vb2_ops_wait_prepare,
+	.wait_finish		= vb2_ops_wait_finish,
+	.buf_prepare		= imx_rpmsg_buf_prepare,
+	.start_streaming	= imx_rpmsg_start_streaming,
+	.stop_streaming		= imx_rpmsg_stop_streaming,
+	.buf_queue		= imx_rpmsg_buf_queue,
+};
+
+static int imx_rpmsg_dma_done_handle(struct imx_rpmsg_device *rpmsg_dev)
+{
+	int ret;
+	uint32_t field = 0;
+	unsigned long flags;
+	struct imx_rpmsg_buffer *buf;
+	struct rpmsg_buf_internal *ibuf;
+	struct vb2_buffer *vb;
+	dma_addr_t dma_addr;
+
+	spin_lock_irqsave(&rpmsg_dev->slock, flags);
+
+	if (unlikely(list_empty(&rpmsg_dev->active_queue))) {
+		WARN_ON(1);
+		spin_unlock_irqrestore(&rpmsg_dev->slock, flags);
+		return -ENOBUFS;
+	}
+
+	ibuf = list_first_entry(&rpmsg_dev->active_queue, struct rpmsg_buf_internal,
+				queue);
+
+	if (ibuf->discard) {
+
+		/* discard buffer just return to discard queue */
+		/* not dqbuf to user */
+		list_move_tail(rpmsg_dev->active_queue.next, &rpmsg_dev->discard);
+	} else {
+		/* make vb2 know about the buffer done, can return to user */
+		buf = rpmsg_ibuf_to_buf(ibuf);
+		vb = &buf->vb.vb2_buf;
+
+		/* delete current buffer from queue */
+		list_del_init(&buf->internal.queue);
+		to_vb2_v4l2_buffer(vb)->sequence = rpmsg_dev->frame_count;
+		vb2_buffer_done(vb, VB2_BUF_STATE_DONE);
+	}
+
+	rpmsg_dev->frame_count++;
+
+	if (list_empty(&rpmsg_dev->active_queue)) {
+
+		if (list_empty(&rpmsg_dev->discard)) {
+			spin_unlock_irqrestore(&rpmsg_dev->slock, flags);
+			dev_err(rpmsg_dev->dev,
+				"trying to access empty discard list\n");
+			return 0;
+		}
+
+		list_move_tail(rpmsg_dev->discard.next, &rpmsg_dev->active_queue);
+
+		imx_rpmsg_config_dma(rpmsg_dev, rpmsg_dev->discard_buffer_dma, 0);
+		spin_unlock_irqrestore(&rpmsg_dev->slock, flags);
+
+		return 0;
+	}
+
+	buf = list_first_entry(&rpmsg_dev->active_queue, struct imx_rpmsg_buffer,
+				internal.queue);
+
+	vb = &buf->vb.vb2_buf;
+	vb->state = VB2_BUF_STATE_ACTIVE;
+
+	dma_addr = vb2_dma_contig_plane_dma_addr(vb, 0);
+	ret = imx_rpmsg_config_dma(rpmsg_dev, dma_addr, field);
+	spin_unlock_irqrestore(&rpmsg_dev->slock, flags);
+	return ret;
+}
+
+static void imx_rpmsg_callback(uint32_t addr, uint32_t buf_num, void *ptr)
+{
+	struct imx_rpmsg_device *rpmsg_dev = ptr;
+	if (rpmsg_dev->streaming)
+		imx_rpmsg_dma_done_handle(rpmsg_dev);
+}
+
+static int imx_rpmsg_subdev_bound(struct v4l2_async_notifier *notifier,
+				struct v4l2_subdev *subdev,
+				struct v4l2_async_subdev *asd)
+{
+	struct imx_rpmsg_device *rpmsg_dev = notifier_to_rpmsg_dev(notifier);
+
+	/* TODO support multiple subdevs */
+	rpmsg_dev->v4l2_sd = subdev;
+
+	dev_info(rpmsg_dev->dev, "subdev %s bound success\n", subdev->name);
+
+	return 0;
+}
+
+static void imx_rpmsg_subdev_unbind(struct v4l2_async_notifier *notifier,
+				  struct v4l2_subdev *subdev,
+				  struct v4l2_async_subdev *asd)
+{
+	struct imx_rpmsg_device *rpmsg_dev = notifier_to_rpmsg_dev(notifier);
+
+	rpmsg_dev->v4l2_sd = NULL;
+
+	dev_info(rpmsg_dev->dev, "subdev %s unbind\n", subdev->name);
+}
+
+static int imx_rpmsg_async_subdevs_register(struct imx_rpmsg_device *rpmsg_dev)
+{
+	int ret;
+	unsigned int num_subdevs = 0;
+	struct fwnode_handle *endpoint = NULL;
+	struct fwnode_handle *np = dev_fwnode(rpmsg_dev->dev);
+	struct fwnode_handle *remote = NULL;
+	struct v4l2_async_notifier *notifier = &rpmsg_dev->notifier;
+	struct v4l2_async_subdev *asd;
+
+	while (num_subdevs < IMX_RPMSG_MAX_SUBDEV_NUM) {
+		endpoint = fwnode_graph_get_next_endpoint(np, endpoint);
+		if (!endpoint)
+			break;
+
+		remote = fwnode_graph_get_remote_port_parent(endpoint);
+
+		fwnode_handle_put(remote);
+		if (!remote)
+			continue;
+
+		asd = &rpmsg_dev->subdevs[num_subdevs];
+		asd->match_type = V4L2_ASYNC_MATCH_FWNODE;
+		asd->match.fwnode.fwnode = remote;
+		rpmsg_dev->async_subdevs[num_subdevs] = asd;
+
+		num_subdevs++;
+	}
+
+	if (unlikely(endpoint))
+		fwnode_handle_put(endpoint);
+
+	if (!num_subdevs) {
+		dev_err(rpmsg_dev->dev, "no subdev found for rpmsg\n");
+		return -ENODEV;
+	}
+
+	notifier->subdevs = rpmsg_dev->async_subdevs;
+	notifier->num_subdevs = num_subdevs;
+	notifier->bound  = imx_rpmsg_subdev_bound;
+	notifier->unbind = imx_rpmsg_subdev_unbind;
+
+	ret = v4l2_async_notifier_register(&rpmsg_dev->v4l2_dev, notifier);
+	if (ret) {
+		dev_err(rpmsg_dev->dev, "register async notifier failed\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int imx_rpmsg_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct imx_rpmsg_device *rpmsg_dev;
+	struct vb2_queue *vb2q;
+
+	rpmsg_dev = devm_kzalloc(&pdev->dev, sizeof(*rpmsg_dev), GFP_KERNEL);
+	if (!rpmsg_dev) {
+		dev_err(&pdev->dev, "Can't allocate 'rpmsg_dev' struct\n");
+		return -ENOMEM;
+	}
+
+	rpmsg_dev->dev = &pdev->dev;
+
+	mutex_init(&rpmsg_dev->lock);
+
+	/* Register 'v4l2_device' */
+	snprintf(rpmsg_dev->v4l2_dev.name,
+		 sizeof(rpmsg_dev->v4l2_dev.name), "IMX-RPMSG");
+
+	ret = v4l2_device_register(rpmsg_dev->dev, &rpmsg_dev->v4l2_dev);
+
+	/* Initialize the vb2 queue */
+	vb2q = &rpmsg_dev->queue;
+	vb2q->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	vb2q->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF | VB2_READ;
+	vb2q->dev = rpmsg_dev->dev;
+	vb2q->drv_priv = rpmsg_dev;
+	vb2q->buf_struct_size = sizeof(struct imx_rpmsg_buffer);
+	vb2q->min_buffers_needed = 3;
+	vb2q->ops = &imx_rpmsg_vb2_ops;
+	vb2q->mem_ops = &vb2_dma_contig_memops;
+	vb2q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
+	vb2q->lock = &rpmsg_dev->lock;
+
+	/* TODO other possible configurable fields:
+	 *	'buf_struct_size';
+	 *	'gfp_flags';
+	 *	'min_buffers_needed';
+	 *	'alloc_devs'
+	 */ 
+	ret = vb2_queue_init(vb2q);
+	if (ret)
+		goto unregister_v4l2_dev;
+
+	/* Register 'video_device' */
+	rpmsg_dev->vdev = video_device_alloc();
+	if (!rpmsg_dev->vdev) {
+		ret = -ENOMEM;
+		goto unregister_v4l2_dev;
+	}
+
+	strlcpy(rpmsg_dev->vdev->name, "IMX rpmsg", sizeof(rpmsg_dev->vdev->name));
+
+	rpmsg_dev->vdev->release	 = video_device_release;
+	rpmsg_dev->vdev->v4l2_dev	 = &rpmsg_dev->v4l2_dev;
+	rpmsg_dev->vdev->vfl_dir	 = VFL_DIR_RX;
+	rpmsg_dev->vdev->fops	 = &imx_rpmsg_fops;
+	rpmsg_dev->vdev->ioctl_ops = &imx_rpmsg_ioctl_ops;
+	rpmsg_dev->vdev->device_caps = V4L2_CAP_VIDEO_CAPTURE |
+				     V4L2_CAP_STREAMING |
+				     V4L2_CAP_READWRITE;
+	rpmsg_dev->vdev->lock	 = &rpmsg_dev->lock;
+	rpmsg_dev->vdev->queue	 = vb2q;
+
+	video_set_drvdata(rpmsg_dev->vdev, rpmsg_dev);
+
+	ret = video_register_device(rpmsg_dev->vdev, VFL_TYPE_GRABBER, -1);
+	if (ret)
+		goto release_video_device;
+
+	/* Register async subdevs */
+	ret = imx_rpmsg_async_subdevs_register(rpmsg_dev);
+	if (ret) {
+		dev_err(rpmsg_dev->dev, "register async subdevs failed\n");
+		goto release_video_device;
+	}
+
+	/* Seems necessary to set up some default parameters */
+	rpmsg_dev->v4l2_pix_fmt.pixelformat = V4L2_PIX_FMT_RGB32;
+	rpmsg_dev->v4l2_pix_fmt.width	= 160;
+	rpmsg_dev->v4l2_pix_fmt.height	= 120;
+	rpmsg_dev->v4l2_pix_fmt.sizeimage = (32 >> 3) *
+			rpmsg_dev->v4l2_pix_fmt.height *
+			rpmsg_dev->v4l2_pix_fmt.width;
+	rpmsg_dev->v4l2_pix_fmt.bytesperline = (32 >> 3) * rpmsg_dev->v4l2_pix_fmt.width;
+	rpmsg_dev->v4l2_pix_fmt.field	= V4L2_FIELD_NONE;
+
+
+	pm_runtime_enable(rpmsg_dev->dev);
+	spin_lock_init(&rpmsg_dev->slock);
+
+	pm_runtime_get_sync(rpmsg_dev->dev);
+
+	INIT_LIST_HEAD(&rpmsg_dev->active_queue);
+	INIT_LIST_HEAD(&rpmsg_dev->discard);
+
+	rpmsg_setup_callback(imx_rpmsg_callback, (void *)rpmsg_dev);
+
+	dev_info(rpmsg_dev->dev, "IMX RPMSG Driver probe success\n");
+
+	return 0;
+
+release_video_device:
+	video_device_release(rpmsg_dev->vdev);
+unregister_v4l2_dev:
+	v4l2_device_unregister(&rpmsg_dev->v4l2_dev);
+
+	return ret;
+}
+
+static int imx_rpmsg_remove(struct platform_device *pdev)
+{
+	struct v4l2_device *v4l2_dev = dev_get_drvdata(&pdev->dev);
+	struct imx_rpmsg_device *rpmsg_dev = v4l2_dev_to_rpmsg_dev(v4l2_dev);
+
+	video_device_release(rpmsg_dev->vdev);
+	v4l2_device_unregister(&rpmsg_dev->v4l2_dev);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP 
+static int imx_rpmsg_suspend(struct device *dev)
+{
+	struct v4l2_device *v4l2_dev = dev_get_drvdata(dev);
+	struct imx_rpmsg_device *rpmsg_dev = v4l2_dev_to_rpmsg_dev(v4l2_dev);
+
+	if (!vb2_is_streaming(&rpmsg_dev->queue))
+		return 0;
+
+	return 0;
+}
+
+static int imx_rpmsg_resume(struct device *dev)
+{
+	struct v4l2_device *v4l2_dev = dev_get_drvdata(dev);
+	struct imx_rpmsg_device *rpmsg_dev = v4l2_dev_to_rpmsg_dev(v4l2_dev);
+
+	if (!vb2_is_streaming(&rpmsg_dev->queue))
+		return 0;
+
+	return 0;
+}
+#else
+#define imx_rpmsg_suspend		NULL
+#define imx_rpmsg_resume		NULL
+#endif
+
+#ifdef CONFIG_PM
+static int imx_rpmsg_runtime_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int imx_rpmsg_runtime_resume(struct device *dev)
+{
+	int ret = 0;
+
+	return ret;
+}
+#else
+#define imx_rpmsg_runtime_suspend	NULL
+#define imx_rpmsg_runtime_resume	NULL
+#endif
+
+static const struct dev_pm_ops imx_rpmsg_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(imx_rpmsg_suspend, imx_rpmsg_resume)
+	SET_RUNTIME_PM_OPS(imx_rpmsg_runtime_suspend, imx_rpmsg_runtime_resume, NULL)
+};
+
+static const struct of_device_id imx_rpmsg_of_match[] = {
+	{ .compatible = "fsl,imx7-rpmsg-capture", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, imx_rpmsg_of_match);
+
+static struct platform_driver imx_rpmsg_driver = {
+	.probe    = imx_rpmsg_probe,
+	.remove   = imx_rpmsg_remove,
+	.driver   = {
+		.name = IMX_RPMSG_DRV_NAME,
+		.of_match_table = of_match_ptr(imx_rpmsg_of_match),
+		.pm = &imx_rpmsg_pm_ops,
+	},
+};
+
+module_platform_driver(imx_rpmsg_driver);
+
+MODULE_DESCRIPTION("NXP i.MX RPMSG driver");
+MODULE_AUTHOR("Peter Fitger <petyer.fitger@flir.se>");
+MODULE_LICENSE("GPL");
-- 
2.17.1

