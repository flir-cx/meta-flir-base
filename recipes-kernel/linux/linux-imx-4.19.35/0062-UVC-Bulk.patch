From b7ce7f6c87ed76e0d59c0a58ea21953f5df17ada Mon Sep 17 00:00:00 2001
From: Adrien Martinez <adrien.martinez@flir.se>
Date: Tue, 4 Feb 2020 13:18:52 +0100
Subject: [PATCH] UVC Bulk

---
 drivers/usb/gadget/function/f_uvc.c    | 242 +++++++++++++++++++------
 drivers/usb/gadget/function/uvc_v4l2.c |   7 +-
 2 files changed, 194 insertions(+), 55 deletions(-)

diff --git a/drivers/usb/gadget/function/f_uvc.c b/drivers/usb/gadget/function/f_uvc.c
index d8ce7868fe22..5af771da4760 100644
--- a/drivers/usb/gadget/function/f_uvc.c
+++ b/drivers/usb/gadget/function/f_uvc.c
@@ -34,6 +34,8 @@ unsigned int uvc_gadget_trace_param;
 module_param_named(trace, uvc_gadget_trace_param, uint, 0644);
 MODULE_PARM_DESC(trace, "Trace level bitmask");
 
+//#define BULK
+
 /* --------------------------------------------------------------------------
  * Function descriptors
  */
@@ -112,6 +114,76 @@ static struct uvc_control_endpoint_descriptor uvc_control_cs_ep = {
 	.wMaxTransferSize	= cpu_to_le16(UVC_STATUS_MAX_PACKET_SIZE),
 };
 
+static struct usb_ss_ep_comp_descriptor uvc_ss_streaming_comp = {
+	.bLength		= sizeof(uvc_ss_streaming_comp),
+	.bDescriptorType	= USB_DT_SS_ENDPOINT_COMP,
+	/* The bMaxBurst, bmAttributes and wBytesPerInterval values will be
+	 * initialized from module parameters.
+	 */
+};
+
+#ifdef BULK
+static struct usb_interface_descriptor uvc_streaming_intf = {
+	.bLength		= USB_DT_INTERFACE_SIZE,
+	.bDescriptorType	= USB_DT_INTERFACE,
+	.bInterfaceNumber	= UVC_INTF_VIDEO_STREAMING,
+	.bAlternateSetting	= 0,
+	.bNumEndpoints		= 1,
+	.bInterfaceClass	= USB_CLASS_VIDEO,
+	.bInterfaceSubClass	= UVC_SC_VIDEOSTREAMING,
+	.bInterfaceProtocol	= 0x00,
+	.iInterface		= 0,
+};
+static struct usb_endpoint_descriptor uvc_fs_streaming_ep = {
+	.bLength		= USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType	= USB_DT_ENDPOINT,
+	.bEndpointAddress	= USB_DIR_IN,
+	.bmAttributes		= USB_ENDPOINT_XFER_BULK,
+	//.bmAttributes		= USB_ENDPOINT_SYNC_ASYNC | USB_ENDPOINT_XFER_ISOC,
+	/* The wMaxPacketSize and bInterval values will be initialized from
+	 * module parameters.
+	 */
+};
+
+static struct usb_endpoint_descriptor uvc_hs_streaming_ep = {
+	.bLength		= USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType	= USB_DT_ENDPOINT,
+	.bEndpointAddress	= USB_DIR_IN,
+	.bmAttributes		= USB_ENDPOINT_XFER_BULK,
+	//.bmAttributes		= USB_ENDPOINT_SYNC_ASYNC | USB_ENDPOINT_XFER_ISOC,
+	/* The wMaxPacketSize and bInterval values will be initialized from
+	 * module parameters.
+	 */
+};
+
+static struct usb_endpoint_descriptor uvc_ss_streaming_ep = {
+	.bLength		= USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType	= USB_DT_ENDPOINT,
+	.bEndpointAddress	= USB_DIR_IN,
+	.bmAttributes		= USB_ENDPOINT_XFER_BULK,
+	//.bmAttributes		= USB_ENDPOINT_SYNC_ASYNC | USB_ENDPOINT_XFER_ISOC,
+	/* The wMaxPacketSize and bInterval values will be initialized from
+	 * module parameters.
+	 */
+};
+static const struct usb_descriptor_header * const uvc_fs_streaming[] = {
+	(struct usb_descriptor_header *) &uvc_fs_streaming_ep,
+	NULL,
+};
+
+static const struct usb_descriptor_header * const uvc_hs_streaming[] = {
+	(struct usb_descriptor_header *) &uvc_hs_streaming_ep,
+	NULL,
+};
+
+static const struct usb_descriptor_header * const uvc_ss_streaming[] = {
+	(struct usb_descriptor_header *) &uvc_ss_streaming_ep,
+	(struct usb_descriptor_header *) &uvc_ss_streaming_comp,
+	NULL,
+};
+
+#else
+
 static struct usb_interface_descriptor uvc_streaming_intf_alt0 = {
 	.bLength		= USB_DT_INTERFACE_SIZE,
 	.bDescriptorType	= USB_DT_INTERFACE,
@@ -135,13 +207,11 @@ static struct usb_interface_descriptor uvc_streaming_intf_alt1 = {
 	.bInterfaceProtocol	= 0x00,
 	.iInterface		= 0,
 };
-
 static struct usb_endpoint_descriptor uvc_fs_streaming_ep = {
 	.bLength		= USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType	= USB_DT_ENDPOINT,
 	.bEndpointAddress	= USB_DIR_IN,
-	.bmAttributes		= USB_ENDPOINT_SYNC_ASYNC
-				| USB_ENDPOINT_XFER_ISOC,
+	.bmAttributes		= USB_ENDPOINT_SYNC_ASYNC | USB_ENDPOINT_XFER_ISOC,
 	/* The wMaxPacketSize and bInterval values will be initialized from
 	 * module parameters.
 	 */
@@ -151,8 +221,7 @@ static struct usb_endpoint_descriptor uvc_hs_streaming_ep = {
 	.bLength		= USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType	= USB_DT_ENDPOINT,
 	.bEndpointAddress	= USB_DIR_IN,
-	.bmAttributes		= USB_ENDPOINT_SYNC_ASYNC
-				| USB_ENDPOINT_XFER_ISOC,
+	.bmAttributes		= USB_ENDPOINT_SYNC_ASYNC | USB_ENDPOINT_XFER_ISOC,
 	/* The wMaxPacketSize and bInterval values will be initialized from
 	 * module parameters.
 	 */
@@ -161,23 +230,12 @@ static struct usb_endpoint_descriptor uvc_hs_streaming_ep = {
 static struct usb_endpoint_descriptor uvc_ss_streaming_ep = {
 	.bLength		= USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType	= USB_DT_ENDPOINT,
-
 	.bEndpointAddress	= USB_DIR_IN,
-	.bmAttributes		= USB_ENDPOINT_SYNC_ASYNC
-				| USB_ENDPOINT_XFER_ISOC,
+	.bmAttributes		= USB_ENDPOINT_SYNC_ASYNC | USB_ENDPOINT_XFER_ISOC,
 	/* The wMaxPacketSize and bInterval values will be initialized from
 	 * module parameters.
 	 */
 };
-
-static struct usb_ss_ep_comp_descriptor uvc_ss_streaming_comp = {
-	.bLength		= sizeof(uvc_ss_streaming_comp),
-	.bDescriptorType	= USB_DT_SS_ENDPOINT_COMP,
-	/* The bMaxBurst, bmAttributes and wBytesPerInterval values will be
-	 * initialized from module parameters.
-	 */
-};
-
 static const struct usb_descriptor_header * const uvc_fs_streaming[] = {
 	(struct usb_descriptor_header *) &uvc_streaming_intf_alt1,
 	(struct usb_descriptor_header *) &uvc_fs_streaming_ep,
@@ -196,6 +254,27 @@ static const struct usb_descriptor_header * const uvc_ss_streaming[] = {
 	(struct usb_descriptor_header *) &uvc_ss_streaming_comp,
 	NULL,
 };
+#endif
+
+DECLARE_UVC_EXTENSION_UNIT_DESCRIPTOR(1, 2);
+
+static const struct UVC_EXTENSION_UNIT_DESCRIPTOR(1, 2) uvc_extension_unit = {
+	.bLength		= UVC_DT_EXTENSION_UNIT_SIZE(1,2),
+	.bDescriptorType	= USB_DT_CS_INTERFACE,
+	.bDescriptorSubType	= UVC_VC_EXTENSION_UNIT,
+	.bUnitID		= 4,
+	.guidExtensionCode	=
+		{ 0xd4, 0x1f, 0x59, 0xfa, 0x50, 0x94, 0x46, 0x3a,
+		  0xb3, 0xbb, 0xe7, 0x85, 0x8a, 0x83, 0x1f, 0xa3},
+	.bNumControls		= 4,
+	.bNrInPins		= 1,
+	.baSourceID[0]		= 2,
+	.bControlSize		= 2,
+	.bmControls[0]		= 0x0f,
+	.bmControls[1]		= 0x00,
+	.iExtension		= 0,
+};
+
 
 void uvc_set_trace_param(unsigned int trace)
 {
@@ -297,7 +376,7 @@ uvc_function_set_alt(struct usb_function *f, unsigned interface, unsigned alt)
 		if (alt)
 			return -EINVAL;
 
-		INFO(cdev, "reset UVC Control\n");
+		INFO(cdev, "reset UVC Control Endpoint\n");
 		usb_ep_disable(uvc->control_ep);
 
 		if (!uvc->control_ep->desc)
@@ -312,6 +391,7 @@ uvc_function_set_alt(struct usb_function *f, unsigned interface, unsigned alt)
 			uvc_event->speed = cdev->gadget->speed;
 			v4l2_event_queue(&uvc->vdev, &v4l2_event);
 
+			INFO(cdev, "UVC Connected\n");
 			uvc->state = UVC_STATE_CONNECTED;
 		}
 
@@ -321,50 +401,65 @@ uvc_function_set_alt(struct usb_function *f, unsigned interface, unsigned alt)
 	if (interface != uvc->streaming_intf)
 		return -EINVAL;
 
-	/* TODO
-	if (usb_endpoint_xfer_bulk(&uvc->desc.vs_ep))
-		return alt ? -EINVAL : 0;
-	*/
+#ifdef BULK
+	if (uvc->state != UVC_STATE_CONNECTED)
+		return 0;
 
-	switch (alt) {
-	case 0:
-		if (uvc->state != UVC_STATE_STREAMING)
-			return 0;
+	if (!uvc->video.ep)
+		return -EINVAL;
 
-		if (uvc->video.ep)
-			usb_ep_disable(uvc->video.ep);
+	INFO(cdev, "Reset UVC video ep\n");
+	if (uvc->video.ep)
+		usb_ep_disable(uvc->video.ep);
 
-		memset(&v4l2_event, 0, sizeof(v4l2_event));
-		v4l2_event.type = UVC_EVENT_STREAMOFF;
-		v4l2_event_queue(&uvc->vdev, &v4l2_event);
+	ret = config_ep_by_speed(f->config->cdev->gadget,
+			&(uvc->func), uvc->video.ep);
+	if (ret)
+		return ret;
+	if (uvc->video.ep)
+		usb_ep_enable(uvc->video.ep);
+	return 0;
+#else
+	switch (alt) {
+		case 0:
+			if (uvc->state != UVC_STATE_STREAMING)
+				return 0;
 
-		uvc->state = UVC_STATE_CONNECTED;
-		return 0;
+			if (uvc->video.ep)
+				usb_ep_disable(uvc->video.ep);
 
-	case 1:
-		if (uvc->state != UVC_STATE_CONNECTED)
+			memset(&v4l2_event, 0, sizeof(v4l2_event));
+			v4l2_event.type = UVC_EVENT_STREAMOFF;
+			v4l2_event_queue(&uvc->vdev, &v4l2_event);
+
+			uvc->state = UVC_STATE_CONNECTED;
 			return 0;
 
-		if (!uvc->video.ep)
-			return -EINVAL;
+		case 1:
+			if (uvc->state != UVC_STATE_CONNECTED)
+				return 0;
 
-		INFO(cdev, "reset UVC\n");
-		usb_ep_disable(uvc->video.ep);
+			if (!uvc->video.ep)
+				return -EINVAL;
 
-		ret = config_ep_by_speed(f->config->cdev->gadget,
-				&(uvc->func), uvc->video.ep);
-		if (ret)
-			return ret;
-		usb_ep_enable(uvc->video.ep);
+			INFO(cdev, "reset UVC\n");
+			usb_ep_disable(uvc->video.ep);
 
-		memset(&v4l2_event, 0, sizeof(v4l2_event));
-		v4l2_event.type = UVC_EVENT_STREAMON;
-		v4l2_event_queue(&uvc->vdev, &v4l2_event);
-		return USB_GADGET_DELAYED_STATUS;
+			ret = config_ep_by_speed(f->config->cdev->gadget,
+					&(uvc->func), uvc->video.ep);
+			if (ret)
+				return ret;
+			usb_ep_enable(uvc->video.ep);
 
-	default:
-		return -EINVAL;
+			memset(&v4l2_event, 0, sizeof(v4l2_event));
+			v4l2_event.type = UVC_EVENT_STREAMON;
+			v4l2_event_queue(&uvc->vdev, &v4l2_event);
+			return 0; //USB_GADGET_DELAYED_STATUS;
+
+		default:
+			return -EINVAL;
 	}
+#endif
 }
 
 static void
@@ -395,6 +490,8 @@ uvc_function_connect(struct uvc_device *uvc)
 	struct usb_composite_dev *cdev = uvc->func.config->cdev;
 	int ret;
 
+        INFO(cdev, "UVC connect\n");
+
 	if ((ret = usb_function_activate(&uvc->func)) < 0)
 		INFO(cdev, "UVC connect failed with %d\n", ret);
 }
@@ -405,6 +502,7 @@ uvc_function_disconnect(struct uvc_device *uvc)
 	struct usb_composite_dev *cdev = uvc->func.config->cdev;
 	int ret;
 
+        INFO(cdev, "UVC disconnect\n");
 	if ((ret = usb_function_deactivate(&uvc->func)) < 0)
 		INFO(cdev, "UVC disconnect failed with %d\n", ret);
 }
@@ -525,17 +623,22 @@ uvc_copy_descriptors(struct uvc_device *uvc, enum usb_device_speed speed)
 	 */
 
 	/* Count descriptors and compute their size. */
-	control_size = 0;
+	control_size = uvc_extension_unit.bLength;
 	streaming_size = 0;
 	bytes = uvc_iad.bLength + uvc_control_intf.bLength
 	      + uvc_control_ep.bLength + uvc_control_cs_ep.bLength
-	      + uvc_streaming_intf_alt0.bLength;
+              + uvc_extension_unit.bLength;
+#ifdef BULK
+      	bytes += uvc_streaming_intf.bLength;
+#else
+	bytes += uvc_streaming_intf_alt0.bLength;
+#endif
 
 	if (speed == USB_SPEED_SUPER) {
 		bytes += uvc_ss_control_comp.bLength;
-		n_desc = 6;
+		n_desc = 7;
 	} else {
-		n_desc = 5;
+		n_desc = 6;
 	}
 
 	for (src = (const struct usb_descriptor_header **)uvc_control_desc;
@@ -574,12 +677,18 @@ uvc_copy_descriptors(struct uvc_device *uvc, enum usb_device_speed speed)
 	uvc_control_header->bInCollection = 1;
 	uvc_control_header->baInterfaceNr[0] = uvc->streaming_intf;
 
+	UVC_COPY_DESCRIPTOR(mem, dst, &uvc_extension_unit);
+
 	UVC_COPY_DESCRIPTOR(mem, dst, &uvc_control_ep);
 	if (speed == USB_SPEED_SUPER)
 		UVC_COPY_DESCRIPTOR(mem, dst, &uvc_ss_control_comp);
 
 	UVC_COPY_DESCRIPTOR(mem, dst, &uvc_control_cs_ep);
+#ifdef BULK
+	UVC_COPY_DESCRIPTOR(mem, dst, &uvc_streaming_intf);
+#else
 	UVC_COPY_DESCRIPTOR(mem, dst, &uvc_streaming_intf_alt0);
+#endif
 
 	uvc_streaming_header = mem;
 	UVC_COPY_DESCRIPTORS(mem, dst,
@@ -681,6 +790,13 @@ uvc_function_bind(struct usb_configuration *c, struct usb_function *f)
 	uvc_hs_streaming_ep.bEndpointAddress = uvc->video.ep->address;
 	uvc_ss_streaming_ep.bEndpointAddress = uvc->video.ep->address;
 
+#ifdef BULK
+	// BULK packet size is forced to 64 by auto config (!)
+	uvc_fs_streaming_ep.wMaxPacketSize = cpu_to_le16(64);
+	uvc_hs_streaming_ep.wMaxPacketSize = cpu_to_le16(512);
+	uvc_ss_streaming_ep.wMaxPacketSize = cpu_to_le16(512);
+#endif
+
 	us = usb_gstrings_attach(cdev, uvc_function_strings,
 				 ARRAY_SIZE(uvc_en_us_strings));
 	if (IS_ERR(us)) {
@@ -690,8 +806,12 @@ uvc_function_bind(struct usb_configuration *c, struct usb_function *f)
 	uvc_iad.iFunction = us[UVC_STRING_CONTROL_IDX].id;
 	uvc_control_intf.iInterface = us[UVC_STRING_CONTROL_IDX].id;
 	ret = us[UVC_STRING_STREAMING_IDX].id;
+#ifdef BULK
+	uvc_streaming_intf.iInterface = ret;
+#else
 	uvc_streaming_intf_alt0.iInterface = ret;
 	uvc_streaming_intf_alt1.iInterface = ret;
+#endif        
 
 	/* Allocate interface IDs. */
 	if ((ret = usb_interface_id(c, f)) < 0)
@@ -702,8 +822,12 @@ uvc_function_bind(struct usb_configuration *c, struct usb_function *f)
 
 	if ((ret = usb_interface_id(c, f)) < 0)
 		goto error;
+#ifdef BULK
+	uvc_streaming_intf.bInterfaceNumber = ret;
+#else
 	uvc_streaming_intf_alt0.bInterfaceNumber = ret;
 	uvc_streaming_intf_alt1.bInterfaceNumber = ret;
+#endif	
 	uvc->streaming_intf = ret;
 
 	/* Copy descriptors */
@@ -752,6 +876,10 @@ uvc_function_bind(struct usb_configuration *c, struct usb_function *f)
 	if (ret < 0)
 		goto error;
 
+#ifdef BULK
+	uvc->video.max_payload_size = 16 * 1024;
+#endif
+
 	/* Register a V4L2 device. */
 	ret = uvc_register_video(uvc);
 	if (ret < 0) {
@@ -896,6 +1024,11 @@ static void uvc_unbind(struct usb_configuration *c, struct usb_function *f)
 	kfree(uvc->control_buf);
 
 	usb_free_all_descriptors(f);
+
+	if (uvc->func.bind_deactivated) {
+		if (usb_function_activate(&uvc->func) < 0)
+			INFO(cdev, "USB activate failed\n");
+	}
 }
 
 static struct usb_function *uvc_alloc(struct usb_function_instance *fi)
@@ -946,6 +1079,7 @@ static struct usb_function *uvc_alloc(struct usb_function_instance *fi)
 	uvc->func.disable = uvc_function_disable;
 	uvc->func.setup = uvc_function_setup;
 	uvc->func.free_func = uvc_free;
+	/* Avoid letting this gadget enumerate until the user space app is active */
 	uvc->func.bind_deactivated = true;
 
 	return &uvc->func;
diff --git a/drivers/usb/gadget/function/uvc_v4l2.c b/drivers/usb/gadget/function/uvc_v4l2.c
index 7f1ca3b57823..d95f1a451521 100644
--- a/drivers/usb/gadget/function/uvc_v4l2.c
+++ b/drivers/usb/gadget/function/uvc_v4l2.c
@@ -25,6 +25,8 @@
 #include "uvc_video.h"
 #include "uvc_v4l2.h"
 
+//#define BULK
+
 /* --------------------------------------------------------------------------
  * Requests handling
  */
@@ -58,6 +60,7 @@ struct uvc_format {
 static struct uvc_format uvc_formats[] = {
 	{ 16, V4L2_PIX_FMT_YUYV  },
 	{ 0,  V4L2_PIX_FMT_MJPEG },
+	{ 16, V4L2_PIX_FMT_Y16   },
 };
 
 static int
@@ -202,11 +205,13 @@ uvc_v4l2_streamon(struct file *file, void *fh, enum v4l2_buf_type type)
 	if (ret < 0)
 		return ret;
 
+#ifndef BULK
 	/*
 	 * Complete the alternate setting selection setup phase now that
 	 * userspace is ready to provide video frames.
 	 */
-	uvc_function_setup_continue(uvc);
+	//uvc_function_setup_continue(uvc);
+#endif
 	uvc->state = UVC_STATE_STREAMING;
 
 	return 0;
-- 
2.17.1

