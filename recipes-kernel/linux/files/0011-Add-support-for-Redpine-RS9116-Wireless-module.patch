From 7ae1cd35ab9424ee0f48128f8f0fa7d1798317c4 Mon Sep 17 00:00:00 2001
From: Peter Fitger <peter.fitger@flir.se>
Date: Tue, 5 Jun 2018 11:04:08 +0200
Subject: [PATCH 1/2] Add support for Redpine RS9116 Wireless module

Source code as delivered in RS9113.NBZ.NL.GNU.LNX.1.4.RC1
---
 drivers/net/wireless/rsi/Kconfig            |   50 +-
 drivers/net/wireless/rsi/Makefile           |   59 +-
 drivers/net/wireless/rsi/rsi_91x_coex.c     |  209 ++
 drivers/net/wireless/rsi/rsi_91x_core.c     |  342 +++-
 drivers/net/wireless/rsi/rsi_91x_debugfs.c  |  565 +++++-
 drivers/net/wireless/rsi/rsi_91x_hal.c      | 1583 +++++++++++++++
 drivers/net/wireless/rsi/rsi_91x_hci.c      |  448 +++++
 drivers/net/wireless/rsi/rsi_91x_mac80211.c | 2258 +++++++++++++++++++--
 drivers/net/wireless/rsi/rsi_91x_main.c     |  406 +++-
 drivers/net/wireless/rsi/rsi_91x_mgmt.c     | 2837 ++++++++++++++++++++++++---
 drivers/net/wireless/rsi/rsi_91x_ps.c       |  216 ++
 drivers/net/wireless/rsi/rsi_91x_rrm.c      |  763 +++++++
 drivers/net/wireless/rsi/rsi_91x_sdio.c     | 1073 +++++++++-
 drivers/net/wireless/rsi/rsi_91x_sdio_ops.c |  413 ++--
 drivers/net/wireless/rsi/rsi_91x_usb.c      |  914 +++++++--
 drivers/net/wireless/rsi/rsi_91x_usb_ops.c  |  200 +-
 drivers/net/wireless/rsi/rsi_91x_zigb.c     |  488 +++++
 drivers/net/wireless/rsi/rsi_boot_params.h  |  239 ++-
 drivers/net/wireless/rsi/rsi_coex.h         |   67 +
 drivers/net/wireless/rsi/rsi_common.h       |   75 +-
 drivers/net/wireless/rsi/rsi_debugfs.h      |   38 +-
 drivers/net/wireless/rsi/rsi_hal.h          |  252 +++
 drivers/net/wireless/rsi/rsi_hci.h          |  128 ++
 drivers/net/wireless/rsi/rsi_main.h         |  487 ++++-
 drivers/net/wireless/rsi/rsi_mgmt.h         |  518 ++++-
 drivers/net/wireless/rsi/rsi_ps.h           |   76 +
 drivers/net/wireless/rsi/rsi_rrm.h          |  220 +++
 drivers/net/wireless/rsi/rsi_sdio.h         |  164 +-
 drivers/net/wireless/rsi/rsi_usb.h          |  104 +-
 drivers/net/wireless/rsi/rsi_zigb.h         |  166 ++
 31 files changed, 13748 insertions(+), 1610 deletions(-)
 create mode 100644 drivers/net/wireless/rsi/rsi_91x_coex.c
 create mode 100644 drivers/net/wireless/rsi/rsi_91x_hal.c
 create mode 100644 drivers/net/wireless/rsi/rsi_91x_hci.c
 create mode 100644 drivers/net/wireless/rsi/rsi_91x_ps.c
 create mode 100644 drivers/net/wireless/rsi/rsi_91x_rrm.c
 create mode 100644 drivers/net/wireless/rsi/rsi_91x_zigb.c
 create mode 100644 drivers/net/wireless/rsi/rsi_coex.h
 create mode 100644 drivers/net/wireless/rsi/rsi_hal.h
 create mode 100644 drivers/net/wireless/rsi/rsi_hci.h
 create mode 100644 drivers/net/wireless/rsi/rsi_ps.h
 create mode 100644 drivers/net/wireless/rsi/rsi_rrm.h
 create mode 100755 drivers/net/wireless/rsi/rsi_zigb.h

diff --git a/drivers/net/wireless/rsi/Kconfig b/drivers/net/wireless/rsi/Kconfig
index 7c5e4ca..4a2e0de 100644
--- a/drivers/net/wireless/rsi/Kconfig
+++ b/drivers/net/wireless/rsi/Kconfig
@@ -24,7 +24,7 @@ config RSI_DEBUGFS
 	default y
 	---help---
 	 Say Y, if you would like to enable debug support. This option
-	 creates debugfs entries
+	 creates debugfs entries.
 
 config RSI_SDIO
 	tristate "Redpine Signals SDIO bus support"
@@ -42,4 +42,52 @@ config RSI_USB
 	  This option enables the USB bus support in rsi drivers.
 	  Select M (recommended), if you have a RSI 1x1 wireless module.
 
+config RSI_BT_ALONE
+	bool "Redpine Signals BT alone (classic/LE) mode support"
+	depends on RSI_91X
+	default n
+	---help---
+	  This option enables the BT classic alone upport in rsi drivers.
+	  Say Y, if you want to use this feature.
+
+config RSI_COEX
+	bool "Redpine Signals Wi-Fi BT Coex support"
+	depends on RSI_91X
+	default n
+	---help---
+	  This option enables the Wi-Fi BT coex support in rsi drivers.
+	  Select Y, if you have to use this feature.
+
+config RSI_WOW
+	bool "Redpine Signals WoWLAN support"
+	depends on RSI_91X
+	default n
+	---help---
+	  This option enables the WoWLAN support.
+	  Say Y if you want to use this feature.
+
+config RSI_P2P
+	bool "Redpine Signals Wi-Fi Direct support"
+	depends on RSI_91X
+	default n
+	---help---
+	  This option enables the Wi-Fi Direct support in rsi drivers.
+	  Select Y, if you have to use this feature.
+
+config HW_SCAN_OFFLOAD 
+	bool "Redpine Signals Hardware scan offload feature"
+	depends on RSI_91X
+	default n
+	---help---
+	  This option enables the hardware scan offload option in rsi drivers.
+	  Select Y, if you have to use this feature.
+
+config CARACALLA_BOARD 
+	bool "Redpine device support on Caracalla board"
+	depends on RSI_91X
+	default n
+	---help---
+	  This option is used to support Caracalla board with RSI driver.
+	  Select Y, if you have to use this support.
+
 endif # WLAN_VENDOR_RSI
diff --git a/drivers/net/wireless/rsi/Makefile b/drivers/net/wireless/rsi/Makefile
index 25828b6..cd54524 100644
--- a/drivers/net/wireless/rsi/Makefile
+++ b/drivers/net/wireless/rsi/Makefile
@@ -1,12 +1,47 @@
-rsi_91x-y			+= rsi_91x_main.o
-rsi_91x-y			+= rsi_91x_core.o
-rsi_91x-y			+= rsi_91x_mac80211.o
-rsi_91x-y			+= rsi_91x_mgmt.o
-rsi_91x-y			+= rsi_91x_pkt.o
-rsi_91x-$(CONFIG_RSI_DEBUGFS)	+= rsi_91x_debugfs.o
-
-rsi_usb-y			+= rsi_91x_usb.o rsi_91x_usb_ops.o
-rsi_sdio-y			+= rsi_91x_sdio.o rsi_91x_sdio_ops.o
-obj-$(CONFIG_RSI_91X) 		+= rsi_91x.o
-obj-$(CONFIG_RSI_SDIO)		+= rsi_sdio.o
-obj-$(CONFIG_RSI_USB)		+= rsi_usb.o
+#/*
+# Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are met:
+#
+# 	1. Redistributions of source code must retain the above copyright
+# 	   notice, this list of conditions and the following disclaimer.
+#
+# 	2. Redistributions in binary form must reproduce the above copyright
+# 	   notice, this list of conditions and the following disclaimer in the
+# 	   documentation and/or other materials provided with the distribution.
+#
+# 	3. Neither the name of the copyright holder nor the names of its
+# 	   contributors may be used to endorse or promote products derived from
+# 	   this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+# INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#*/
+
+rsi_91x-y			+= rsi_91x_main.o
+rsi_91x-y			+= rsi_91x_core.o
+rsi_91x-y			+= rsi_91x_mac80211.o
+rsi_91x-y			+= rsi_91x_mgmt.o
+rsi_91x-y			+= rsi_91x_hal.o
+rsi_91x-y			+= rsi_91x_ps.o
+rsi_91x-$(CONFIG_RSI_DEBUGFS)	+= rsi_91x_debugfs.o
+rsi_91x-$(CONFIG_RSI_BT_ALONE)	+= rsi_91x_hci.o
+rsi_91x-$(CONFIG_RSI_COEX)	+= rsi_91x_coex.o
+rsi_91x-$(CONFIG_RSI_COEX)	+= rsi_91x_hci.o
+rsi_91x-$(CONFIG_RSI_11K)	+= rsi_91x_rrm.o
+
+rsi_usb-$(CONFIG_RSI_USB)	+= rsi_91x_usb.o rsi_91x_usb_ops.o
+rsi_sdio-$(CONFIG_RSI_SDIO)	+= rsi_91x_sdio.o rsi_91x_sdio_ops.o
+obj-$(CONFIG_RSI_91X) 		+= rsi_91x.o
+obj-$(CONFIG_RSI_SDIO)		+= rsi_sdio.o
+obj-$(CONFIG_RSI_USB)		+= rsi_usb.o
diff --git a/drivers/net/wireless/rsi/rsi_91x_coex.c b/drivers/net/wireless/rsi/rsi_91x_coex.c
new file mode 100644
index 0000000..c11bc8e
--- /dev/null
+++ b/drivers/net/wireless/rsi/rsi_91x_coex.c
@@ -0,0 +1,209 @@
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
+ *
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
+ *
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "rsi_main.h"
+#include "rsi_coex.h"
+#include "rsi_hal.h"
+#include "rsi_mgmt.h"
+
+static u8 rsi_coex_determine_coex_q(struct rsi_coex_ctrl_block *coex_cb)
+{
+	u8 q_num = INVALID_QUEUE;
+
+	if (skb_queue_len(&coex_cb->coex_tx_qs[VIP_Q]) > 0)
+		q_num = VIP_Q;
+	if (skb_queue_len(&coex_cb->coex_tx_qs[COEX_Q]) > 0)
+		q_num = COEX_Q;
+	if (skb_queue_len(&coex_cb->coex_tx_qs[BT_Q]) > 0)
+		q_num = BT_Q;
+	if (skb_queue_len(&coex_cb->coex_tx_qs[ZIGB_Q]) > 0)
+		q_num = ZIGB_Q;
+	if (skb_queue_len(&coex_cb->coex_tx_qs[WLAN_Q]) > 0)
+		q_num = WLAN_Q;
+
+	return q_num;
+}
+
+static void rsi_coex_sched_tx_pkts(struct rsi_coex_ctrl_block *coex_cb)
+{
+	u8 coex_q;
+	struct sk_buff *skb;
+#ifdef CONFIG_RSI_ZIGB
+	struct rsi_common *common = coex_cb->priv;
+#endif
+	while (1) {
+		coex_q = rsi_coex_determine_coex_q(coex_cb);
+		rsi_dbg(INFO_ZONE, "queue = %d\n", coex_q);
+
+		if (coex_q == INVALID_QUEUE) {
+			rsi_dbg(DATA_TX_ZONE, "No more pkt\n");
+			break;
+		}
+
+		if ((coex_q == BT_Q) || (coex_q == ZIGB_Q)) {
+			skb = skb_dequeue(&coex_cb->coex_tx_qs[BT_Q]);
+#ifdef CONFIG_RSI_ZIGB
+			if (common->zb_fsm_state == ZB_DEVICE_READY) {
+				rsi_dbg(DATA_TX_ZONE, "Sending zigbee pkt\n");
+				rsi_send_zb_pkt(coex_cb->priv, skb);
+			} else {
+#endif
+				rsi_dbg(DATA_TX_ZONE, "Sending BT pkt\n");
+				rsi_send_bt_pkt(coex_cb->priv, skb);
+#ifdef CONFIG_RSI_ZIGB
+			}
+#endif
+		}
+	}
+}
+
+/**
+ * rsi_coex_scheduler_thread() - This function is a kernel thread to schedule
+ *			       the coex packets to device
+ * @common: Pointer to the driver private structure.
+ *
+ * Return: None.
+ */
+static void rsi_coex_scheduler_thread(struct rsi_common *common)
+{
+	struct rsi_coex_ctrl_block *coex_cb =
+		(struct rsi_coex_ctrl_block *)common->coex_cb;
+
+	u32 timeout = EVENT_WAIT_FOREVER;
+
+	do {
+		rsi_wait_event(&coex_cb->coex_tx_thread.event, timeout);
+		rsi_reset_event(&coex_cb->coex_tx_thread.event);
+
+		rsi_coex_sched_tx_pkts(coex_cb);
+	} while (atomic_read(&coex_cb->coex_tx_thread.thread_done) == 0);
+
+	complete_and_exit(&coex_cb->coex_tx_thread.completion, 0);
+}
+
+int rsi_coex_recv_pkt(struct rsi_common *common, u8 *msg)
+{
+	u16 msg_type = msg[2];
+
+	if (msg_type == COMMON_CARD_READY_IND) {
+		common->hibernate_resume = false;
+		rsi_dbg(INFO_ZONE, "COMMON CARD READY RECEIVED\n");
+		rsi_handle_card_ready(common, msg);
+	} else if (msg_type == SLEEP_NOTIFY_IND) {
+		rsi_dbg(INFO_ZONE, "\n\n sleep notify RECEIVED\n");
+		rsi_mgmt_pkt_recv(common, msg);
+	}
+
+	return 0;
+}
+
+int rsi_coex_send_pkt(void *priv,
+		      struct sk_buff *skb,
+		      u8 hal_queue)
+{
+	struct rsi_common *common = (struct rsi_common *)priv;
+	struct rsi_coex_ctrl_block *coex_cb =
+		(struct rsi_coex_ctrl_block *)common->coex_cb;
+	struct skb_info *tx_params = NULL;
+	int status = 0;
+
+	/* Add pkt to queue if not WLAN packet */
+	if (hal_queue != RSI_WLAN_Q) {
+		skb_queue_tail(&coex_cb->coex_tx_qs[hal_queue], skb);
+		rsi_set_event(&coex_cb->coex_tx_thread.event);
+		return status;
+	}
+	if (common->iface_down) {
+		tx_params = (struct skb_info *)&IEEE80211_SKB_CB(skb)->driver_data;
+
+		if (!(tx_params->flags & INTERNAL_MGMT_PKT)) {
+			rsi_indicate_tx_status(common->priv, skb, -EINVAL);
+			return 0;
+		}
+	}
+
+	/* Send packet to hal */
+	if (skb->priority == MGMT_SOFT_Q)
+		status = rsi_send_mgmt_pkt(common, skb);
+	else
+		status = rsi_send_data_pkt(common, skb);
+
+	return 0;
+}
+
+int rsi_coex_init(struct rsi_common *common)
+{
+	struct rsi_coex_ctrl_block *coex_cb = NULL;
+	int cnt;
+
+	coex_cb = kzalloc(sizeof(*coex_cb), GFP_KERNEL);
+	if (!coex_cb)
+		return -ENOMEM;
+
+	common->coex_cb = (void *)coex_cb;
+	coex_cb->priv = common;
+	sema_init(&coex_cb->tx_bus_lock, 1);
+
+	/* Initialize co-ex queues */
+	for (cnt = 0; cnt < NUM_COEX_TX_QUEUES; cnt++)
+		skb_queue_head_init(&coex_cb->coex_tx_qs[cnt]);
+	rsi_init_event(&coex_cb->coex_tx_thread.event);
+
+	/* Initialize co-ex thread */
+	if (rsi_create_kthread(common,
+			       &coex_cb->coex_tx_thread,
+			       rsi_coex_scheduler_thread,
+			       "Coex-Tx-Thread")) {
+		rsi_dbg(ERR_ZONE, "%s: Unable to init tx thrd\n", __func__);
+		goto err;
+	}
+	return 0;
+
+err:
+	return -EINVAL;
+}
+
+void rsi_coex_deinit(struct rsi_common *common)
+{
+	int cnt;
+
+	struct rsi_coex_ctrl_block *coex_cb =
+		(struct rsi_coex_ctrl_block *)common->coex_cb;
+
+	/* Stop the coex tx thread */
+	rsi_kill_thread(&coex_cb->coex_tx_thread);
+
+	/* Empty the coex queue */
+	for (cnt = 0; cnt < NUM_COEX_TX_QUEUES; cnt++)
+		skb_queue_purge(&coex_cb->coex_tx_qs[cnt]);
+
+	/* Free the coex control block */
+	kfree(coex_cb);
+}
diff --git a/drivers/net/wireless/rsi/rsi_91x_core.c b/drivers/net/wireless/rsi/rsi_91x_core.c
index f3d3995..2621e2c 100644
--- a/drivers/net/wireless/rsi/rsi_91x_core.c
+++ b/drivers/net/wireless/rsi/rsi_91x_core.c
@@ -1,21 +1,39 @@
-/**
- * Copyright (c) 2014 Redpine Signals Inc.
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
+ *
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
  *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
  *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include "rsi_mgmt.h"
 #include "rsi_common.h"
+#include "rsi_hal.h"
+#ifdef CONFIG_RSI_COEX
+#include "rsi_coex.h"
+#endif
 
 /**
  * rsi_determine_min_weight_queue() - This function determines the queue with
@@ -106,9 +124,9 @@ static u32 rsi_get_num_pkts_dequeue(struct rsi_common *common, u8 q_num)
 
 	do {
 		r_txop = ieee80211_generic_frame_duration(adapter->hw,
-							  adapter->vifs[0],
-							  common->band,
-							  skb->len, &rate);
+					adapter->vifs[adapter->sc_nvifs - 1],
+					common->band,
+					skb->len, &rate);
 		txop -= le16_to_cpu(r_txop);
 		pkt_cnt += 1;
 		/*checking if pkts are still there*/
@@ -134,7 +152,12 @@ static u8 rsi_core_determine_hal_queue(struct rsi_common *common)
 	bool recontend_queue = false;
 	u32 q_len = 0;
 	u8 q_num = INVALID_QUEUE;
-	u8 ii = 0;
+	u8 ii;
+	
+	if (skb_queue_len(&common->tx_queue[MGMT_BEACON_Q])) {
+		q_num = MGMT_BEACON_Q;
+		return q_num;
+	}
 
 	if (skb_queue_len(&common->tx_queue[MGMT_SOFT_Q])) {
 		if (!common->mgmt_q_block)
@@ -142,8 +165,10 @@ static u8 rsi_core_determine_hal_queue(struct rsi_common *common)
 		return q_num;
 	}
 
-	if (common->hw_data_qs_blocked)
+	if (common->hw_data_qs_blocked) {
+		rsi_dbg(INFO_ZONE, "%s: data queue blocked\n", __func__);
 		return q_num;
+	}
 
 	if (common->pkt_cnt != 0) {
 		--common->pkt_cnt;
@@ -210,6 +235,7 @@ static void rsi_core_queue_pkt(struct rsi_common *common,
 			       struct sk_buff *skb)
 {
 	u8 q_num = skb->priority;
+
 	if (q_num >= NUM_SOFT_QUEUES) {
 		rsi_dbg(ERR_ZONE, "%s: Invalid Queue Number: q_num = %d\n",
 			__func__, q_num);
@@ -263,54 +289,137 @@ void rsi_core_qos_processor(struct rsi_common *common)
 		rsi_dbg(DATA_TX_ZONE,
 			"%s: Queue number = %d\n", __func__, q_num);
 
-		if (q_num == INVALID_QUEUE) {
-			rsi_dbg(DATA_TX_ZONE, "%s: No More Pkt\n", __func__);
+		if (q_num == INVALID_QUEUE)
 			break;
-		}
 
-		mutex_lock(&common->tx_rxlock);
-
-		status = adapter->check_hw_queue_status(adapter, q_num);
-		if ((status <= 0)) {
-			mutex_unlock(&common->tx_rxlock);
+		if (common->hibernate_resume)
 			break;
+
+		mutex_lock(&common->tx_lock);
+
+		status = adapter->host_intf_ops->check_hw_queue_status(adapter,
+								       q_num);
+		if (status <= 0) {
+			if ((q_num < MGMT_SOFT_Q) ||
+			    ((!adapter->peer_notify) &&
+			     (q_num == MGMT_SOFT_Q))) {
+				mutex_unlock(&common->tx_lock);
+				break;
+			}
 		}
 
 		if ((q_num < MGMT_SOFT_Q) &&
 		    ((skb_queue_len(&common->tx_queue[q_num])) <=
 		      MIN_DATA_QUEUE_WATER_MARK)) {
+			if (!adapter->hw) {
+				mutex_unlock(&common->tx_lock);
+				break;
+			}
 			if (ieee80211_queue_stopped(adapter->hw, WME_AC(q_num)))
 				ieee80211_wake_queue(adapter->hw,
 						     WME_AC(q_num));
 		}
 
 		skb = rsi_core_dequeue_pkt(common, q_num);
-		if (skb == NULL) {
+		if (!skb) {
 			rsi_dbg(ERR_ZONE, "skb null\n");
-			mutex_unlock(&common->tx_rxlock);
+			mutex_unlock(&common->tx_lock);
 			break;
 		}
-
+		if ((adapter->peer_notify) &&
+		    (skb->data[2] == PEER_NOTIFY)) {
+			adapter->peer_notify = false;
+			rsi_dbg(INFO_ZONE, "%s RESET PEER_NOTIFY\n", __func__);
+		}
+#ifdef CONFIG_RSI_COEX
+		if (q_num == MGMT_BEACON_Q) {
+			status = rsi_send_pkt(common, skb);
+			dev_kfree_skb(skb);
+		} else
+			status = rsi_coex_send_pkt(common, skb, RSI_WLAN_Q);
+#else
 		if (q_num == MGMT_SOFT_Q)
 			status = rsi_send_mgmt_pkt(common, skb);
-		else
+		else if(q_num == MGMT_BEACON_Q) {
+			status = rsi_send_pkt(common, skb);
+			dev_kfree_skb(skb);
+		} else
 			status = rsi_send_data_pkt(common, skb);
+#endif
 
 		if (status) {
-			mutex_unlock(&common->tx_rxlock);
+			mutex_unlock(&common->tx_lock);
 			break;
 		}
 
 		common->tx_stats.total_tx_pkt_send[q_num]++;
 
 		tstamp_2 = jiffies;
-		mutex_unlock(&common->tx_rxlock);
+		mutex_unlock(&common->tx_lock);
 
 		if (tstamp_2 > tstamp_1 + (300 * HZ / 1000))
 			schedule();
 	}
 }
 
+char *dot11_pkt_type(__le16 frame_control)
+{
+	if (ieee80211_is_beacon(frame_control))
+		return "BEACON";
+	if (ieee80211_is_assoc_req(frame_control))
+		return "ASSOC_REQ";
+	if (ieee80211_is_assoc_resp(frame_control))
+		return "ASSOC_RESP";
+	if (ieee80211_is_reassoc_req(frame_control))
+		return "REASSOC_REQ";
+	if (ieee80211_is_reassoc_resp(frame_control))
+		return "REASSOC_RESP";
+	if (ieee80211_is_auth(frame_control))
+		return "AUTH";
+	if (ieee80211_is_probe_req(frame_control))
+		return "PROBE_REQ";
+	if (ieee80211_is_probe_resp(frame_control))
+		return "PROBE_RESP";
+	if (ieee80211_is_disassoc(frame_control))
+		return "DISASSOC";
+	if (ieee80211_is_deauth(frame_control))
+		return "DEAUTH";
+	if (ieee80211_is_action(frame_control))
+		return "ACTION";
+	if (ieee80211_is_data_qos(frame_control))
+		return "QOS DATA";
+	if (ieee80211_is_pspoll(frame_control))
+		return "PS_POLL";
+	if (ieee80211_is_nullfunc(frame_control))
+		return "NULL_DATA";
+	if (ieee80211_is_qos_nullfunc(frame_control))
+		return "QOS_NULL_DATA";
+
+	if (ieee80211_is_mgmt(frame_control))
+		return "DOT11_MGMT";
+	if (ieee80211_is_data(frame_control))
+		return "DOT11_DATA";
+	if (ieee80211_is_ctl(frame_control))
+		return "DOT11_CTRL";
+
+	return "UNKNOWN";
+}
+EXPORT_SYMBOL_GPL(dot11_pkt_type);
+
+struct rsi_sta *rsi_find_sta(struct rsi_common *common, u8 *mac_addr)
+{
+	int i;
+
+	for (i = 0; i < common->max_stations; i++) {
+		if (!common->stations[i].sta)
+			continue;
+		if (!(memcmp(common->stations[i].sta->addr,
+			     mac_addr, ETH_ALEN)))
+			return &common->stations[i];
+	}
+	return NULL;
+}
+
 /**
  * rsi_core_xmit() - This function transmits the packets received from mac80211
  * @common: Pointer to the driver private structure.
@@ -323,7 +432,8 @@ void rsi_core_xmit(struct rsi_common *common, struct sk_buff *skb)
 	struct rsi_hw *adapter = common->priv;
 	struct ieee80211_tx_info *info;
 	struct skb_info *tx_params;
-	struct ieee80211_hdr *tmp_hdr = NULL;
+	struct ieee80211_hdr *wlh = NULL;
+	struct ieee80211_vif *vif = adapter->vifs[adapter->sc_nvifs - 1];
 	u8 q_num, tid = 0;
 
 	if ((!skb) || (!skb->len)) {
@@ -331,41 +441,172 @@ void rsi_core_xmit(struct rsi_common *common, struct sk_buff *skb)
 			__func__);
 		goto xmit_fail;
 	}
-	info = IEEE80211_SKB_CB(skb);
-	tx_params = (struct skb_info *)info->driver_data;
-	tmp_hdr = (struct ieee80211_hdr *)&skb->data[0];
-
+#ifdef CONFIG_RSI_WOW
+	if (common->wow_flags & RSI_WOW_ENABLED) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Blocking Tx_packets when WOWLAN is enabled\n",
+			__func__);
+		goto xmit_fail;
+	}
+#endif
 	if (common->fsm_state != FSM_MAC_INIT_DONE) {
 		rsi_dbg(ERR_ZONE, "%s: FSM state not open\n", __func__);
 		goto xmit_fail;
 	}
 
-	if ((ieee80211_is_mgmt(tmp_hdr->frame_control)) ||
-	    (ieee80211_is_ctl(tmp_hdr->frame_control)) ||
-	    (ieee80211_is_qos_nullfunc(tmp_hdr->frame_control))) {
+	info = IEEE80211_SKB_CB(skb);
+	tx_params = (struct skb_info *)info->driver_data;
+	wlh = (struct ieee80211_hdr *)&skb->data[0];
+
+	if ((ieee80211_is_mgmt(wlh->frame_control)) ||
+	    (ieee80211_is_ctl(wlh->frame_control)) ||
+	    (ieee80211_is_qos_nullfunc(wlh->frame_control))) {
+
+		if ((ieee80211_is_assoc_req(wlh->frame_control)) ||
+	 	    (ieee80211_is_reassoc_req(wlh->frame_control))) {
+			struct ieee80211_bss_conf *bss = NULL;
+
+			bss = &adapter->vifs[0]->bss_conf;
+			common->eapol4_confirm = 0;
+			common->start_bgscan = 0;
+			rsi_send_sta_notify_frame(common, STA_OPMODE,
+						  STA_CONNECTED,
+						  bss->bssid, bss->qos,
+						  bss->aid, 0);
+		}
 		q_num = MGMT_SOFT_Q;
 		skb->priority = q_num;
+
+#ifdef CONFIG_RSI_WOW          
+		if ((ieee80211_is_deauth(wlh->frame_control)) &&
+		    (common->wow_flags & RSI_WOW_ENABLED)) {
+			rsi_dbg(ERR_ZONE,
+				"%s: Discarding Deauth when WOWLAN is enabled\n",
+				__func__);
+			goto xmit_fail; 
+		}
+#endif
+		rsi_dbg(INFO_ZONE, "Core: TX Dot11 Mgmt Pkt Type: %s\n",
+			dot11_pkt_type(wlh->frame_control));
+#ifndef CONFIG_HW_SCAN_OFFLOAD
+		if (ieee80211_is_probe_req(wlh->frame_control)) {
+			if ((is_broadcast_ether_addr(wlh->addr1)) &&
+			    (skb->data[MIN_802_11_HDR_LEN + 1] == 0) &&
+			    (skb->len < 120)) {
+				memcpy(common->bgscan_probe_req,
+				       skb->data, skb->len);
+				common->bgscan_probe_req_len = skb->len;
+			}
+		}
+#endif
+		if (rsi_prepare_mgmt_desc(common, skb)) {
+			rsi_dbg(ERR_ZONE, "Failed to prepeare desc\n");
+			goto xmit_fail;
+		}
 	} else {
-		if (ieee80211_is_data_qos(tmp_hdr->frame_control)) {
-			tid = (skb->data[24] & IEEE80211_QOS_TID);
+		struct rsi_sta *sta = NULL;
+
+		rsi_dbg(INFO_ZONE, "Core: TX Data Packet\n");
+		rsi_hex_dump(DATA_TX_ZONE, "TX Data Packet",
+			     skb->data, skb->len);
+
+		/* Drop the null packets if bgscan is enabled
+ 		 * as it is already handled in firmware */
+		if ((vif->type == NL80211_IFTYPE_STATION) && (common->bgscan_en)) {
+			if ((ieee80211_is_qos_nullfunc(wlh->frame_control) ||
+			    ieee80211_is_nullfunc(wlh->frame_control))) {
+				++common->tx_stats.total_tx_pkt_freed[skb->priority];
+				rsi_indicate_tx_status(adapter, skb, 0);
+				return;
+			}
+		}
+
+		if (ieee80211_is_data_qos(wlh->frame_control)) {
+			u8 *qos = ieee80211_get_qos_ctl(wlh);
+			
+			tid = *qos & IEEE80211_QOS_CTL_TID_MASK;
 			skb->priority = TID_TO_WME_AC(tid);
 		} else {
 			tid = IEEE80211_NONQOS_TID;
 			skb->priority = BE_Q;
 		}
+		if (((vif->type == NL80211_IFTYPE_AP) ||
+		     (vif->type == NL80211_IFTYPE_P2P_GO)) &&
+		    (!is_broadcast_ether_addr(wlh->addr1)) &&
+		    (!is_multicast_ether_addr(wlh->addr1))) {
+			sta = rsi_find_sta(common, wlh->addr1);
+			if (!sta)
+				goto xmit_fail;
+		}
+
 		q_num = skb->priority;
 		tx_params->tid = tid;
-		tx_params->sta_id = 0;
+
+		if (sta) {
+#if 0
+			seq = IEEE80211_SN_TO_SEQ(sta->seq_no[skb->priority]);
+
+			wlh->seq_ctrl = cpu_to_le16(seq);
+			sta->seq_no[skb->priority] =
+				ieee80211_sn_inc(sta->seq_no[skb->priority]);
+#endif
+			tx_params->sta_id = sta->sta_id;
+			
+			/* Start aggregation if not done for this tid */
+			if (!sta->start_tx_aggr[tid]) {
+				sta->start_tx_aggr[tid] = true;
+				ieee80211_start_tx_ba_session(sta->sta, tid, 0);
+			}
+		} else {
+#if 0
+			seq = IEEE80211_SN_TO_SEQ(common->bc_mc_seqno);
+			if ((vif->type == NL80211_IFTYPE_AP) ||
+			    (vif->type == NL80211_IFTYPE_P2P_GO)) {
+				seq = IEEE80211_SN_TO_SEQ(common->bc_mc_seqno);
+				wlh->seq_ctrl = cpu_to_le16(seq);
+				common->bc_mc_seqno =
+					ieee80211_sn_inc(common->bc_mc_seqno);
+			}
+#endif
+			tx_params->sta_id = 0;
+		}
+
+		if (skb->protocol == cpu_to_be16(ETH_P_PAE)) {
+			q_num = MGMT_SOFT_Q;
+			skb->priority = q_num;
+		}
+		if (rsi_prepare_data_desc(common, skb)) {
+			rsi_dbg(ERR_ZONE, "Failed to prepare data desc\n");
+			goto xmit_fail;
+		}
 	}
 
-	if ((q_num != MGMT_SOFT_Q) &&
-	    ((skb_queue_len(&common->tx_queue[q_num]) + 1) >=
-	     DATA_QUEUE_WATER_MARK)) {
-		rsi_dbg(ERR_ZONE, "%s: sw queue full\n", __func__);
-		if (!ieee80211_queue_stopped(adapter->hw, WME_AC(q_num)))
-			ieee80211_stop_queue(adapter->hw, WME_AC(q_num));
-		rsi_set_event(&common->tx_thread.event);
-		goto xmit_fail;
+	if (q_num != MGMT_SOFT_Q)  {
+		u16 water_mark = DATA_QUEUE_WATER_MARK;
+
+		switch (q_num) {
+		case BK_Q:
+			water_mark = BK_DATA_QUEUE_WATER_MARK;
+			break;
+		case BE_Q:
+			water_mark = BE_DATA_QUEUE_WATER_MARK;
+			break;
+		case VI_Q:
+			water_mark = VI_DATA_QUEUE_WATER_MARK;
+			break;
+		case VO_Q:
+			water_mark = VO_DATA_QUEUE_WATER_MARK;
+			break;
+		}
+		if ((skb_queue_len(&common->tx_queue[q_num]) + 1) >= 
+	   	    water_mark) {
+			rsi_dbg(ERR_ZONE, "%s: queue %d is full\n",
+				__func__, q_num);
+			if (!ieee80211_queue_stopped(adapter->hw, WME_AC(q_num)))
+				ieee80211_stop_queue(adapter->hw, WME_AC(q_num));
+			rsi_set_event(&common->tx_thread.event);
+			goto xmit_fail;
+		}
 	}
 
 	rsi_core_queue_pkt(common, skb);
@@ -376,6 +617,7 @@ void rsi_core_xmit(struct rsi_common *common, struct sk_buff *skb)
 
 xmit_fail:
 	rsi_dbg(ERR_ZONE, "%s: Failed to queue packet\n", __func__);
+
 	/* Dropping pkt here */
 	ieee80211_free_txskb(common->priv->hw, skb);
 }
diff --git a/drivers/net/wireless/rsi/rsi_91x_debugfs.c b/drivers/net/wireless/rsi/rsi_91x_debugfs.c
index 828a042..8642c13 100644
--- a/drivers/net/wireless/rsi/rsi_91x_debugfs.c
+++ b/drivers/net/wireless/rsi/rsi_91x_debugfs.c
@@ -1,21 +1,41 @@
 /**
- * Copyright (c) 2014 Redpine Signals Inc.
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
  *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
  *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
+ *
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
+ *
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include "rsi_debugfs.h"
 #include "rsi_sdio.h"
+#include "rsi_mgmt.h"
+#ifdef CONFIG_RSI_11K
+#include "rsi_rrm.h"
+#endif
+
+extern int g_bgscan_enable;
 
 /**
  * rsi_sdio_stats_read() - This function returns the sdio status of the driver.
@@ -59,7 +79,7 @@ static int rsi_sdio_stats_read(struct seq_file *seq, void *data)
 }
 
 /**
- * rsi_sdio_stats_open() - This funtion calls single open function of seq_file
+ * rsi_sdio_stats_open() - This function calls single open function of seq_file
  *			   to open file and read contents from it.
  * @inode: Pointer to the inode structure.
  * @file: Pointer to the file structure.
@@ -83,24 +103,17 @@ static int rsi_version_read(struct seq_file *seq, void *data)
 {
 	struct rsi_common *common = seq->private;
 
-	common->driver_ver.major = 0;
-	common->driver_ver.minor = 1;
-	common->driver_ver.release_num = 0;
-	common->driver_ver.patch_num = 0;
-	seq_printf(seq, "Driver : %x.%d.%d.%d\nLMAC   : %d.%d.%d.%d\n",
-		   common->driver_ver.major,
-		   common->driver_ver.minor,
-		   common->driver_ver.release_num,
-		   common->driver_ver.patch_num,
-		   common->fw_ver.major,
-		   common->fw_ver.minor,
-		   common->fw_ver.release_num,
-		   common->fw_ver.patch_num);
+	seq_printf(seq, "Driver : %s\nLMAC   : %d.%d.%d.%d\n",
+		   common->driver_ver,
+		   common->lmac_ver.major,
+		   common->lmac_ver.minor,
+		   common->lmac_ver.release_num,
+		   common->lmac_ver.patch_num);
 	return 0;
 }
 
 /**
- * rsi_version_open() - This funtion calls single open function of seq_file to
+ * rsi_version_open() - This function calls single open function of seq_file to
  *			open file and read contents from it.
  * @inode: Pointer to the inode structure.
  * @file: Pointer to the file structure.
@@ -108,7 +121,7 @@ static int rsi_version_read(struct seq_file *seq, void *data)
  * Return: Pointer to the opened file status: 0 on success, ENOMEM on failure.
  */
 static int rsi_version_open(struct inode *inode,
-				 struct file *file)
+			    struct file *file)
 {
 	return single_open(file, rsi_version_read, inode->i_private);
 }
@@ -180,7 +193,7 @@ static int rsi_stats_read(struct seq_file *seq, void *data)
 }
 
 /**
- * rsi_stats_open() - This funtion calls single open function of seq_file to
+ * rsi_stats_open() - This function calls single open function of seq_file to
  *		      open file and read contents from it.
  * @inode: Pointer to the inode structure.
  * @file: Pointer to the file structure.
@@ -194,7 +207,8 @@ static int rsi_stats_open(struct inode *inode,
 }
 
 /**
- * rsi_debug_zone_read() - This function display the currently enabled debug zones.
+ * rsi_debug_zone_read() - This function display the currently
+ *			enabled debug zones.
  * @seq: Pointer to the sequence file structure.
  * @data: Pointer to the data.
  *
@@ -209,7 +223,7 @@ static int rsi_debug_zone_read(struct seq_file *seq, void *data)
 }
 
 /**
- * rsi_debug_read() - This funtion calls single open function of seq_file to
+ * rsi_debug_read() - This function calls single open function of seq_file to
  *		      open file and read contents from it.
  * @inode: Pointer to the inode structure.
  * @file: Pointer to the file structure.
@@ -252,6 +266,217 @@ static ssize_t rsi_debug_zone_write(struct file *filp,
 	return len;
 }
 
+/**
+ * rsi_bgscan_int_read() - This function display the default bgscan param
+ *			   values.
+ * @seq: Pointer to the sequence file structure.
+ * @data: Pointer to the data.
+ *
+ * Return: 0 on success, -1 on failure.
+ */
+static int rsi_bgscan_int_read(struct seq_file *file, void *data)
+{
+	struct rsi_common *common = file->private;
+	struct bgscan_config_params *params = NULL;
+	int cnt;
+
+	if (!common) {
+		rsi_dbg(ERR_ZONE, "No Interface\n");
+		return -ENODEV;
+	}
+	if (common->iface_down) {
+		rsi_dbg(ERR_ZONE, "Interface Down\n");
+		return -ENODEV;
+	}
+	params = &common->bgscan_info;
+
+	seq_printf(file, "%d %d %d %d %d %d %d %d\n",
+		   common->bgscan_en,
+		   params->bgscan_threshold,
+		   params->roam_threshold,
+		   params->bgscan_periodicity,
+		   params->active_scan_duration,
+		   params->passive_scan_duration,
+		   params->two_probe,
+		   params->num_bg_channels);
+
+	for (cnt = 0; cnt < params->num_bg_channels; cnt++) {
+		if (params->channels2scan[cnt] & (BIT(15)))
+			seq_printf(file, "%d[DFS] ",
+				   (params->channels2scan[cnt] & 0x7FFF));
+		else
+			seq_printf(file, "%d ", params->channels2scan[cnt]);
+	}
+	seq_printf(file, "\n");
+
+	return 0;
+}
+
+static int rsi_bgscan_read(struct inode *inode, struct file *file)
+{
+	return single_open(file, rsi_bgscan_int_read, inode->i_private);
+}
+
+/**
+ * rsi_bgscan_write() - This function gets the bgscan params from user
+ *			    and configures to device.
+ * @file: Pointer to the file structure.
+ * @user_buff: user buffer.
+ * @count: Length of the data written in buffer.
+ * @ppos: offset.
+ *
+ * Return: Number of bytes read.
+ */
+static ssize_t rsi_bgscan_write(struct file *file,
+			        const char __user *user_buff,
+				size_t count,
+				loff_t *ppos)
+
+{
+	struct rsi_common *common = file->f_inode->i_private;
+	struct rsi_hw *adapter = NULL;
+	struct ieee80211_bss_conf *bss = NULL;
+	char bgscan_buf[200];
+	int bgscan_vals[64] = { 0 };
+	int total_bytes, cnt = 0;
+	int bytes_read = 0, t_bytes;
+	int ret;
+
+	if (!common) {
+		rsi_dbg(ERR_ZONE, "No Interface\n");
+		return -ENODEV;
+	}
+	if (common->iface_down) {
+		rsi_dbg(ERR_ZONE, "Interface Down\n");
+		return -ENODEV;
+	}
+	adapter = common->priv;
+	bss = &adapter->vifs[adapter->sc_nvifs - 1]->bss_conf;
+
+	total_bytes = simple_write_to_buffer(bgscan_buf,
+					     sizeof(bgscan_buf) - 1,
+					     ppos, user_buff, count);
+	if (total_bytes < 1)
+		return -EINVAL;
+
+	/* make sure that buf is null terminated */
+	bgscan_buf[sizeof(bgscan_buf) - 1] = '\0';
+
+	ret = sscanf(bgscan_buf, "%d%n",
+		     (int *)&g_bgscan_enable, &t_bytes);
+	if (ret <= 0)
+		return -EINVAL;
+
+	if (!g_bgscan_enable) {
+		/* return here if bgscan is already disabled */
+		if (!common->bgscan_en) {
+#ifdef PLATFORM_X86
+			rsi_dbg(ERR_ZONE, "bgscan already disabled\n");
+#endif
+			return total_bytes;
+		}
+
+		mutex_lock(&common->mutex);
+		if (bss->assoc && !rsi_send_bgscan_params(common, 0)) {
+#ifdef PLATFORM_X86
+			rsi_dbg(ERR_ZONE, "*** bgscan disabled ***\n");
+#endif
+			common->bgscan_en = 0;
+		}
+		mutex_unlock(&common->mutex);
+
+		return total_bytes;
+	} else if (common->bgscan_en) {
+#ifdef PLATFORM_X86
+		rsi_dbg(ERR_ZONE, "bgscan already enabled\n");
+#endif
+		return total_bytes;
+	}
+
+	/* Return if bgscan is already in progress */
+	if (common->bgscan_en)
+		return total_bytes;
+
+	bytes_read += t_bytes;
+	while (1) {
+		ret = sscanf(bgscan_buf + bytes_read, "%d%n",
+			     &bgscan_vals[cnt++],
+			     &t_bytes);
+		if (ret <= 0)
+			break;
+		bytes_read += t_bytes;
+		
+		if ((bgscan_vals[6] > 0) && (cnt > (6 + bgscan_vals[6])))
+			break;
+	}
+	common->bgscan_info.bgscan_threshold = bgscan_vals[0];
+	common->bgscan_info.roam_threshold = bgscan_vals[1];
+	common->bgscan_info.bgscan_periodicity = bgscan_vals[2];
+	common->bgscan_info.active_scan_duration = bgscan_vals[3];
+	common->bgscan_info.passive_scan_duration = bgscan_vals[4];
+	common->bgscan_info.two_probe = bgscan_vals[5];
+	common->bgscan_info.num_user_channels = bgscan_vals[6];
+	memset(&common->bgscan_info.user_channels, 0,
+	       (MAX_BGSCAN_CHANNELS * 2));
+	common->bgscan_info.num_user_channels = 
+		((bgscan_vals[6] > MAX_BGSCAN_CHANNELS) ?
+		 MAX_BGSCAN_CHANNELS : bgscan_vals[6]); 
+	
+	for (cnt = 0; cnt < common->bgscan_info.num_user_channels; cnt++)
+		common->bgscan_info.user_channels[cnt] = bgscan_vals[7 + cnt];
+
+#ifdef PLATFORM_X86
+	rsi_dbg(INFO_ZONE,
+		"bgscan_count = %d, roam_count = %d, periodicity = %d\n",
+		common->bgscan_info.bgscan_threshold,
+		common->bgscan_info.roam_threshold,
+		common->bgscan_info.bgscan_periodicity);
+	rsi_dbg(INFO_ZONE,
+		"active_scan_dur = %d, passive_scan_dur = %d, two_probe = %d\n",
+		common->bgscan_info.active_scan_duration,
+		common->bgscan_info.passive_scan_duration,
+		common->bgscan_info.two_probe);
+	rsi_dbg(INFO_ZONE, "Number of scan channels = %d\n",
+		common->bgscan_info.num_user_channels);
+	rsi_hex_dump(INFO_ZONE, "bgscan channels",
+		     (u8 *)common->bgscan_info.user_channels,
+		     common->bgscan_info.num_user_channels * 2);
+#endif
+
+	/* If connection is not done don't send bgscan params */
+	if (!bss->assoc) {
+#ifdef PLATFORM_X86
+		rsi_dbg(INFO_ZONE, "Station not connected; skip now\n");
+#endif
+		return total_bytes;
+	}
+
+	/* Send bgscan params to device */
+	mutex_lock(&common->mutex);
+	if (!rsi_send_bgscan_params(common, 1)) {
+		if (!rsi_send_bgscan_probe_req(common)) {
+#ifdef PLATFORM_X86
+			rsi_dbg(INFO_ZONE, "Background scan started ===>\n");
+#endif
+			common->bgscan_en = 1;
+		} else {
+#ifdef PLATFORM_X86
+			rsi_dbg(ERR_ZONE, "Failed sending bgscan probe req\n");
+#endif
+			common->bgscan_en = 0;
+			g_bgscan_enable = 0;
+		}
+	
+} else {
+#ifdef PLATFORM_X86
+		rsi_dbg(ERR_ZONE, "Failed sending bgscan params req\n");
+#endif
+	}
+	mutex_unlock(&common->mutex);
+
+	return total_bytes;
+}
+
 #define FOPS(fopen) { \
 	.owner = THIS_MODULE, \
 	.open = (fopen), \
@@ -267,10 +492,290 @@ static ssize_t rsi_debug_zone_write(struct file *filp,
 	.write = (fwrite), \
 }
 
+#if defined(CONFIG_RSI_11K) && defined(RSI_DEBUG_RRM)
+static ssize_t rsi_write_chload_meas_req(struct file *file,
+					 const char __user *user_buff,
+					 size_t count, loff_t *ppos)
+{
+	struct rsi_common *common = file->f_inode->i_private;
+	char in_buf[200];
+	int chan_load_vals[64] = { 0 };
+	int total_bytes, bytes_read = 0;
+	int ret, i;
+        struct rsi_hw *adapter = common->priv;
+	struct ieee80211_bss_conf *bss =
+		&adapter->vifs[adapter->sc_nvifs - 1]->bss_conf;
+
+	if (!bss->assoc) {
+		rsi_dbg(ERR_ZONE,
+			"unable to send channelload in non connected state\n");
+		return -EINVAL;
+	}
+
+	total_bytes = simple_write_to_buffer(in_buf,
+					     sizeof(in_buf) - 1,
+					     ppos, user_buff, count);
+	if (total_bytes < 1)
+		return -EINVAL;
+	in_buf[sizeof(in_buf) - 1] = '\0';
+	ret = sscanf(in_buf + bytes_read, "%x%x%x%x%x%x%d%d%d%d%d%d",
+		     &chan_load_vals[0], &chan_load_vals[1],
+		     &chan_load_vals[2], &chan_load_vals[3],
+		     &chan_load_vals[4], &chan_load_vals[5],
+		     &chan_load_vals[6], &chan_load_vals[7],
+		     &chan_load_vals[8], &chan_load_vals[9],
+		     &chan_load_vals[10], &chan_load_vals[11]);
+	rsi_hex_dump(INFO_ZONE, "Parsed values", (u8 *)chan_load_vals, 32);
+	for (i = 0; i < ETH_ALEN; i++)
+		common->rrm_chload_params.macid[i] = chan_load_vals[i];
+
+	common->rrm_chload_params.regulatory_class = chan_load_vals[6];
+	common->rrm_chload_params.channel_num = chan_load_vals[7];
+	common->rrm_chload_params.rand_interval = chan_load_vals[8];
+	common->rrm_chload_params.meas_duration = chan_load_vals[9];
+	common->rrm_chload_params.meas_req_mode = chan_load_vals[10];
+	common->rrm_chload_params.meas_type = chan_load_vals[11];
+
+	if (!rsi_rrm_send_channel_load_req(common))
+		rsi_dbg(ERR_ZONE, "Sent channel load measurement request\n");
+	else
+		rsi_dbg(ERR_ZONE,
+			"Failed sending channel load measurement req\n");
+
+	return total_bytes;
+}
+
+static ssize_t rsi_int_read_chload_params(struct seq_file *file, void *data)
+{
+	struct rsi_common *common = file->private;
+	struct rsi_chload_meas_req_params *params = &common->rrm_chload_params;
+
+	seq_printf(file, "0x%x 0x%x 0x%x 0x%x 0x%x 0x%x %d %d %d %d %d %d\n",
+		   params->macid[0], params->macid[1], params->macid[2],
+		   params->macid[3], params->macid[4], params->macid[5],
+		   params->regulatory_class, params->channel_num,
+		   params->rand_interval, params->meas_duration,
+		   params->meas_req_mode, params->meas_type);
+	seq_puts(file, "\n");
+
+	return 0;
+}
+
+static int rsi_read_chload_meas_req(struct inode *inode, struct file *file)
+{
+	return single_open(file, rsi_int_read_chload_params, inode->i_private);
+}
+
+static ssize_t rsi_write_frame_meas_req(struct file *file,
+					const char __user *user_buff,
+					size_t count, loff_t *ppos)
+{
+	struct rsi_common *common = file->f_inode->i_private;
+	char in_buf[200];
+	int frame_load_vals[64] = { 0 };
+	int total_bytes, bytes_read = 0;
+	int ret, i;
+        struct rsi_hw *adapter = common->priv;
+	struct ieee80211_bss_conf *bss =
+		&adapter->vifs[adapter->sc_nvifs - 1]->bss_conf;
+
+	if (!bss->assoc) {
+		rsi_dbg(ERR_ZONE,
+			"unable to send frame req in non connected state\n");
+		return -EINVAL;
+	}
+	total_bytes = simple_write_to_buffer(in_buf,
+					     sizeof(in_buf) - 1,
+					     ppos, user_buff, count);
+	if (total_bytes < 1)
+		return -EINVAL;
+	in_buf[sizeof(in_buf) - 1] = '\0';
+	ret = sscanf(in_buf + bytes_read, "%x%x%x%x%x%x%d%d%d%d%d%d%d\n"
+		     "%x%x%x%x%x%x",
+		     &frame_load_vals[0], &frame_load_vals[1],
+		     &frame_load_vals[2], &frame_load_vals[3],
+		     &frame_load_vals[4], &frame_load_vals[5],
+		     &frame_load_vals[6], &frame_load_vals[7],
+		     &frame_load_vals[8], &frame_load_vals[9],
+		     &frame_load_vals[10], &frame_load_vals[11],
+		     &frame_load_vals[12], &frame_load_vals[13],
+		     &frame_load_vals[14], &frame_load_vals[15],
+		     &frame_load_vals[16], &frame_load_vals[17],
+		     &frame_load_vals[18]);
+	rsi_hex_dump(INFO_ZONE, "Parsed values", (u8 *)frame_load_vals, 32);
+
+	for (i = 0; i < ETH_ALEN; i++)
+		common->rrm_frame_params.destid[i] = frame_load_vals[i];
+	common->rrm_frame_params.regulatory_class = frame_load_vals[6];
+	common->rrm_frame_params.channel_num = frame_load_vals[7];
+	common->rrm_frame_params.rand_interval = frame_load_vals[8];
+	common->rrm_frame_params.meas_duration = frame_load_vals[9];
+	common->rrm_frame_params.meas_req_mode = frame_load_vals[10];
+	common->rrm_frame_params.meas_type = frame_load_vals[11];
+	common->rrm_frame_params.frame_req_type = frame_load_vals[12];
+	for (i = 0; i < ETH_ALEN; i++)
+		common->rrm_frame_params.macid[i] = frame_load_vals[13 + i];
+
+	if (!rsi_rrm_send_frame_req(common))
+		rsi_dbg(ERR_ZONE, "Sent frame measurement request\n");
+	else
+		rsi_dbg(ERR_ZONE, "Failed sending frame measurement req\n");
+
+	return total_bytes;
+}
+
+static ssize_t rsi_int_read_frame_params(struct seq_file *file, void *data)
+{
+	struct rsi_common *common = file->private;
+	struct rsi_frame_meas_req_params *params = &common->rrm_frame_params;
+
+	seq_printf(file, "0x%x 0x%x 0x%x 0x%x 0x%x 0x%x %d %d %d %d %d %d %d\n"
+		   "0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\n",
+		   params->destid[0], params->destid[1], params->destid[2],
+		   params->destid[3], params->destid[4], params->destid[5],
+		   params->regulatory_class, params->channel_num,
+		   params->rand_interval, params->meas_duration,
+		   params->meas_req_mode, params->meas_type,
+		   params->frame_req_type, params->macid[0],
+		   params->macid[1], params->macid[2],
+		   params->macid[3], params->macid[4],
+		   params->macid[5]);
+	seq_puts(file, "\n");
+
+	return 0;
+}
+
+static int rsi_read_frame_meas_req(struct inode *inode, struct file *file)
+{
+	return single_open(file, rsi_int_read_frame_params, inode->i_private);
+}
+
+static ssize_t rsi_write_beacon_meas_req(struct file *file,
+					 const char __user *user_buff,
+					 size_t count, loff_t *ppos)
+{
+	struct rsi_common *common = file->f_inode->i_private;
+	char in_buf[200];
+	int beacon_load_vals[64] = { 0 };
+	int total_bytes, bytes_read = 0;
+	int ret;
+	char str[32];
+        struct rsi_hw *adapter = common->priv;
+	struct ieee80211_bss_conf *bss =
+		&adapter->vifs[adapter->sc_nvifs - 1]->bss_conf;
+
+	if (!bss->assoc) {
+		rsi_dbg(ERR_ZONE,
+			"unable to send beacon req in non connected state\n");
+		return -EINVAL;
+	}
+	total_bytes = simple_write_to_buffer(in_buf,
+					     sizeof(in_buf) - 1,
+					     ppos, user_buff, count);
+	if (total_bytes < 1)
+		return -EINVAL;
+	in_buf[sizeof(in_buf) - 1] = '\0';
+	ret = sscanf(in_buf + bytes_read, "%x%x%x%x%x%x%d%d%d%d%d%d%d\n"
+					  "%x%x%x%x%x%x%s",
+		     &beacon_load_vals[0], &beacon_load_vals[1],
+		     &beacon_load_vals[2], &beacon_load_vals[3],
+		     &beacon_load_vals[4], &beacon_load_vals[5],
+		     &beacon_load_vals[6], &beacon_load_vals[7],
+		     &beacon_load_vals[8], &beacon_load_vals[9],
+		     &beacon_load_vals[10], &beacon_load_vals[11],
+		     &beacon_load_vals[12], &beacon_load_vals[13],
+		     &beacon_load_vals[14], &beacon_load_vals[15],
+		     &beacon_load_vals[16], &beacon_load_vals[17],
+		     &beacon_load_vals[18], str);
+	rsi_hex_dump(INFO_ZONE, "Parsed values", (u8 *)beacon_load_vals, 32);
+
+	common->rrm_beacon_params.destid[0] = beacon_load_vals[0];
+	common->rrm_beacon_params.destid[1] = beacon_load_vals[1];
+	common->rrm_beacon_params.destid[2] = beacon_load_vals[2];
+	common->rrm_beacon_params.destid[3] = beacon_load_vals[3];
+	common->rrm_beacon_params.destid[4] = beacon_load_vals[4];
+	common->rrm_beacon_params.destid[5] = beacon_load_vals[5];
+	common->rrm_beacon_params.regulatory_class = beacon_load_vals[6];
+	common->rrm_beacon_params.channel_num = beacon_load_vals[7];
+	common->rrm_beacon_params.rand_interval = beacon_load_vals[8];
+	common->rrm_beacon_params.meas_duration = beacon_load_vals[9];
+	common->rrm_beacon_params.meas_req_mode = beacon_load_vals[10];
+	common->rrm_beacon_params.meas_type = beacon_load_vals[11];
+	common->rrm_beacon_params.meas_mode = beacon_load_vals[12];
+	common->rrm_beacon_params.bssid[0] = beacon_load_vals[13];
+	common->rrm_beacon_params.bssid[1] = beacon_load_vals[14];
+	common->rrm_beacon_params.bssid[2] = beacon_load_vals[15];
+	common->rrm_beacon_params.bssid[3] = beacon_load_vals[16];
+	common->rrm_beacon_params.bssid[4] = beacon_load_vals[17];
+	common->rrm_beacon_params.bssid[5] = beacon_load_vals[18];
+	memset(common->rrm_beacon_params.str, 0, 32);
+	memcpy(common->rrm_beacon_params.str, str, strlen(str));
+
+	rsi_dbg(INFO_ZONE, "regulatory class %d\n",
+		common->rrm_beacon_params.regulatory_class);
+	rsi_dbg(INFO_ZONE, "channel num %d\n",
+		common->rrm_beacon_params.channel_num);
+	rsi_dbg(INFO_ZONE, "rand_interval %d\n",
+		common->rrm_beacon_params.rand_interval);
+	rsi_dbg(INFO_ZONE, "meas_duration %d\n",
+		common->rrm_beacon_params.meas_duration);
+	rsi_dbg(INFO_ZONE, "meas_req_mode %d\n",
+		common->rrm_beacon_params.meas_req_mode);
+	rsi_dbg(INFO_ZONE, "meas_type %d\n",
+		common->rrm_beacon_params.meas_type);
+	rsi_dbg(INFO_ZONE, "meas_mode %d\n",
+		common->rrm_beacon_params.meas_mode);
+	rsi_dbg(INFO_ZONE, "ssid %s\n",
+		common->rrm_beacon_params.str);
+
+	if (!rsi_rrm_send_beacon_req(common))
+		rsi_dbg(ERR_ZONE, "Sent Beacon measurement request\n");
+	else
+		rsi_dbg(ERR_ZONE, "Failed sending beacon measurement req\n");
+
+	return total_bytes;
+}
+
+static ssize_t rsi_int_read_beacon_params(struct seq_file *file, void *data)
+{
+	struct rsi_common *common = file->private;
+	struct rsi_beacon_meas_req_params *params = &common->rrm_beacon_params;
+
+	seq_printf(file, "0x%x 0x%x 0x%x 0x%x 0x%x 0x%x %d %d %d %d %d %d %d "
+			 "0x%x 0x%x 0x%x 0x%x 0x%x 0x%x %s\n",
+		   params->destid[0], params->destid[1], params->destid[2],
+		   params->destid[3], params->destid[4], params->destid[5],
+		   params->regulatory_class, params->channel_num,
+		   params->rand_interval, params->meas_duration,
+		   params->meas_req_mode, params->meas_type,
+		   params->meas_mode, params->bssid[0],
+		   params->bssid[1], params->bssid[2],
+		   params->bssid[3], params->bssid[4],
+		   params->bssid[5], params->str);
+	seq_puts(file, "\n");
+
+	return 0;
+}
+
+static int rsi_read_beacon_meas_req(struct inode *inode, struct file *file)
+{
+	return single_open(file, rsi_int_read_beacon_params, inode->i_private);
+}
+#endif
+
 static const struct rsi_dbg_files dev_debugfs_files[] = {
 	{"version", 0644, FOPS(rsi_version_open),},
 	{"stats", 0644, FOPS(rsi_stats_open),},
 	{"debug_zone", 0666, FOPS_RW(rsi_debug_read, rsi_debug_zone_write),},
+	{"bgscan", 0666, FOPS_RW(rsi_bgscan_read, rsi_bgscan_write),},
+#if defined(CONFIG_RSI_11K) && defined(RSI_DEBUG_RRM)
+	{"rrm_chan_load_req", 0666, FOPS_RW(rsi_read_chload_meas_req,
+					    rsi_write_chload_meas_req),},
+	{"rrm_frame_req", 0666, FOPS_RW(rsi_read_frame_meas_req,
+					rsi_write_frame_meas_req),},
+	{"rrm_beacon_req", 0666, FOPS_RW(rsi_read_beacon_meas_req,
+					 rsi_write_beacon_meas_req),},
+#endif
 	{"sdio_stats", 0644, FOPS(rsi_sdio_stats_open),},
 };
 
diff --git a/drivers/net/wireless/rsi/rsi_91x_hal.c b/drivers/net/wireless/rsi/rsi_91x_hal.c
new file mode 100644
index 0000000..c2fd925
--- /dev/null
+++ b/drivers/net/wireless/rsi/rsi_91x_hal.c
@@ -0,0 +1,1583 @@
+/**
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
+ *
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
+ *
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/firmware.h>
+#include <linux/version.h>
+#include <linux/jiffies.h>
+#include <net/bluetooth/bluetooth.h>
+#include "rsi_mgmt.h"
+#include "rsi_hal.h"
+#include "rsi_sdio.h"
+#include "rsi_common.h"
+#if defined(CONFIG_RSI_COEX) || defined(CONFIG_RSI_BT_ALONE)
+#include "rsi_hci.h"
+#endif
+#ifdef CONFIG_RSI_COEX
+#include "rsi_coex.h"
+#endif
+
+atomic_t drv_instances[5];
+
+/* FLASH Firmware */
+static struct ta_metadata metadata_flash_content[] = {
+	{"flash_content", 0x00010000},
+	{"RS9113_WLAN_QSPI.rps", 0x00010000},
+	{"RS9113_WLAN_BT_DUAL_MODE.rps", 0x00010000},
+	{"RS9113_WLAN_ZIGBEE.rps", 0x00010000},
+	{"RS9113_AP_BT_DUAL_MODE.rps", 0x00010000},
+	{"RS9113_WLAN_QSPI.rps", 0x00010000},
+	{"RS9113_ZIGBEE_COORDINATOR.rps", 0x00010000},
+	{"RS9113_ZIGBEE_ROUTER.rps", 0x00010000}
+
+};
+
+static struct ta_metadata metadata[] = {{"pmemdata_dummy", 0x00000000},
+	{"pmemdata", 0x00000000},
+	{"pmemdata_wlan_bt_classic", 0x00000000},
+	{"pmemdata_wlan_zigb", 0x00000000},
+	{"pmemdata_wlan_bt_classic", 0x00000000}
+};
+
+/**
+ * rsi_send_pkt() - This function sends the received packet from
+ *			 driver to device.
+ * @common: Pointer to the driver private structure.
+ * @skb: Pointer to the socket buffer structure.
+ *
+ * Return: status: 0 on success, -1 on failure.
+ */
+int rsi_send_pkt(struct rsi_common *common, struct sk_buff *skb)
+{
+	struct rsi_hw *adapter = common->priv;
+	int status = -EINVAL;
+
+//#ifdef CONFIG_RSI_COEX
+	//down(&coex_cb->tx_bus_lock);
+	down(&common->tx_bus_lock);
+//#endif
+	status = adapter->host_intf_ops->write_pkt(common->priv,
+						   skb->data, skb->len);
+//#ifdef CONFIG_RSI_COEX
+	up(&common->tx_bus_lock);
+//#endif
+	return status;
+}
+
+/**
+ * rsi_prepare_data_desc() - This function prepares the device specific descriptor
+ *			     for the given data packet
+ *
+ * @common: Pointer to the driver private structure.
+ * @skb: Pointer to the socket buffer structure.
+ *
+ * Return: status: 0 on success, negative error code on failure.
+ */
+int rsi_prepare_data_desc(struct rsi_common *common, struct sk_buff *skb)
+{
+	struct rsi_hw *adapter = common->priv;
+	struct ieee80211_vif *vif = NULL;
+	struct ieee80211_hdr *wh = NULL;
+	struct ieee80211_tx_info *info;
+	struct skb_info *tx_params;
+	int status = -EINVAL;
+	u8 ieee80211_hdr_size = MIN_802_11_HDR_LEN;
+	u8 dword_align_bytes = 0;
+	u8 header_size = 0;
+	__le16 *frame_desc;
+	struct xtended_desc *xtend_desc;
+	u16 seq_num = 0;
+	u8 vap_id = 0;
+
+	info = IEEE80211_SKB_CB(skb);
+	tx_params = (struct skb_info *)info->driver_data;
+
+	header_size = FRAME_DESC_SZ + sizeof(struct xtended_desc);
+	if (header_size > skb_headroom(skb)) {
+		rsi_dbg(ERR_ZONE, "%s: Not enough headroom\n", __func__);
+		status = -ENOSPC;
+		goto err;
+	}
+	skb_push(skb, header_size);
+	dword_align_bytes = ((unsigned long)skb->data & 0x3f);
+	if (header_size > skb_headroom(skb)) {
+		rsi_dbg(ERR_ZONE, "%s: Not enough headroom\n", __func__);
+		status = -ENOSPC;
+		goto err;
+	}
+	skb_push(skb, dword_align_bytes);
+	header_size += dword_align_bytes;
+
+	tx_params->internal_hdr_size = header_size;
+	frame_desc = (__le16 *)&skb->data[0];
+	xtend_desc = (struct xtended_desc *)&skb->data[FRAME_DESC_SZ];
+	memset((u8 *)frame_desc, 0, header_size);
+
+	wh = (struct ieee80211_hdr *)&skb->data[header_size];
+	seq_num = le16_to_cpu(IEEE80211_SEQ_TO_SN(wh->seq_ctrl));
+	vif = rsi_get_vif(adapter, wh->addr2);
+	vap_id = ((struct vif_priv *)vif->drv_priv)->vap_id;
+
+	frame_desc[2] = cpu_to_le16(header_size - FRAME_DESC_SZ);
+	if (ieee80211_is_data_qos(wh->frame_control)) {
+		ieee80211_hdr_size += 2;
+		frame_desc[6] |= cpu_to_le16(BIT(12));
+	}
+
+	if ((vif->type == NL80211_IFTYPE_STATION) &&
+	    (adapter->ps_state == PS_ENABLED))
+		wh->frame_control |= BIT(12);
+
+	if ((!(info->flags & IEEE80211_TX_INTFL_DONT_ENCRYPT)) &&
+	    (common->secinfo.security_enable)) {
+		if (rsi_is_cipher_wep(common))
+			ieee80211_hdr_size += 4;
+		else
+			ieee80211_hdr_size += 8;
+		frame_desc[6] |= cpu_to_le16(BIT(15));
+	}
+
+	frame_desc[0] = cpu_to_le16((skb->len - FRAME_DESC_SZ) |
+				    (RSI_WIFI_DATA_Q << 12));
+	frame_desc[2] |= cpu_to_le16(ieee80211_hdr_size << 8);
+
+	if (common->min_rate != 0xffff) {
+		/* Send fixed rate */
+		frame_desc[3] = cpu_to_le16(RATE_INFO_ENABLE);
+		frame_desc[4] = cpu_to_le16(common->min_rate);
+
+		if (conf_is_ht40(&common->priv->hw->conf))
+			frame_desc[5] = cpu_to_le16(FULL40M_ENABLE);
+
+		if ((common->vif_info[0].sgi) && (common->min_rate & 0x100)) {
+			/* Only MCS rates */
+			frame_desc[4] |= cpu_to_le16(ENABLE_SHORTGI_RATE);
+		}
+	}
+
+	if (skb->protocol == cpu_to_be16(ETH_P_PAE)) {
+		rsi_dbg(INFO_ZONE, "*** Tx EAPOL ***\n");
+		
+		frame_desc[3] = cpu_to_le16(RATE_INFO_ENABLE);
+		if (common->band == NL80211_BAND_5GHZ)
+			frame_desc[4] = cpu_to_le16(RSI_RATE_6);
+		else
+			frame_desc[4] = cpu_to_le16(RSI_RATE_1);
+		frame_desc[6] |= cpu_to_le16(BIT(13));
+		frame_desc[1] |= cpu_to_le16(BIT(12));
+		if (vif->type == NL80211_IFTYPE_STATION) {
+		if (common->eapol4_confirm) {
+			/* Eapol Rekeying , Change the priority to Voice _Q
+			 * XXX: Check for AP*/ 
+			skb->priority = VO_Q;
+		} else {
+			frame_desc[0] = cpu_to_le16((skb->len - FRAME_DESC_SZ) |
+						    (RSI_WIFI_MGMT_Q << 12));
+		}
+			if (((skb->len - header_size) == 133) ||
+			    ((skb->len - header_size) == 131)) {
+				rsi_dbg(INFO_ZONE, "*** Tx EAPOL 4*****\n");
+				frame_desc[1] |=
+					cpu_to_le16(RSI_DESC_REQUIRE_CFM_TO_HOST);
+				xtend_desc->confirm_frame_type = EAPOL4_CONFIRM;
+			}
+		}
+#define EAPOL_RETRY_CNT 15
+		xtend_desc->retry_cnt = EAPOL_RETRY_CNT;
+	}
+
+	frame_desc[6] |= cpu_to_le16(seq_num);
+	frame_desc[7] = cpu_to_le16(((tx_params->tid & 0xf) << 4) |
+				    (skb->priority & 0xf) |
+				    (tx_params->sta_id << 8));
+
+	if ((is_broadcast_ether_addr(wh->addr1)) ||
+	    (is_multicast_ether_addr(wh->addr1))) {
+		frame_desc[3] = cpu_to_le16(RATE_INFO_ENABLE);
+		frame_desc[3] |= cpu_to_le16(RSI_BROADCAST_PKT);
+		if ((vif->type == NL80211_IFTYPE_AP) ||
+		    (vif->type == NL80211_IFTYPE_P2P_GO)) {
+			if (common->band == NL80211_BAND_5GHZ)
+				frame_desc[4] = cpu_to_le16(RSI_RATE_6);
+			else
+				frame_desc[4] = cpu_to_le16(RSI_RATE_1);
+		}
+		frame_desc[7] = cpu_to_le16(((tx_params->tid & 0xf) << 4) |
+					    (skb->priority & 0xf) |
+					    (vap_id << 8));
+	}
+
+	if (((vif->type == NL80211_IFTYPE_AP) ||
+	     (vif->type == NL80211_IFTYPE_P2P_GO)) &&
+	    (ieee80211_has_moredata(wh->frame_control)))
+		frame_desc[3] |= cpu_to_le16(MORE_DATA_PRESENT);
+
+	return 0;
+
+err:
+	++common->tx_stats.total_tx_pkt_freed[skb->priority];
+	rsi_indicate_tx_status(adapter, skb, status);
+	return status;
+}
+
+/**
+ * rsi_prepare_mgmt_desc() - This functions prepares the descriptor for
+ *			     the given management packet.
+ *
+ * @common: Pointer to the driver private structure.
+ * @skb: Pointer to the socket buffer structure.
+ *
+ * Return: status: 0 on success, -1 on failure.
+ */
+int rsi_prepare_mgmt_desc(struct rsi_common *common,struct sk_buff *skb)
+{
+	struct rsi_hw *adapter = common->priv;
+	struct ieee80211_hdr *wh = NULL;
+	struct ieee80211_tx_info *info;
+	struct ieee80211_conf *conf;// = &adapter->hw->conf;
+	struct ieee80211_vif *vif = NULL;
+	struct skb_info *tx_params;
+	int status = -EINVAL;
+	__le16 *desc = NULL;
+	struct xtended_desc *xtend_desc = NULL;
+	u8 header_size = 0;
+	u8 vap_id = 0;
+	u32 dword_align_bytes = 0;
+
+	if (!adapter->hw)
+		goto err;
+	conf = &adapter->hw->conf;
+	info = IEEE80211_SKB_CB(skb);
+	tx_params = (struct skb_info *)info->driver_data;
+
+	/* Update header size */
+	header_size = FRAME_DESC_SZ + sizeof(struct xtended_desc);
+	if (header_size > skb_headroom(skb)) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Failed to add extended descriptor\n",
+			__func__);
+		status = -ENOSPC;
+		goto err;
+	}
+	skb_push(skb, header_size);
+	dword_align_bytes = ((unsigned long)skb->data & 0x3f);
+	if (dword_align_bytes > skb_headroom(skb)) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Failed to add dword align\n", __func__);
+		status = -ENOSPC;
+		goto err;
+	}
+	skb_push(skb, dword_align_bytes);
+	header_size += dword_align_bytes;
+
+	tx_params->internal_hdr_size = header_size;
+	memset(&skb->data[0], 0, header_size);
+
+	wh = (struct ieee80211_hdr *)&skb->data[header_size];
+	vif = rsi_get_vif(adapter, wh->addr2);
+	vap_id = ((struct vif_priv *)vif->drv_priv)->vap_id;
+
+	desc = (__le16 *)skb->data;
+	xtend_desc = (struct xtended_desc *)&skb->data[FRAME_DESC_SZ];
+
+	if (skb->len > MAX_MGMT_PKT_SIZE) {
+		rsi_dbg(INFO_ZONE, "%s: Dropping mgmt pkt > 512\n", __func__);
+		goto err;
+	}
+
+	desc[0] = cpu_to_le16((skb->len - FRAME_DESC_SZ) |
+			      (RSI_WIFI_MGMT_Q << 12));
+	desc[1] = cpu_to_le16(TX_DOT11_MGMT);
+	desc[2] = cpu_to_le16(MIN_802_11_HDR_LEN << 8);
+	desc[2] |= cpu_to_le16(header_size - FRAME_DESC_SZ);
+#ifdef CONFIG_HW_SCAN_OFFLOAD
+	if (ieee80211_is_probe_req(wh->frame_control) && 
+		(common->scan_in_prog))
+	desc[3] = cpu_to_le16(INSERT_SEQ_IN_FW);
+#endif
+	desc[3] |= cpu_to_le16(RATE_INFO_ENABLE);
+	if (wh->addr1[0] & BIT(0))
+		desc[3] |= cpu_to_le16(RSI_BROADCAST_PKT);
+	desc[6] = cpu_to_le16(IEEE80211_SEQ_TO_SN(wh->seq_ctrl));
+
+	if (common->band == NL80211_BAND_2GHZ)
+		if (!common->p2p_enabled)
+			desc[4] = cpu_to_le16(RSI_RATE_1);
+		else
+			desc[4] = cpu_to_le16(RSI_RATE_6);
+	else
+		desc[4] = cpu_to_le16(RSI_RATE_6);
+
+	if (conf_is_ht40(conf)) {
+		desc[5] = cpu_to_le16(FULL40M_ENABLE);
+	}
+
+	if (ieee80211_is_probe_resp(wh->frame_control)) {
+		desc[1] |= cpu_to_le16(ADD_DELTA_TSF_VAP_ID |
+				       FETCH_RETRY_CNT_FRM_HST);
+#define PROBE_RESP_RETRY_CNT	3
+		xtend_desc->retry_cnt = PROBE_RESP_RETRY_CNT;
+	}
+
+	if (((vif->type == NL80211_IFTYPE_AP) ||
+	     (vif->type == NL80211_IFTYPE_P2P_GO)) &&
+	    (ieee80211_is_action(wh->frame_control))) {
+		struct rsi_sta *sta = rsi_find_sta(common, wh->addr1);
+
+		if (sta)
+			desc[7] |= cpu_to_le16(sta->sta_id << 8);
+		else
+			goto err;
+	} else
+		desc[7] |= cpu_to_le16(vap_id << 8); /* Station ID */
+	desc[4] |= cpu_to_le16(vap_id << 14);
+
+	return 0;
+
+err:
+	return status;
+}
+
+/**
+ * rsi_send_data_pkt() - This function sends the received data packet from
+ *			 driver to device.
+ * @common: Pointer to the driver private structure.
+ * @skb: Pointer to the socket buffer structure.
+ *
+ * Return: status: 0 on success, -1 on failure.
+ */
+int rsi_send_data_pkt(struct rsi_common *common, struct sk_buff *skb)
+{
+	struct rsi_hw *adapter = common->priv;
+	struct ieee80211_vif *vif = NULL;
+	struct ieee80211_hdr *wh = NULL;
+	struct ieee80211_tx_info *info;
+	struct skb_info *tx_params;
+	struct ieee80211_bss_conf *bss = NULL;
+	int status = -EINVAL;
+	u8 header_size = 0;
+
+	if (!skb)
+		return 0;
+	if (common->iface_down)
+		goto err;
+	info = IEEE80211_SKB_CB(skb);
+	if (!info->control.vif)
+		goto err;
+	bss = &info->control.vif->bss_conf;
+	tx_params = (struct skb_info *)info->driver_data;
+
+	header_size = tx_params->internal_hdr_size;
+	wh = (struct ieee80211_hdr *)&skb->data[header_size];
+	vif = rsi_get_vif(adapter, wh->addr2);
+
+	if (vif->type == NL80211_IFTYPE_STATION) {
+		if (!bss->assoc)
+			goto err;
+		if (!ether_addr_equal(wh->addr1, bss->bssid))
+			goto err;
+	}
+
+	rsi_dbg(INFO_ZONE, "hal: Sending data pkt");
+	rsi_hex_dump(DATA_TX_ZONE, "TX data pkt", skb->data, skb->len);
+
+	status = rsi_send_pkt(common, skb);
+	if (status)
+		rsi_dbg(ERR_ZONE, "%s: Failed to write data pkt\n", __func__);
+
+err:
+	++common->tx_stats.total_tx_pkt_freed[skb->priority];
+	rsi_indicate_tx_status(common->priv, skb, status);
+	return status;
+}
+
+/**
+ * rsi_send_mgmt_pkt() - This function prepares sends the given mgmt packet
+ *			 to device.
+ *
+ * @common: Pointer to the driver private structure.
+ * @skb: Pointer to the socket buffer structure.
+ *
+ * Return: status: 0 on success, -1 on failure.
+ */
+int rsi_send_mgmt_pkt(struct rsi_common *common, struct sk_buff *skb)
+{
+	struct rsi_hw *adapter = common->priv;
+	struct ieee80211_hdr *wh = NULL;
+	struct ieee80211_tx_info *info;
+	struct skb_info *tx_params;
+	u8 header_size = 0;
+	int status = -EINVAL;
+	struct ieee80211_bss_conf *bss = NULL;
+	__le16 *desc = NULL;
+	struct xtended_desc *xtend_desc = NULL;
+
+	if (!skb)
+		return 0;
+
+	info = IEEE80211_SKB_CB(skb);
+	tx_params = (struct skb_info *)info->driver_data;
+	header_size = tx_params->internal_hdr_size;
+
+	if (tx_params->flags & INTERNAL_MGMT_PKT) {
+		skb->data[1] |= BIT(7); /* Immediate Wakeup bit*/
+		rsi_hex_dump(MGMT_TX_ZONE,
+			     "Tx Command Packet",
+			     skb->data, skb->len);
+
+		status = rsi_send_pkt(common, skb);
+		if (status) {
+			rsi_dbg(ERR_ZONE,
+				"%s: Failed to write the packet\n",
+				__func__);
+		}
+		dev_kfree_skb(skb);
+		return status;
+	}
+
+	if (common->iface_down)
+		goto out;
+	if (!info->control.vif)
+		goto out;
+	bss = &info->control.vif->bss_conf;
+	wh = (struct ieee80211_hdr *)&skb->data[header_size];
+
+	desc = (__le16 *)skb->data;
+	xtend_desc = (struct xtended_desc *)&skb->data[FRAME_DESC_SZ];
+
+	/* Indicate to firmware to give cfm */
+	if (ieee80211_is_probe_req(wh->frame_control)) {
+		if (!bss->assoc) {
+			rsi_dbg(INFO_ZONE,
+				"%s: blocking mgmt queue\n", __func__);
+			desc[1] |= cpu_to_le16(RSI_DESC_REQUIRE_CFM_TO_HOST);
+			xtend_desc->confirm_frame_type = PROBEREQ_CONFIRM;
+			common->mgmt_q_block = true;
+			rsi_dbg(INFO_ZONE, "Mgmt queue blocked\n");
+		} else if (common->bgscan_en) {
+			if (common->mac80211_cur_channel !=
+			    rsi_get_connected_channel(adapter)) { 
+				/* Drop off channel probe request */
+				status = 0;
+				goto out;
+			} else if (wh->addr1[0] == 0xff) {
+				/* Drop broadcast probe in connected channel*/
+				status = 0;
+				goto out;
+			}
+		}
+	}
+	
+	rsi_dbg(MGMT_TX_ZONE,
+		"Sending Packet : %s =====>\n",
+		dot11_pkt_type(wh->frame_control));
+
+	rsi_hex_dump(MGMT_TX_ZONE, "Tx Mgmt Packet", skb->data, skb->len);
+	status = rsi_send_pkt(common, skb);
+
+	if (status) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Failed to write the packet\n",
+			__func__);
+	}
+
+out:
+	rsi_indicate_tx_status(common->priv, skb, status);
+	return status;
+}
+
+int rsi_send_bt_pkt(struct rsi_common *common, struct sk_buff *skb)
+{
+	int status = -EINVAL;
+	u8 header_size = 0;
+	__le16 *frame_desc;
+	u8 queueno = ((skb->data[1] >> 4) & 0xf);
+
+	if (queueno == RSI_BT_MGMT_Q) {
+		rsi_hex_dump(MGMT_TX_ZONE, "TX BT Mgmt Pkt",
+			     skb->data, skb->len);
+
+		status = rsi_send_pkt(common, skb);
+		if (status)
+			rsi_dbg(ERR_ZONE, "%s: Failed to write bt mgmt pkt\n",
+				__func__);
+		goto out;
+	}
+
+	header_size = FRAME_DESC_SZ;
+	if (header_size > skb_headroom(skb)) {
+		rsi_dbg(ERR_ZONE, "%s: Not enough headroom\n", __func__);
+		status = -ENOSPC;
+		goto out;
+	}
+	skb_push(skb, header_size);
+	frame_desc = (__le16 *)&skb->data[0];
+	memset((u8 *)frame_desc, 0, header_size);
+
+	frame_desc[0] = cpu_to_le16(skb->len - FRAME_DESC_SZ);
+	frame_desc[0] |= (cpu_to_le16(RSI_BT_DATA_Q) & 0x7) << 12;
+
+	frame_desc[7] = cpu_to_le16(bt_cb(skb)->pkt_type);
+
+	rsi_hex_dump(DATA_TX_ZONE, "TX BT pkt", skb->data, skb->len);
+	status = rsi_send_pkt(common, skb);
+	if (status)
+		rsi_dbg(ERR_ZONE, "%s: Failed to write bt pkt\n", __func__);
+
+out:
+	dev_kfree_skb(skb);
+	return status;
+}
+
+int rsi_send_zb_pkt(struct rsi_common *common, struct sk_buff *skb)
+{
+	int status;
+
+	if (!skb) {
+		rsi_dbg(ERR_ZONE, "%s: Null skb\n", __func__);
+		return -EINVAL;
+	}
+	skb->data[1] |= BIT(7);  /* Set immediate wake up */
+	
+	status = rsi_send_pkt(common, skb);
+	if (status)
+		rsi_dbg(ERR_ZONE, "%s: Failed to send ZigB packet\n", __func__);
+	dev_kfree_skb(skb);
+
+	return status;
+}
+
+int rsi_prepare_beacon(struct rsi_common *common, struct sk_buff *skb)
+{
+	struct rsi_hw *adapter = (struct rsi_hw *)common->priv;
+	struct rsi_mac_frame *bcn_frm = NULL;
+	struct ieee80211_hw *hw = common->priv->hw;
+	struct ieee80211_conf *conf = &hw->conf;
+	struct sk_buff *mac_bcn = NULL;
+	u8 vap_id = 0;
+	int status = 0;
+	u16 tim_offset = 0;
+
+	mac_bcn = ieee80211_beacon_get_tim(adapter->hw,
+					   adapter->vifs[adapter->sc_nvifs - 1],
+					   &tim_offset, NULL);
+	if (!mac_bcn) {
+		rsi_dbg(ERR_ZONE, "Failed to get beacon from mac80211\n");
+		return -EINVAL;
+	}
+
+	common->beacon_cnt++;
+	bcn_frm = (struct rsi_mac_frame *)skb->data;
+	bcn_frm->desc_word[0] = cpu_to_le16(mac_bcn->len |
+					    (RSI_WIFI_DATA_Q << 12));
+	bcn_frm->desc_word[1] = 0; // FIXME: Fill type later
+	bcn_frm->desc_word[2] = cpu_to_le16(MIN_802_11_HDR_LEN << 8);
+	bcn_frm->desc_word[3] = cpu_to_le16(MAC_BBP_INFO | NO_ACK_IND |
+					    BEACON_FRAME | INSERT_TSF |
+					    INSERT_SEQ_NO);
+	bcn_frm->desc_word[3] |= cpu_to_le16(RATE_INFO_ENABLE);
+	bcn_frm->desc_word[4] = cpu_to_le16(vap_id << 14);
+	bcn_frm->desc_word[7] = cpu_to_le16(BEACON_HW_Q);
+	
+	if (conf_is_ht40_plus(conf)) {
+		bcn_frm->desc_word[5] = cpu_to_le16(LOWER_20_ENABLE);
+		bcn_frm->desc_word[5] |= cpu_to_le16(LOWER_20_ENABLE >> 12);
+	} else if (conf_is_ht40_minus(conf)) {
+		bcn_frm->desc_word[5] = cpu_to_le16(UPPER_20_ENABLE);
+		bcn_frm->desc_word[5] |= cpu_to_le16(UPPER_20_ENABLE >> 12);
+	}
+
+	if (common->band == NL80211_BAND_2GHZ) {
+		if (common->p2p_enabled)
+			bcn_frm->desc_word[4] |= cpu_to_le16(RSI_RATE_6);
+		else
+			bcn_frm->desc_word[4] |= cpu_to_le16(RSI_RATE_1);
+	} else
+		bcn_frm->desc_word[4] |= cpu_to_le16(RSI_RATE_6);
+
+	if (mac_bcn->data[tim_offset + 2] == 0)
+		bcn_frm->desc_word[3] |= cpu_to_le16(DTIM_BEACON);
+
+	memcpy(&skb->data[FRAME_DESC_SZ], mac_bcn->data, mac_bcn->len);
+	skb_put(skb, mac_bcn->len + FRAME_DESC_SZ);
+
+	rsi_hex_dump(MGMT_TX_ZONE, "Beacon Frame", skb->data, skb->len);	
+
+	if (mac_bcn)
+		dev_kfree_skb(mac_bcn);
+
+	return status;
+}
+
+/**
+ * bl_cmd_timeout() - This function is called when BL command timed out
+ * @priv: Pointer to the hardware structure.
+ *
+ * Return: NONE.
+ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION (4, 15, 0)
+static void bl_cmd_timeout(unsigned long priv)
+{
+	struct rsi_hw *adapter = (struct rsi_hw *)priv;
+#else
+static void bl_cmd_timeout(struct timer_list *t)
+{
+	struct rsi_hw *adapter = from_timer(adapter, t, bl_cmd_timer);
+#endif
+	adapter->blcmd_timer_expired = 1;
+	del_timer(&adapter->bl_cmd_timer);
+}
+
+/**
+ * bl_start_cmd_timer() - This function starts the BL command timer
+ * @adapter: Pointer to the hardware structure.
+ * @timeout: Timeout of the command in milliseconds
+ *
+ * Return: 0 on success.
+ */
+static int bl_start_cmd_timer(struct rsi_hw *adapter, u32 timeout)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION (4, 15, 0)
+	init_timer(&adapter->bl_cmd_timer);
+	adapter->bl_cmd_timer.data = (unsigned long)adapter;
+	adapter->bl_cmd_timer.function = (void *)&bl_cmd_timeout;
+#else
+	timer_setup(&adapter->bl_cmd_timer, bl_cmd_timeout, 0);
+#endif
+	adapter->bl_cmd_timer.expires = (msecs_to_jiffies(timeout) + jiffies);
+
+	adapter->blcmd_timer_expired = 0;
+	add_timer(&adapter->bl_cmd_timer);
+
+	return 0;
+}
+
+/**
+ * bl_stop_cmd_timer() - This function stops the BL command timer
+ * @adapter: Pointer to the hardware structure.
+ *
+ * Return: 0 on success.
+ */
+static int bl_stop_cmd_timer(struct rsi_hw *adapter)
+{
+	adapter->blcmd_timer_expired = 0;
+	if (timer_pending(&adapter->bl_cmd_timer))
+		del_timer(&adapter->bl_cmd_timer);
+
+	return 0;
+}
+
+/**
+ * bl_write_cmd() - This function writes the BL command to device
+ * @adapter: Pointer to the hardware structure.
+ * @cmd: Command to write
+ * @exp_resp: Expected Response
+ * @cmd_resp: Received Response
+ *
+ * Return: 0 on success.
+ */
+static int bl_write_cmd(struct rsi_hw *adapter, u8 cmd, u8 exp_resp, u16 *cmd_resp)
+{
+	struct rsi_host_intf_ops *hif_ops = adapter->host_intf_ops;
+	u32 regin_val = 0, regout_val = 0;
+	u8 output = 0;
+	u32 regin_input = 0;
+
+	regin_input = (REGIN_INPUT | adapter->priv->coex_mode);
+
+	while (!adapter->blcmd_timer_expired) {
+		regin_val = 0;
+		if (hif_ops->master_reg_read(adapter,
+					     SWBL_REGIN,
+					     &regin_val,
+					     2) < 0) {
+			rsi_dbg(ERR_ZONE,
+				"%s: Command %0x REGIN reading failed..\n",
+				__func__, cmd);
+			goto fail;
+		}
+		mdelay(1);
+		if ((regin_val >> 12) != REGIN_VALID)
+			break;
+	}
+	if (adapter->blcmd_timer_expired) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Command %0x REGIN reading timed out..\n",
+			__func__, cmd);
+		goto fail;
+	}
+
+	rsi_dbg(INFO_ZONE,
+		"Issuing write to Regin val:%0x sending cmd:%0x\n",
+		regin_val, (cmd | regin_input << 8));
+	if ((hif_ops->master_reg_write(adapter,
+				       SWBL_REGIN,
+				       (cmd | regin_input << 8),
+				       2)) < 0) {
+		goto fail;
+	}
+	mdelay(1);
+
+	if (cmd == LOAD_HOSTED_FW || cmd == JUMP_TO_ZERO_PC) {
+		/* JUMP_TO_ZERO_PC doesn't expect
+		 * any response. So return from here
+		 */
+		return 0;
+	}
+
+	while (!adapter->blcmd_timer_expired) {
+		regout_val = 0;
+		if (hif_ops->master_reg_read(adapter,
+					     SWBL_REGOUT,
+					     &regout_val,
+					     2) < 0) {
+			rsi_dbg(ERR_ZONE,
+				"%s: Command %0x REGOUT reading failed..\n",
+				__func__, cmd);
+			goto fail;
+		}
+		mdelay(1);
+		if ((regout_val >> 8) == REGOUT_VALID)
+			break;
+	}
+	if (adapter->blcmd_timer_expired) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Command %0x REGOUT reading timed out..\n",
+			__func__, cmd);
+		goto fail;
+	}
+
+	*cmd_resp = ((u16 *)&regout_val)[0] & 0xffff;
+
+	output = ((u8 *)&regout_val)[0] & 0xff;
+
+	if ((hif_ops->master_reg_write(adapter,
+				       SWBL_REGOUT,
+				       (cmd | REGOUT_INVALID << 8),
+				       2)) < 0) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Command %0x REGOUT writing failed..\n",
+			__func__, cmd);
+		goto fail;
+	}
+	mdelay(1);
+
+	if (output == exp_resp) {
+		rsi_dbg(INFO_ZONE,
+			"%s: received expected response 0x%0X for cmd 0x%0X\n",
+			__func__, output, cmd);
+	} else {
+		rsi_dbg(INFO_ZONE,
+			"%s: received response 0x%0X for cmd 0x%0X\n",
+			__func__, output, cmd);
+		goto fail;
+	}
+	return 0;
+
+fail:
+	return -EINVAL;
+}
+
+/**
+ * bl_cmd() - This function initiates the BL command
+ * @adapter: Pointer to the hardware structure.
+ * @cmd: Command to write
+ * @exp_resp: Expected Response
+ * @str: Command string
+ *
+ * Return: 0 on success, -1 on failure.
+ */
+static int bl_cmd(struct rsi_hw *adapter, u8 cmd, u8 exp_resp, char *str)
+{
+	u16 regout_val = 0;
+	u32 timeout = 0;
+
+	if ((cmd == EOF_REACHED) || (cmd == PING_VALID) || (cmd == PONG_VALID))
+		timeout = BL_BURN_TIMEOUT;
+	else
+		timeout = BL_CMD_TIMEOUT;
+
+	bl_start_cmd_timer(adapter, timeout);
+	if (bl_write_cmd(adapter, cmd, exp_resp, &regout_val) < 0) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Command %s (%0x) writing failed..\n",
+			__func__, str, cmd);
+		goto fail;
+	}
+	bl_stop_cmd_timer(adapter);
+	return 0;
+
+fail:
+	return -EINVAL;
+}
+
+/**
+ * bl_write_header() - This function writes the BL header
+ * @adapter: Pointer to the hardware structure.
+ * @flash_content: Flash content
+ * @content_size: Flash content size
+ *
+ * Return: 0 on success, -1 on failure.
+ */
+static int bl_write_header(struct rsi_hw *adapter,
+			   u8 *flash_content, u32 content_size)
+{
+	struct rsi_host_intf_ops *hif_ops = adapter->host_intf_ops;
+	struct bl_header *bl_hdr;
+	u32 write_addr, write_len;
+
+#define CHECK_SUM_OFFSET 20
+#define LEN_OFFSET 8
+#define ADDR_OFFSET 16
+
+	bl_hdr = kzalloc(sizeof(*bl_hdr), GFP_KERNEL);
+	if (!bl_hdr)
+		return -ENOMEM;
+
+	bl_hdr->flags = 0;
+	bl_hdr->image_no = cpu_to_le32(adapter->priv->coex_mode);
+	bl_hdr->check_sum = cpu_to_le32(
+				*(u32 *)&flash_content[CHECK_SUM_OFFSET]);
+	bl_hdr->flash_start_address = cpu_to_le32(
+					*(u32 *)&flash_content[ADDR_OFFSET]);
+	bl_hdr->flash_len = cpu_to_le32(*(u32 *)&flash_content[LEN_OFFSET]);
+	write_len = sizeof(struct bl_header);
+
+	if (adapter->rsi_host_intf == RSI_HOST_INTF_USB) {
+		write_addr = PING_BUFFER_ADDRESS;
+		if ((hif_ops->write_reg_multiple(adapter,
+						 write_addr,
+						 (u8 *)bl_hdr,
+						 write_len)) < 0) {
+			rsi_dbg(ERR_ZONE,
+				"%s: Failed to load Version/CRC structure\n",
+				__func__);
+			goto fail;
+		}
+	} else {
+		write_addr = PING_BUFFER_ADDRESS >> 16;
+		if ((hif_ops->master_access_msword(adapter, write_addr)) < 0) {
+			rsi_dbg(ERR_ZONE,
+				"%s: Unable to set ms word to common reg\n",
+				__func__);
+			goto fail;
+		}
+		write_addr = SD_REQUEST_MASTER |
+			     (PING_BUFFER_ADDRESS & 0xFFFF);
+		if ((hif_ops->write_reg_multiple(adapter,
+						 write_addr,
+						 (u8 *)bl_hdr,
+						 write_len)) < 0) {
+			rsi_dbg(ERR_ZONE,
+				"%s: Failed to load Version/CRC structure\n",
+				__func__);
+			goto fail;
+		}
+	}
+	kfree(bl_hdr);
+	return 0;
+
+fail:
+	kfree(bl_hdr);
+	return -EINVAL;
+}
+
+/**
+ * read_flash_capacity() - This function reads the flash size from device
+ * @adapter: Pointer to the hardware structure.
+ *
+ * Return: flash capacity on success, 0 on failure.
+ */
+static u32 read_flash_capacity(struct rsi_hw *adapter)
+{
+	u32 flash_sz = 0;
+
+	if ((adapter->host_intf_ops->master_reg_read(adapter,
+						     FLASH_SIZE_ADDR,
+						     &flash_sz, 2)) < 0) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Flash size reading failed..\n",
+			__func__);
+		return 0;
+	}
+	rsi_dbg(INIT_ZONE, "Flash capacity: %d KiloBytes\n", flash_sz);
+
+	return (flash_sz * 1024); /* Return size in kbytes */
+}
+
+/**
+ * ping_pong_write() - This function writes the flash contents throgh ping
+ *			pong buffers
+ * @adapter: Pointer to the hardware structure.
+ * @cmd: command ping/pong write
+ * @addr: address to write
+ * @size: size
+ *
+ * Return: 0 on success, -1 on failure.
+ */
+static int ping_pong_write(struct rsi_hw *adapter, u8 cmd, u8 *addr, u32 size)
+{
+	struct rsi_host_intf_ops *hif_ops = adapter->host_intf_ops;
+	u32 block_size = 0;
+	u32 cmd_addr;
+	u16 cmd_resp = 0, cmd_req = 0;
+	u8 *str;
+
+	if (adapter->rsi_host_intf == RSI_HOST_INTF_SDIO)
+		block_size = 256;
+	else
+		block_size = 252;
+
+	if (cmd == PING_WRITE) {
+		cmd_addr = PING_BUFFER_ADDRESS;
+		cmd_resp = PONG_AVAIL;
+		cmd_req = PING_VALID;
+		str = "PING_VALID";
+	} else {
+		cmd_addr = PONG_BUFFER_ADDRESS;
+		cmd_resp = PING_AVAIL;
+		cmd_req = PONG_VALID;
+		str = "PONG_VALID";
+	}
+
+	if (hif_ops->load_data_master_write(adapter,
+					    cmd_addr,
+					    size,
+					    block_size,
+					    addr)) {
+		rsi_dbg(ERR_ZONE, "%s: Unable to write blk at addr %0x\n",
+			__func__, *addr);
+		goto fail;
+	}
+	if (bl_cmd(adapter, cmd_req, cmd_resp, str) < 0) {
+		bl_stop_cmd_timer(adapter);
+		goto fail;
+	}
+	return 0;
+
+fail:
+	return -EINVAL;
+}
+
+/**
+ * auto_fw_upgrade() - This function loads the firmware to device
+ * @adapter: Pointer to the hardware structure.
+ * @flash_content: Firmware to load
+ * @content_size: Size of the firmware
+ *
+ * Return: 0 on success, -1 on failure.
+ */
+static int auto_fw_upgrade(struct rsi_hw *adapter,
+			   u8 *flash_content,
+			   u32 content_size)
+{
+	u8 cmd;
+	u8 *temp_flash_content;
+	u32 temp_content_size;
+	u32 num_flash;
+	u32 index;
+	u32 flash_start_address;
+
+	temp_flash_content = flash_content;
+
+	if (content_size > MAX_FLASH_FILE_SIZE) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Flash Content size is more than 400K %u\n",
+			__func__, MAX_FLASH_FILE_SIZE);
+		goto fail;
+	}
+
+	flash_start_address = cpu_to_le32(
+				*(u32 *)&flash_content[FLASHING_START_ADDRESS]);
+	rsi_dbg(INFO_ZONE, "flash start address: %08x\n", flash_start_address);
+
+	if (flash_start_address < FW_IMAGE_MIN_ADDRESS) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Fw image Flash Start Address is less than 64K\n",
+			__func__);
+		goto fail;
+	}
+
+	if (flash_start_address % FLASH_SECTOR_SIZE) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Flash Start Address is not multiple of 4K\n",
+			__func__);
+		goto fail;
+	}
+	if (adapter->device_model != RSI_DEV_9116) {
+		if ((flash_start_address + content_size) >
+					 adapter->flash_capacity) {
+			rsi_dbg(ERR_ZONE,
+				"%s: Flash Content will cross max flash size\n",
+				__func__);
+			goto fail;
+		}
+	}
+
+	temp_content_size  = content_size;
+	num_flash = content_size / FLASH_WRITE_CHUNK_SIZE;
+
+	rsi_dbg(INFO_ZONE, "content_size: %d\n", content_size);
+	rsi_dbg(INFO_ZONE, "num_flash: %d\n", num_flash);
+
+	for (index = 0; index <= num_flash; index++) {
+		rsi_dbg(INFO_ZONE, "flash index: %d\n", index);
+		if (index != num_flash) {
+			content_size = FLASH_WRITE_CHUNK_SIZE;
+			rsi_dbg(INFO_ZONE,
+				"QSPI content_size:%d\n",
+				content_size);
+		} else {
+			content_size =
+				temp_content_size % FLASH_WRITE_CHUNK_SIZE;
+			rsi_dbg(INFO_ZONE,
+				"Writing last sector content_size:%d\n",
+				content_size);
+			if (!content_size) {
+				rsi_dbg(INFO_ZONE, "INSTRUCTION SIZE ZERO\n");
+				break;
+			}
+		}
+
+		if (index % 2)
+			cmd = PING_WRITE;
+		else
+			cmd = PONG_WRITE;
+
+		if (ping_pong_write(adapter,
+				    cmd,
+				    flash_content,
+				    content_size)) {
+			rsi_dbg(ERR_ZONE,
+				"%s: Unable to load %d block\n",
+				__func__, index);
+			goto fail;
+		}
+
+		rsi_dbg(INFO_ZONE,
+			"%s: Successfully loaded %d instructions\n",
+			__func__, index);
+		flash_content += content_size;
+	}
+
+	if (bl_cmd(adapter, EOF_REACHED, FW_LOADING_SUCCESSFUL,
+		   "EOF_REACHED") < 0) {
+		bl_stop_cmd_timer(adapter);
+		goto fail;
+	}
+	rsi_dbg(INFO_ZONE, "FW loading is done and FW is running..\n");
+	return 0;
+
+fail:
+	return -EINVAL;
+}
+
+static int rsi_load_9116_firmware(struct rsi_hw *adapter)
+{
+	struct rsi_common *common = adapter->priv;
+	struct rsi_host_intf_ops *hif_ops = adapter->host_intf_ops;
+	int status = 0;
+	struct ta_metadata *metadata_p = NULL;
+	u8 *ta_firmware = NULL;
+	u8 *firmware_ptr;
+	u32 instructions_sz = 0;
+	const struct firmware *fw_entry = NULL;
+	int ii;
+	struct bootload_ds bootload_ds;
+	u32 base_address;
+	u32 block_size;
+
+	rsi_dbg(INIT_ZONE, "***** Load 9116 TA Instructions *****\n");
+
+	if ((hif_ops->master_reg_write(adapter, MEM_ACCESS_CTRL_FROM_HOST,
+				       RAM_384K_ACCESS_FROM_TA , 4)) < 0) {
+		rsi_dbg(ERR_ZONE, "%s: Unable to access full RAM memory\n",
+			__func__);
+		return -EIO;
+	}
+
+	metadata_p = &metadata[adapter->priv->coex_mode];
+
+	rsi_dbg(INIT_ZONE, "%s: loading file %s\n", __func__, metadata_p->name);
+
+	if ((request_firmware(&fw_entry, metadata_p->name,
+			      adapter->device)) < 0) {
+		rsi_dbg(ERR_ZONE, "%s: Failed to open file %s\n",
+			__func__, metadata_p->name);
+		return -EINVAL;
+	}
+	ta_firmware = kmemdup(fw_entry->data, fw_entry->size, GFP_KERNEL);
+	if (!ta_firmware) {
+		rsi_dbg(ERR_ZONE, "%s: Failed to copy firmware\n", __func__);
+		goto fail_free_fw;
+	}
+	firmware_ptr = ta_firmware;
+	instructions_sz = fw_entry->size;
+	rsi_dbg(INFO_ZONE, "FW Length = %d bytes\n", instructions_sz);
+
+	if (!strncmp(metadata_p->name, "pmemdata", strlen("pmemdata"))) {
+		common->lmac_ver.major =
+			((ta_firmware[LMAC_VER_OFFSET_RS9116]) & 0xFF);
+		common->lmac_ver.minor =
+			((ta_firmware[LMAC_VER_OFFSET_RS9116 + 1]) & 0xFF);
+		common->lmac_ver.release_num =
+			((ta_firmware[LMAC_VER_OFFSET_RS9116 + 2]) & 0xFF);
+		common->lmac_ver.patch_num =
+			((ta_firmware[LMAC_VER_OFFSET_RS9116 + 3]) & 0xFF);
+		common->lmac_ver.ver.info.fw_ver[0] =
+			((ta_firmware[LMAC_VER_OFFSET_RS9116 + 4]) & 0xFF);
+	}
+
+	if (instructions_sz % 4)
+		instructions_sz += (4 - (instructions_sz % 4));
+
+	rsi_dbg(INFO_ZONE, "instructions_sz : %d\n", instructions_sz);
+
+	base_address = metadata_p->address;
+
+	if (adapter->rsi_host_intf == RSI_HOST_INTF_SDIO)
+		block_size = 256;
+	else
+		block_size = 252;
+	if (*(u16 *)firmware_ptr == 0x5aa5) {
+	/* memcpy to boot descriptor from TA firmware len should be assign */
+		memcpy(&bootload_ds, (u8 *)firmware_ptr,
+		       sizeof(struct bootload_ds));
+		/* move ta firmware poiner to ta_fw+ len*/
+		firmware_ptr = firmware_ptr + bootload_ds.offset;
+
+		ii = 0;
+
+		do {
+			rsi_dbg(ERR_ZONE, "%s: Loading chunk %d\n",
+				__func__, ii);
+
+			rsi_dbg(ERR_ZONE, "length %d: destination %x\n",
+				(bootload_ds.bl_entry[ii].control &
+				RSI_BL_CTRL_LEN_MASK),
+				bootload_ds.bl_entry[ii].dst_addr);
+
+			rsi_dbg(ERR_ZONE, "FW start %x\n",
+				*(u32 *)firmware_ptr);
+			status = hif_ops->load_data_master_write(adapter,
+					bootload_ds.bl_entry[ii].dst_addr,
+					(bootload_ds.bl_entry[ii].control &
+					RSI_BL_CTRL_LEN_MASK),
+					block_size, firmware_ptr);
+
+			firmware_ptr += (bootload_ds.bl_entry[ii].control &
+					 RSI_BL_CTRL_LEN_MASK);
+			if (bootload_ds.bl_entry[ii].control &
+			    RSI_BL_CTRL_LAST_ENTRY)
+				break;
+			ii++;
+		} while (1);
+	} else {
+		status = hif_ops->load_data_master_write(adapter,
+							 base_address,
+							 instructions_sz,
+							 block_size,
+							 ta_firmware);
+	}
+	if (status) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Unable to load %s blk\n",
+			__func__, metadata_p->name);
+		goto fail_free_fw;
+	}
+
+	rsi_dbg(INIT_ZONE, "%s: Successfully loaded %s instructions\n",
+		__func__, metadata_p->name);
+
+	if (adapter->rsi_host_intf == RSI_HOST_INTF_SDIO) {
+		if (adapter->host_intf_ops->ta_reset_ops(adapter))
+			rsi_dbg(ERR_ZONE, "Unable to put ta in reset\n");
+	}
+
+fail_free_fw:
+	kfree(ta_firmware);
+	release_firmware(fw_entry);
+	return status;
+}
+
+/**
+ * rsi_load_firmware () - This function loads the TA firmware for 9113
+ *				device.
+ * @adapter: Pointer to the rsi hw.
+ *
+ * Return: status: 0 on success, -1 on failure.
+ */
+static int rsi_load_firmware(struct rsi_hw *adapter)
+{
+	struct rsi_common *common = adapter->priv;
+	struct rsi_host_intf_ops *hif_ops = adapter->host_intf_ops;
+	const struct firmware *fw_entry = NULL;
+	u32 regout_val = 0;
+	u16 tmp_regout_val = 0;
+	u8 *flash_content = NULL;
+	u32 content_size = 0;
+	struct ta_metadata *metadata_p;
+	int status;
+
+	bl_start_cmd_timer(adapter, BL_CMD_TIMEOUT);
+
+	while (!adapter->blcmd_timer_expired) {
+		if ((hif_ops->master_reg_read(adapter,
+					      SWBL_REGOUT,
+					      &regout_val,
+					      2)) < 0) {
+			rsi_dbg(ERR_ZONE,
+				"%s: REGOUT read failed\n", __func__);
+			goto fail;
+		}
+		mdelay(1);
+		if ((regout_val >> 8) == REGOUT_VALID)
+			break;
+	}
+	if (adapter->blcmd_timer_expired) {
+		rsi_dbg(ERR_ZONE, "%s: REGOUT read timedout\n", __func__);
+		rsi_dbg(ERR_ZONE,
+			"%s: Soft boot loader not present\n", __func__);
+		goto fail;
+	}
+	bl_stop_cmd_timer(adapter);
+
+	rsi_dbg(INFO_ZONE, "Received Board Version Number: %x\n",
+		(regout_val & 0xff));
+
+	if ((hif_ops->master_reg_write(adapter,
+				       SWBL_REGOUT,
+				       (REGOUT_INVALID | REGOUT_INVALID << 8),
+				       2)) < 0) {
+		rsi_dbg(ERR_ZONE, "%s: REGOUT writing failed..\n", __func__);
+		goto fail;
+	}
+	mdelay(1);
+	if (adapter->device_model == RSI_DEV_9116) {
+		if (adapter->rsi_host_intf == RSI_HOST_INTF_USB) {
+			if (bl_cmd(adapter, POLLING_MODE,
+				   CMD_PASS, "POLLING_MODE") < 0) {
+				goto fail;
+			}
+		}
+		status = rsi_load_9116_firmware(adapter);
+		if (adapter->rsi_host_intf == RSI_HOST_INTF_USB) {
+			if (bl_cmd(adapter, JUMP_TO_ZERO_PC,
+				   CMD_PASS, "JUMP_TO_ZERO") < 0)
+				rsi_dbg(INFO_ZONE,
+					"Jump to zero command failed\n");
+			else
+				rsi_dbg(INFO_ZONE,
+					"Jump to zero command successful\n");
+		}
+		return status;
+	} else {
+		if ((bl_cmd(adapter, CONFIG_AUTO_READ_MODE, CMD_PASS,
+			    "AUTO_READ_CMD")) < 0)
+			goto fail;
+
+		adapter->flash_capacity = read_flash_capacity(adapter);
+		if (adapter->flash_capacity <= 0) {
+			rsi_dbg(ERR_ZONE,
+				"%s: Unable to read flash size from EEPROM\n",
+				__func__);
+			goto fail;
+		}
+	
+		metadata_p = &metadata_flash_content[adapter->priv->coex_mode];
+	
+		rsi_dbg(INIT_ZONE, "%s: Loading file %s\n", __func__, metadata_p->name);
+		adapter->fw_file_name = metadata_p->name;
+	
+		if ((request_firmware(&fw_entry, metadata_p->name,
+				      adapter->device)) < 0) {
+			rsi_dbg(ERR_ZONE, "%s: Failed to open file %s\n",
+				__func__, metadata_p->name);
+			goto fail;
+		}
+		flash_content = kmemdup(fw_entry->data, fw_entry->size, GFP_KERNEL);
+		if (!flash_content) {
+			rsi_dbg(ERR_ZONE, "%s: Failed to copy firmware\n", __func__);
+			goto fail;
+		}
+		content_size = fw_entry->size;
+		rsi_dbg(INFO_ZONE, "FW Length = %d bytes\n", content_size);
+	
+		/* Get the firmware version */
+		common->lmac_ver.ver.info.fw_ver[0] =
+			flash_content[LMAC_VER_OFFSET] & 0xFF;
+		common->lmac_ver.ver.info.fw_ver[1] =
+			flash_content[LMAC_VER_OFFSET+1] & 0xFF;
+		common->lmac_ver.major = flash_content[LMAC_VER_OFFSET + 2] & 0xFF;
+		common->lmac_ver.release_num =
+			flash_content[LMAC_VER_OFFSET + 3] & 0xFF;
+		common->lmac_ver.minor = flash_content[LMAC_VER_OFFSET + 4] & 0xFF;
+		common->lmac_ver.patch_num = 0;
+		rsi_print_version(common);
+	
+		if (bl_write_header(adapter, flash_content, content_size)) {
+			rsi_dbg(ERR_ZONE,
+				"%s: RPS Image header loading failed\n",
+				__func__);
+			goto fail;
+		}
+	
+		bl_start_cmd_timer(adapter, BL_CMD_TIMEOUT);
+		if (bl_write_cmd(adapter, CHECK_CRC, CMD_PASS, &tmp_regout_val) < 0) {
+			bl_stop_cmd_timer(adapter);
+			rsi_dbg(INFO_ZONE,
+				"%s: CHECK_CRC Command writing failed..\n",
+				__func__);
+			if ((tmp_regout_val & 0xff) == CMD_FAIL) {
+				rsi_dbg(ERR_ZONE,
+					"device firmware doesnt match %s, proceed to upgrade ...\n", 
+					 metadata_p->name);
+				goto fw_upgrade;
+			}
+		}
+		bl_stop_cmd_timer(adapter);
+	
+		if (bl_cmd(adapter, POLLING_MODE, CMD_PASS, "POLLING_MODE") < 0)
+			goto fail;
+	
+load_image_cmd:
+		if ((bl_cmd(adapter,
+			    LOAD_HOSTED_FW,
+			    LOADING_INITIATED,
+			    "LOAD_HOSTED_FW")) < 0)
+			goto fail;
+		rsi_dbg(INFO_ZONE, "Load Image command passed..\n");
+		goto success;
+	
+fw_upgrade:
+		if (bl_cmd(adapter, BURN_HOSTED_FW, SEND_RPS_FILE, "FW_UPGRADE") < 0)
+			goto fail;
+	
+		rsi_dbg(INFO_ZONE, "Burn Command Pass.. Upgrading the firmware\n");
+	
+		if (auto_fw_upgrade(adapter, flash_content, content_size) == 0) {
+			rsi_dbg(ERR_ZONE, "Firmware upgradation Done\n");
+			goto load_image_cmd;
+		}
+		rsi_dbg(ERR_ZONE, "Firmware upgrade failed\n");
+	
+		if (bl_cmd(adapter, CONFIG_AUTO_READ_MODE,
+			   CMD_PASS, "AUTO_READ_MODE") < 0)
+			goto fail;
+	}
+
+success:
+	rsi_dbg(ERR_ZONE, "***** Firmware Loading successful *****\n");
+	kfree(flash_content);
+	release_firmware(fw_entry);
+	return 0;
+
+fail:
+	rsi_dbg(ERR_ZONE, "##### Firmware loading failed #####\n");
+	kfree(flash_content);
+	release_firmware(fw_entry);
+	return -EINVAL;
+}
+
+int rsi_validate_oper_mode(u16 oper_mode)
+{
+	switch (oper_mode) {
+	case 1:
+#if defined(CONFIG_RSI_BT_ALONE)
+		rsi_dbg(ERR_ZONE, "Operating mode %d not supported with"
+				  "build flag 'CONFIG_RSI_BT_ALONE enabled'\n",
+				  oper_mode);
+		return -EINVAL;
+#else
+		return 0;
+#endif
+	case 4:
+	case 8:
+#ifndef CONFIG_RSI_BT_ALONE
+		rsi_dbg(ERR_ZONE, "Operating mode %d not supported without"
+				  "build flag 'CONFIG_RSI_BT_ALONE enabled'\n",
+				  oper_mode);
+		return -EINVAL;
+#else
+		return 0;
+#endif
+	case 5:
+	case 6:
+	case 9:
+	case 12:
+	case 13:
+	case 14:
+#ifndef CONFIG_RSI_COEX
+		rsi_dbg(ERR_ZONE, "Operating mode %d not supported without"
+			" build flag 'CONFIG_RSI_COEX enabled'\n",
+			oper_mode);
+		return -EINVAL;
+#else
+		return 0;
+#endif
+	case 16:
+	case 17:
+	case 32:
+	case 48:
+#if !defined(CONFIG_RSI_COEX) || !defined(CONFIG_RSI_ZIGB)
+		rsi_dbg(ERR_ZONE, "Operating mode %d not supported without"
+			" build flags 'CONFIG_RSI_COEX and"
+			" CONFIG_RSI_ZIGB are enabled'\n",
+			oper_mode);
+		return -EINVAL;
+#else
+		return 0;
+#endif
+	case 0xFF:
+		return 0xFF;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+EXPORT_SYMBOL_GPL(rsi_validate_oper_mode);
+
+int rsi_opermode_instances(struct rsi_hw *adapter)
+{
+	struct rsi_common *common = adapter->priv;
+	u16 *opermodes = common->dev_oper_mode;
+	int err, i, count = opermodes[0];
+
+	if (count > MAX_INSTANCES) {
+		rsi_dbg(ERR_ZONE, "%s: unable to handle %d instances\n",
+			   __func__, count);
+		return -EINVAL;
+	}
+
+	for (i = 1; i <= MAX_INSTANCES; i++) {
+		if (DRV_INSTANCE(i))
+			continue;
+		err = rsi_validate_oper_mode(opermodes[i]);
+		if (err < 0)
+			return -EINVAL;
+		/*
+		 * User ain't provide opermode for
+		 * later instances, using the first.
+		 */
+		if (err == 0xFF)
+			opermodes[i] = opermodes[1];
+
+		DRV_INSTANCE_SET(i, opermodes[i]);
+		adapter->priv->oper_mode = opermodes[i];
+		adapter->drv_instance_index = i;
+		rsi_dbg(INFO_ZONE, "%s: drv instance index %d opermode %d\n",
+				__func__, i, opermodes[i]);
+		return 0;
+	}
+	return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(rsi_opermode_instances);
+
+/**
+ * rsi_hal_device_init() - This function initializes the Device
+ * @adapter: Pointer to the hardware structure
+ *
+ * Return: status: 0 on success, -1 on failure.
+ */
+int rsi_hal_device_init(struct rsi_hw *adapter)
+{
+	struct rsi_common *common = adapter->priv;
+#if defined (CONFIG_RSI_COEX) || defined(CONFIG_RSI_BT_ALONE) || defined(CONFIG_RSI_ZIGB)
+	switch (common->oper_mode) {
+	case DEV_OPMODE_STA_BT_DUAL:
+	case DEV_OPMODE_STA_BT:
+	case DEV_OPMODE_STA_BT_LE:
+	case DEV_OPMODE_BT_ALONE:
+	case DEV_OPMODE_BT_LE_ALONE:
+	case DEV_OPMODE_BT_DUAL:
+		common->coex_mode = 2;
+		break;
+	case DEV_OPMODE_AP_BT_DUAL:
+	case DEV_OPMODE_AP_BT:
+		common->coex_mode = 4;
+		break;
+	case DEV_OPMODE_WIFI_ALONE:
+		common->coex_mode = 1;
+		break;
+	case DEV_OPMODE_ZB_ALONE:
+	case DEV_OPMODE_STA_ZB:
+		common->coex_mode = 3;
+		common->zb_fsm_state = ZB_DEVICE_NOT_READY;
+		break;
+	case DEV_OPMODE_ZB_COORDINATOR:
+		common->coex_mode = 6;
+		common->oper_mode = 16;
+		common->zb_fsm_state = ZB_DEVICE_NOT_READY;
+		break;
+	case DEV_OPMODE_ZB_ROUTER:
+		common->coex_mode = 7;
+		common->oper_mode = 16;
+		common->zb_fsm_state = ZB_DEVICE_NOT_READY;
+		break;
+	default:
+#ifndef CONFIG_CARACALLA_BOARD
+		common->oper_mode = 1;
+		common->coex_mode = 1;
+#else
+		common->oper_mode = DEV_OPMODE_STA_BT_DUAL;
+		common->coex_mode = 2;
+#endif
+	}
+#else
+	common->oper_mode = 1;
+	common->coex_mode = 1;
+#endif
+
+	rsi_dbg(ERR_ZONE, "%s: oper_mode = %d, coex_mode = %d\n",
+		__func__, common->oper_mode, common->coex_mode);
+
+	switch (adapter->device_model) {
+	case RSI_DEV_9113:
+	case RSI_DEV_9116:
+		if (rsi_load_firmware(adapter)) {
+			rsi_dbg(ERR_ZONE,
+				"%s: Failed to load TA instructions\n",
+				__func__);
+			return -EINVAL;
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+	adapter->common_hal_fsm = COMMAN_HAL_WAIT_FOR_CARD_READY;
+	common->fsm_state = FSM_CARD_NOT_READY;
+
+#if defined(CONFIG_RSI_BT_ALONE) || defined(CONFIG_RSI_COEX)
+	adapter->priv->bt_fsm_state = BT_DEVICE_NOT_READY;
+#endif
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(rsi_hal_device_init);
+
diff --git a/drivers/net/wireless/rsi/rsi_91x_hci.c b/drivers/net/wireless/rsi/rsi_91x_hci.c
new file mode 100644
index 0000000..15b5a79
--- /dev/null
+++ b/drivers/net/wireless/rsi/rsi_91x_hci.c
@@ -0,0 +1,448 @@
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
+ *
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
+ *
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "rsi_hci.h"
+#include "rsi_mgmt.h"
+#include "rsi_coex.h"
+#include "rsi_hal.h"
+
+/**
+ * rsi_hci_open() - This function is called when HCI device is
+ * 						opened 
+ * 
+ * @hdev - pointer to HCI device
+ * @return - 0 on success
+ */
+static int rsi_hci_open(struct hci_dev *hdev)
+{
+	rsi_dbg(ERR_ZONE, "RSI HCI DEVICE \"%s\" open\n", hdev->name);
+
+	if (test_and_set_bit(HCI_RUNNING, &hdev->flags))
+		rsi_dbg(ERR_ZONE, "%s: device `%s' already running\n", 
+				__func__, hdev->name);
+
+	return 0;
+}
+
+/**
+ * rsi_hci_close() - This function is called when HCI device is
+ * 						closed 
+ * 
+ * @hdev - pointer to HCI device
+ * @return - 0 on success
+ */
+static int rsi_hci_close(struct hci_dev *hdev)
+{
+	rsi_dbg(ERR_ZONE, "RSI HCI DEVICE \"%s\" closed\n", hdev->name);
+
+	if (!test_and_clear_bit(HCI_RUNNING, &hdev->flags))
+		rsi_dbg(ERR_ZONE, "%s: device `%s' not running\n",
+				 __func__, hdev->name);
+
+	return 0;
+}
+
+/**
+ * rsi_hci_flush() - This function is called when HCI device is
+ * 						flushed 
+ * 
+ * @hdev - pointer to HCI device
+ * @return - 0 on success; negative error code on failure
+ */
+static int rsi_hci_flush(struct hci_dev *hdev)
+{
+	struct rsi_hci_adapter *h_adapter;
+
+	if (!(h_adapter = hci_get_drvdata(hdev)))
+		return -EFAULT;
+
+	rsi_dbg(ERR_ZONE, "RSI `%s' flush\n", hdev->name);
+
+	return 0;
+}
+
+/**
+ * rsi_hci_send_pkt() - This function is used send the packet received 
+ * 						from HCI layer to co-ex module
+ *
+ * @hdev - pointer to HCI device
+ * @skb - Received packet from HCI
+ * @return - 0 on success; negative error code on failure
+ *  
+ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION (3, 13, 0)
+static int rsi_hci_send_pkt(struct sk_buff *skb)
+#else
+static int rsi_hci_send_pkt(struct hci_dev *hdev, struct sk_buff *skb)
+#endif
+{
+	struct rsi_hci_adapter *h_adapter;
+	struct sk_buff *new_skb = NULL;
+#if LINUX_VERSION_CODE < KERNEL_VERSION (3, 13, 0)
+	struct hci_dev *hdev = (struct hci_dev *)skb->dev;
+#endif
+	int status = 0;
+
+	if (skb->len <= 0) {
+		rsi_dbg(ERR_ZONE, "Zero length packet\n");
+		//hdev->sta.err_tx++;
+		status = -EINVAL;
+		goto fail;
+	}
+
+	if (!(h_adapter = hci_get_drvdata(hdev))) {
+		//hdev->sta.err_tx++;
+		status = -EFAULT;
+		goto fail;
+	}
+
+#ifdef CONFIG_RSI_WOW
+	/* Stop here when in suspend */
+	if (h_adapter->priv->wow_flags & RSI_WOW_ENABLED) {
+		rsi_dbg(INFO_ZONE, "In suspend: Dropping the pkt\n");
+		status = -ENETDOWN;
+		goto fail;
+	}
+#endif
+
+	if (h_adapter->priv->bt_fsm_state != BT_DEVICE_READY) {
+		rsi_dbg(ERR_ZONE, "BT Device not ready\n");
+		status = -ENODEV;
+		goto fail;
+	}
+
+	if (!test_bit(HCI_RUNNING, &hdev->flags)) {
+		status = -EBUSY;
+		goto fail;
+	}
+
+	switch (bt_cb(skb)->pkt_type) {
+		case HCI_COMMAND_PKT:
+			hdev->stat.cmd_tx++;
+			break;
+
+		case HCI_ACLDATA_PKT:
+			hdev->stat.acl_tx++;
+			break;
+
+		case HCI_SCODATA_PKT:
+			hdev->stat.sco_tx++;
+			break;
+
+		default:
+			dev_kfree_skb(skb);
+			status = -EILSEQ;
+			goto fail;
+	}
+
+	if (skb_headroom(skb) < REQUIRED_HEADROOM_FOR_BT_HAL) {
+               /* Re-allocate one more skb with sufficent headroom 
+		 * make copy of input-skb to new one */
+		u16 new_len = skb->len + REQUIRED_HEADROOM_FOR_BT_HAL;
+
+		new_skb = dev_alloc_skb(new_len);
+		if (!new_skb) {
+			rsi_dbg(ERR_ZONE, "%s: Failed to alloc skb\n",
+				__func__);
+			dev_kfree_skb(skb);
+			return -ENOMEM;
+		}
+		skb_reserve(new_skb, REQUIRED_HEADROOM_FOR_BT_HAL);
+                skb_put(new_skb, skb->len);
+		memcpy(new_skb->data, skb->data, skb->len);
+		bt_cb(new_skb)->pkt_type = bt_cb(skb)->pkt_type;
+                dev_kfree_skb(skb);
+                skb = new_skb;
+	}
+
+        rsi_hex_dump(DATA_RX_ZONE, "TX BT Pkt", skb->data, skb->len); 
+
+#ifdef CONFIG_RSI_COEX
+	rsi_coex_send_pkt(h_adapter->priv, skb, BT_Q);
+#else
+        rsi_send_bt_pkt(h_adapter->priv, skb);
+#endif
+	return 0;
+
+fail:
+	dev_kfree_skb(skb);
+	return status;
+}
+
+int rsi_send_rfmode_frame(struct rsi_common *common)
+{
+	struct sk_buff *skb;
+	struct rsi_bt_rfmode_frame *cmd_frame;
+	int status;
+
+	rsi_dbg(MGMT_TX_ZONE, "%s: Sending BT RF mode frame\n", __func__);
+
+	skb = dev_alloc_skb(sizeof(struct rsi_bt_rfmode_frame));
+	if (!skb)
+		return -ENOMEM;
+
+	memset(skb->data, 0, sizeof(struct rsi_bt_rfmode_frame));
+	cmd_frame = (struct rsi_bt_rfmode_frame *)skb->data;
+
+	/* Length is 0 */
+	cmd_frame->desc.q_no = RSI_BT_MGMT_Q;
+	cmd_frame->desc.pkt_type = RSI_BT_PKT_TYPE_RFMODE;
+	cmd_frame->bt_rf_tx_power_mode = 0;
+	cmd_frame->bt_rf_tx_power_mode = 0;
+
+	skb_put(skb, sizeof(struct rsi_bt_rfmode_frame));
+
+//	return rsi_coex_send_pkt(common, skb, RSI_BT_Q);
+	status = common->priv->host_intf_ops->write_pkt(common->priv,
+							skb->data,
+							skb->len);
+	dev_kfree_skb(skb);
+	return status;
+}
+EXPORT_SYMBOL_GPL(rsi_send_rfmode_frame);
+
+int rsi_deregister_bt(struct rsi_common *common)
+{
+	struct sk_buff *skb;
+	struct rsi_bt_cmd_frame *cmd_frame;
+	int status;
+
+	rsi_dbg(MGMT_TX_ZONE, "%s: Sending BT register frame\n", __func__);
+
+	skb = dev_alloc_skb(sizeof(struct rsi_bt_cmd_frame));
+	if (!skb)
+		return -ENOMEM;
+
+	memset(skb->data, 0, sizeof(struct rsi_bt_cmd_frame));
+	cmd_frame = (struct rsi_bt_cmd_frame *)skb->data;
+
+	/* Length is 0 */
+	cmd_frame->q_no = RSI_BT_MGMT_Q;
+	cmd_frame->pkt_type = RSI_BT_PKT_TYPE_DEREGISTR;
+
+	skb_put(skb, sizeof(struct rsi_bt_cmd_frame));
+
+	//return rsi_coex_send_pkt(common, skb, RSI_BT_Q);
+	status = common->priv->host_intf_ops->write_pkt(common->priv,
+							skb->data,
+							skb->len);
+	dev_kfree_skb(skb);
+	return status;
+}
+EXPORT_SYMBOL_GPL(rsi_deregister_bt);
+
+int rsi_hci_recv_pkt(struct rsi_common *common, u8 *pkt)
+{
+	struct rsi_hci_adapter *h_adapter =
+		(struct rsi_hci_adapter *)common->hci_adapter;
+	struct sk_buff *skb = NULL;
+	struct hci_dev *hdev = NULL;
+	int pkt_len = rsi_get_length(pkt, 0);
+	u8 queue_no = rsi_get_queueno(pkt, 0);
+
+	if ((common->bt_fsm_state == BT_DEVICE_NOT_READY) &&
+	    (pkt[14] == BT_CARD_READY_IND)) {
+		rsi_dbg(INIT_ZONE, "%s: ===> BT Card Ready Received <===\n",
+			__func__);
+
+		if (common->suspend_in_prog) {
+			rsi_dbg(INFO_ZONE,
+				"Suspend is in prog; Do not process\n");
+			return 0;
+		}
+
+		rsi_dbg(INFO_ZONE, "Attaching HCI module\n");
+
+		if (rsi_hci_attach(common)) {
+			rsi_dbg(ERR_ZONE, "Failed to attach HCI module\n");
+			return 0;
+		}
+
+		return 0;
+	}
+
+	if (common->bt_fsm_state != BT_DEVICE_READY) {
+		rsi_dbg(INFO_ZONE, "BT Device not ready\n");
+		return 0;
+	}
+	
+	if (queue_no == RSI_BT_MGMT_Q) {
+		u8 msg_type = pkt[14] & 0xFF;
+	
+		switch (msg_type) {
+		case RESULT_CONFIRM:
+			rsi_dbg(MGMT_RX_ZONE, "BT Result Confirm\n");
+			return 0;
+		case BT_BER:
+			rsi_dbg(MGMT_RX_ZONE, "BT Ber\n");
+			return 0;
+		case BT_CW:
+			rsi_dbg(MGMT_RX_ZONE, "BT CW\n");
+			return 0;
+		default:
+			break;
+		}
+	}
+
+	skb = dev_alloc_skb(pkt_len);
+	if (!skb) {
+		rsi_dbg(ERR_ZONE, "%s: Failed to alloc skb\n", __func__);
+		return -ENOMEM;
+	}
+        hdev = h_adapter->hdev;
+	memcpy(skb->data, pkt + FRAME_DESC_SZ, pkt_len);
+	skb_put(skb, pkt_len);
+	h_adapter->hdev->stat.byte_rx += skb->len;
+
+	skb->dev = (void *)hdev;
+	bt_cb(skb)->pkt_type = pkt[14];
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,13,0)
+	return hci_recv_frame(skb);
+#else
+	return hci_recv_frame(hdev, skb);
+#endif
+}
+EXPORT_SYMBOL_GPL(rsi_hci_recv_pkt);
+
+/**
+ * rsi_hci_attach () - This function initializes HCI interface
+ *				      
+ * @common: Pointer to the driver private structure.
+ *
+ * Return: 0 on success, negative error code on failure
+ */
+int rsi_hci_attach(struct rsi_common *common)
+{
+	struct rsi_hci_adapter *h_adapter = NULL;
+	struct hci_dev *hdev;
+	int status = 0;
+
+	/* Allocate HCI adapter */
+	/* TODO: Check GFP_ATOMIC */
+	h_adapter = kzalloc(sizeof (*h_adapter), GFP_KERNEL);
+	if (!h_adapter) {
+		rsi_dbg (ERR_ZONE, "Failed to alloc HCI adapter\n");
+		return -ENOMEM;
+	}
+	h_adapter->priv = common;
+	
+	/* Create HCI Interface */
+	hdev = hci_alloc_dev();
+	if (!hdev) {
+		rsi_dbg (ERR_ZONE, "Failed to alloc HCI device\n");
+		goto err;
+	}
+	h_adapter->hdev = hdev;
+
+	if (common->priv->rsi_host_intf == RSI_HOST_INTF_SDIO)
+		hdev->bus = HCI_SDIO;
+	else
+		hdev->bus = HCI_USB;
+
+	hci_set_drvdata(hdev, h_adapter);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION (4, 8, 0)
+	hdev->dev_type = HCI_PRIMARY;
+#else
+	hdev->dev_type = HCI_BREDR;
+#endif
+
+	hdev->open = rsi_hci_open;
+	hdev->close = rsi_hci_close;
+	hdev->flush = rsi_hci_flush;
+	hdev->send = rsi_hci_send_pkt;
+#if LINUX_VERSION_CODE <= KERNEL_VERSION (3, 3, 8)
+	hdev->destruct = rsi_hci_destruct;
+	hdev->owner = THIS_MODULE;
+#endif
+
+        /* Initialize TX queue */
+	skb_queue_head_init(&h_adapter->hci_tx_queue);
+	common->hci_adapter = (void *)h_adapter;
+	
+	status = hci_register_dev(hdev);
+	if (status < 0) {
+		rsi_dbg(ERR_ZONE,
+			"%s: HCI registration failed with errcode %d\n",
+			__func__, status);
+		goto err;
+	}
+	rsi_dbg(INIT_ZONE, "HCI Interface Created with name \'%s\'\n",
+		hdev->name);
+	common->bt_fsm_state = BT_DEVICE_READY;
+	rsi_dbg(ERR_ZONE, " HCI module init done...\n");
+
+	return 0;
+
+err:
+	if (hdev) {
+		hci_unregister_dev(hdev);
+		hci_free_dev(hdev);
+		h_adapter->hdev = NULL;
+	}
+	kfree(h_adapter);
+
+	return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(rsi_hci_attach);
+
+/**
+ * rsi_hci_attach () - This function initializes HCI interface
+ *				      
+ * @common: Pointer to the driver private structure.
+ *
+ * Return: 0 on success, negative error code on failure
+ */
+void rsi_hci_detach(struct rsi_common *common)
+{
+	struct rsi_hci_adapter *h_adapter = 
+		(struct rsi_hci_adapter *)common->hci_adapter;
+	struct hci_dev *hdev;
+
+	rsi_dbg(INFO_ZONE, "Detaching HCI...\n");
+
+	if (!h_adapter)
+		return;
+
+	hdev = h_adapter->hdev;
+	if (hdev) {
+                //hci_dev_hold(hdev);
+		hci_unregister_dev(hdev);
+                //hci_dev_put(hdev);
+		hci_free_dev(hdev);
+		h_adapter->hdev = NULL;
+	}
+	kfree(h_adapter);
+	common->bt_fsm_state = BT_DEVICE_NOT_READY;
+
+	return;
+}
+EXPORT_SYMBOL_GPL(rsi_hci_detach);
+
diff --git a/drivers/net/wireless/rsi/rsi_91x_mac80211.c b/drivers/net/wireless/rsi/rsi_91x_mac80211.c
index dbb2389..68d5f7a 100644
--- a/drivers/net/wireless/rsi/rsi_91x_mac80211.c
+++ b/drivers/net/wireless/rsi/rsi_91x_mac80211.c
@@ -1,23 +1,43 @@
-/**
- * Copyright (c) 2014 Redpine Signals Inc.
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
+ *
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
  *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
  *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include <linux/etherdevice.h>
+#include <linux/if.h>
+#include <linux/version.h>
 #include "rsi_debugfs.h"
 #include "rsi_mgmt.h"
 #include "rsi_common.h"
+#include "rsi_ps.h"
+#include "rsi_hal.h"
+
+int g_bgscan_enable;
 
 static const struct ieee80211_channel rsi_2ghz_channels[] = {
 	{ .band = NL80211_BAND_2GHZ, .center_freq = 2412,
@@ -42,10 +62,17 @@
 	  .hw_value = 10 }, /* Channel 10 */
 	{ .band = NL80211_BAND_2GHZ, .center_freq = 2462,
 	  .hw_value = 11 }, /* Channel 11 */
+#ifndef CONFIG_CARACALLA_BOARD
 	{ .band = NL80211_BAND_2GHZ, .center_freq = 2467,
 	  .hw_value = 12 }, /* Channel 12 */
 	{ .band = NL80211_BAND_2GHZ, .center_freq = 2472,
 	  .hw_value = 13 }, /* Channel 13 */
+#else
+	{ .band = NL80211_BAND_2GHZ, .center_freq = 2467, .max_power = 15,
+	  .hw_value = 12 }, /* Channel 12 */
+	{ .band = NL80211_BAND_2GHZ, .center_freq = 2472, .max_power = 7,
+	  .hw_value = 13 }, /* Channel 13 */
+#endif
 	{ .band = NL80211_BAND_2GHZ, .center_freq = 2484,
 	  .hw_value = 14 }, /* Channel 14 */
 };
@@ -121,13 +148,93 @@ struct ieee80211_rate rsi_rates[12] = {
 	RSI_RATE_MCS4, RSI_RATE_MCS5, RSI_RATE_MCS6, RSI_RATE_MCS7
 };
 
+static const u32 rsi_max_ap_stas[16] = {
+	32,	/* 1 - Wi-Fi alone */
+	0,	/* 2 */
+	0,	/* 3 */
+	0,	/* 4 - BT EDR alone */
+	4,	/* 5 - STA + BT EDR */
+	32,	/* 6 - AP + BT EDR */
+	0,	/* 7 */
+	0,	/* 8 - BT LE alone */
+        4,	/* 9 - STA + BE LE */
+	0,	/* 10 */
+	0,	/* 11 */
+	0,	/* 12 */
+	1,	/* 13 - STA + BT Dual */
+	4,	/* 14 - AP + BT Dual */
+};
+
+#ifdef CONFIG_RSI_P2P
+static const struct ieee80211_iface_limit rsi_iface_limits[] = {
+	{
+		.max = 1, 
+		.types = BIT(NL80211_IFTYPE_STATION),
+	},
+	{
+		.max = 1, 
+		.types = BIT(NL80211_IFTYPE_AP) |
+			BIT(NL80211_IFTYPE_P2P_CLIENT) |
+			BIT(NL80211_IFTYPE_P2P_GO),
+	},
+	{
+		.max = 1, 
+		.types = BIT(NL80211_IFTYPE_P2P_DEVICE),
+	},
+};
+
+static const struct ieee80211_iface_combination rsi_iface_combinations[] = {
+	{
+		.num_different_channels = 1, 
+		.max_interfaces = 3, 
+		.limits = rsi_iface_limits,
+		.n_limits = ARRAY_SIZE(rsi_iface_limits),
+	},
+};
+#endif
+
+#ifdef CONFIG_CARACALLA_BOARD
+struct reg_map {
+	char country_code[2];
+	u8 region_code; 
+};
+
+static struct reg_map rsi_caracalla_reg_db[MAX_REG_COUNTRIES] = {
+	{"AU", NL80211_DFS_ETSI}, {"AT", NL80211_DFS_ETSI},
+	{"BE", NL80211_DFS_ETSI}, {"BR", NL80211_DFS_WORLD},
+	{"CA", NL80211_DFS_FCC}, {"CL", NL80211_DFS_WORLD},
+	{"CN", NL80211_DFS_WORLD}, {"CO", NL80211_DFS_FCC},
+	{"CZ", NL80211_DFS_ETSI}, {"DK", NL80211_DFS_ETSI},
+	{"FI", NL80211_DFS_ETSI}, {"FR", NL80211_DFS_ETSI},
+	{"DE", NL80211_DFS_ETSI}, {"HK", NL80211_DFS_WORLD},
+	{"IN", NL80211_DFS_WORLD}, {"ID", NL80211_DFS_WORLD},
+	{"IE", NL80211_DFS_ETSI}, {"IL", NL80211_DFS_ETSI},
+	{"IT", NL80211_DFS_ETSI}, {"JP", NL80211_DFS_JP},
+	{"KR", NL80211_DFS_WORLD}, {"LU", NL80211_DFS_ETSI},
+	{"MY", NL80211_DFS_WORLD}, {"MX", NL80211_DFS_FCC},
+	{"MA", NL80211_DFS_WORLD}, {"NL", NL80211_DFS_ETSI},
+};
+#endif
+
+struct ieee80211_vif *rsi_get_vif(struct rsi_hw *adapter, u8 *mac)
+{
+	u8 i;
+
+	for (i = 0; i < RSI_MAX_VIFS; i++) {
+		if (!adapter->vifs[i])
+			continue;
+		if (!(memcmp(adapter->vifs[i]->addr, mac, ETH_ALEN)))
+			return adapter->vifs[i];
+	}
+	return NULL;
+}
+
 /**
  * rsi_is_cipher_wep() -  This function determines if the cipher is WEP or not.
  * @common: Pointer to the driver private structure.
  *
  * Return: If cipher type is WEP, a value of 1 is returned, else 0.
  */
-
 bool rsi_is_cipher_wep(struct rsi_common *common)
 {
 	if (((common->secinfo.gtk_cipher == WLAN_CIPHER_SUITE_WEP104) ||
@@ -151,7 +258,7 @@ static void rsi_register_rates_channels(struct rsi_hw *adapter, int band)
 	void *channels = NULL;
 
 	if (band == NL80211_BAND_2GHZ) {
-		channels = kmalloc(sizeof(rsi_2ghz_channels), GFP_KERNEL);
+		channels = kzalloc(sizeof(rsi_2ghz_channels), GFP_KERNEL);
 		memcpy(channels,
 		       rsi_2ghz_channels,
 		       sizeof(rsi_2ghz_channels));
@@ -160,7 +267,7 @@ static void rsi_register_rates_channels(struct rsi_hw *adapter, int band)
 		sbands->bitrates = rsi_rates;
 		sbands->n_bitrates = ARRAY_SIZE(rsi_rates);
 	} else {
-		channels = kmalloc(sizeof(rsi_5ghz_channels), GFP_KERNEL);
+		channels = kzalloc(sizeof(rsi_5ghz_channels), GFP_KERNEL);
 		memcpy(channels,
 		       rsi_5ghz_channels,
 		       sizeof(rsi_5ghz_channels));
@@ -184,6 +291,175 @@ static void rsi_register_rates_channels(struct rsi_hw *adapter, int band)
 	/* sbands->ht_cap.mcs.rx_highest = 0x82; */
 }
 
+static void rsi_set_min_rate(struct ieee80211_hw *hw,
+			     struct ieee80211_sta *sta,
+			     struct rsi_common *common)
+{
+	struct rsi_hw *adapter = common->priv;
+	struct ieee80211_vif *vif = adapter->vifs[adapter->sc_nvifs - 1];
+	u8 band = hw->conf.chandef.chan->band;
+	u8 ii;
+	u32 rate_bitmap;
+	bool matched = false;
+
+	if (vif->type == NL80211_IFTYPE_AP) {
+		common->bitrate_mask[band] = common->fixedrate_mask[band];
+		rate_bitmap = common->bitrate_mask[band];
+	} else {
+		common->bitrate_mask[band] = sta->supp_rates[band];
+		rate_bitmap = (common->fixedrate_mask[band] &
+			       sta->supp_rates[band]);
+	}
+	rsi_dbg(INFO_ZONE, "bitrate_mask = %x\n", common->bitrate_mask[band]);
+	rsi_dbg(INFO_ZONE, "rate_bitmap = %x\n", rate_bitmap);
+
+	if (rate_bitmap & 0xfff) {
+		/* Find out the min rate */
+		for (ii = 0; ii < ARRAY_SIZE(rsi_rates); ii++) {
+			if (rate_bitmap & BIT(ii)) {
+				common->min_rate = rsi_rates[ii].hw_value;
+				matched = true;
+				break;
+			}
+		}
+	}
+
+	if (vif->type == NL80211_IFTYPE_STATION) {
+		common->vif_info[0].is_ht = sta->ht_cap.ht_supported;
+		if ((sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_20) ||
+		    (sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_40))
+			common->vif_info[0].sgi = true;
+	}
+
+	if ((common->vif_info[0].is_ht) && (rate_bitmap >> 12)) {
+		for (ii = 0; ii < ARRAY_SIZE(rsi_mcsrates); ii++) {
+			if ((rate_bitmap >> 12) & BIT(ii)) {
+				common->min_rate = rsi_mcsrates[ii];
+				matched = true;
+				break;
+			}
+		}
+	}
+
+	if (!matched)
+		common->min_rate = 0xffff;
+
+	rsi_dbg(INFO_ZONE, "Min Rate = %d\n", common->min_rate);
+}
+
+
+#ifdef CONFIG_HW_SCAN_OFFLOAD
+#define MAX_HW_SCAN_SSID 1
+static int rsi_mac80211_hw_scan_start(struct ieee80211_hw *hw,
+				      struct ieee80211_vif *vif,
+				      struct ieee80211_scan_request *hw_req)
+{
+	struct cfg80211_scan_request *scan_req = &hw_req->req;
+	struct cfg80211_ssid *cfg_ssid;
+	struct rsi_hw *adapter = hw->priv;
+	struct rsi_common *common = adapter->priv;
+	struct ieee80211_bss_conf *bss = &adapter->vifs[0]->bss_conf;
+	int ii = 0, n;
+
+	rsi_dbg(INFO_ZONE, "***** Hardware scan start *****\n");
+
+	if (common->fsm_state != FSM_MAC_INIT_DONE)
+		return -ENODEV;
+#ifdef CONFIG_RSI_WOW
+	if (common->wow_flags & RSI_WOW_ENABLED)
+		return -ENETDOWN;
+#endif
+	if (scan_req->n_channels == 0)
+		return -EINVAL;
+	/* Scan already in progress. So return */
+	if (common->bgscan_en || common->scan_in_prog)
+		return -EBUSY;
+
+	mutex_lock(&common->mutex);
+
+	if (!bss->assoc) {
+		common->scan_request = scan_req;
+		common->scan_vif = vif;
+		common->scan_in_prog = false;
+		queue_work(common->scan_workqueue, &common->scan_work);
+	} else {
+		/* Wait for EAPOL4 completion before starting bg scan */
+		if ((bss->assoc_capability & BIT(4))) {	
+			if (!common->start_bgscan) {
+				mutex_unlock(&common->mutex);
+				return -EBUSY;
+			}
+		}
+		common->bgscan_info.num_user_channels = scan_req->n_channels;
+		for (ii = 0; ii < scan_req->n_channels; ii++) {
+			common->bgscan_info.user_channels[ii] = 
+				scan_req->channels[ii]->hw_value;
+		}
+		if (!rsi_send_bgscan_params(common, 1)) {
+			if (scan_req->n_ssids > MAX_HW_SCAN_SSID) {
+				n = 0;
+				cfg_ssid = &scan_req->ssids[n];
+				rsi_dbg(INFO_ZONE, "handling only '%s'ssid of %d "
+					"hw scan ssid's\n", cfg_ssid->ssid,
+					scan_req->n_ssids);
+			}
+			rsi_send_probe_request(common, scan_req, n, 0, 1);
+			if (!rsi_send_bgscan_probe_req(common)) {
+				rsi_dbg(INFO_ZONE,
+					"Background scan started\n");
+				common->bgscan_en = 1;
+			}
+		}	
+	}
+	
+	mutex_unlock(&common->mutex);
+        return 0;
+}
+
+void rsi_mac80211_hw_scan_cancel(struct ieee80211_hw *hw,
+				 struct ieee80211_vif *vif)
+{
+	struct rsi_hw *adapter = hw->priv;
+	struct rsi_common *common = adapter->priv;
+	struct ieee80211_bss_conf *bss = &adapter->vifs[0]->bss_conf;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0))
+	struct cfg80211_scan_info info;
+#endif
+
+	mutex_lock(&common->mutex);
+
+	common->hw_scan_cancel = true;
+
+	if (common->scan_in_prog) {
+		common->scan_in_prog = false;
+		rsi_wait_event(&common->cancel_hw_scan_event,
+			       EVENT_WAIT_FOREVER);
+		rsi_reset_event(&common->cancel_hw_scan_event);
+		cancel_work_sync(&common->scan_work);
+		common->scan_request = NULL;
+	}
+	
+	if (common->bgscan_en) {
+		if (bss->assoc) {
+			rsi_wait_event(&common->cancel_hw_scan_event,
+				       EVENT_WAIT_FOREVER);
+			rsi_reset_event(&common->cancel_hw_scan_event);
+		} else {
+			common->bgscan_en = 0;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0))
+			info.aborted = false;
+			ieee80211_scan_completed(adapter->hw, &info);
+#else	
+			ieee80211_scan_completed(adapter->hw, false);
+#endif
+		}
+	}
+	common->hw_scan_cancel = false;
+	mutex_unlock(&common->mutex);
+}
+EXPORT_SYMBOL_GPL(rsi_mac80211_hw_scan_cancel);
+#endif
+
 /**
  * rsi_mac80211_detach() - This function is used to de-initialize the
  *			   Mac80211 stack.
@@ -194,14 +470,43 @@ static void rsi_register_rates_channels(struct rsi_hw *adapter, int band)
 void rsi_mac80211_detach(struct rsi_hw *adapter)
 {
 	struct ieee80211_hw *hw = adapter->hw;
-
+#ifdef CONFIG_HW_SCAN_OFFLOAD
+	struct rsi_common *common = adapter->priv;
+#endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0))
+	enum nl80211_band band;
+#else
+	int band;
+#endif
+
+	rsi_dbg(INFO_ZONE, "Detach mac80211...\n");
+
+#ifdef CONFIG_HW_SCAN_OFFLOAD
+	flush_workqueue(common->scan_workqueue);
+#endif
 	if (hw) {
 		ieee80211_stop_queues(hw);
 		ieee80211_unregister_hw(hw);
 		ieee80211_free_hw(hw);
+		adapter->hw = NULL;
+		adapter->sc_nvifs = 0;
 	}
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0))
+	for (band = 0; band < NUM_NL80211_BANDS; band++) {
+#else
+	for (band = 0; band < IEEE80211_NUM_BANDS; band++) {
+#endif
+		struct ieee80211_supported_band *sband =
+					&adapter->sbands[band];
+
+		kfree(sband->channels);
+	}
+
+#ifdef CONFIG_RSI_DEBUGFS
 	rsi_remove_dbgfs(adapter);
+	kfree(adapter->dfsentry);
+#endif
 }
 EXPORT_SYMBOL_GPL(rsi_mac80211_detach);
 
@@ -218,12 +523,25 @@ void rsi_indicate_tx_status(struct rsi_hw *adapter,
 			    int status)
 {
 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+	struct skb_info *tx_params;
 
-	memset(info->driver_data, 0, IEEE80211_TX_INFO_DRIVER_DATA_SIZE);
+	if (!adapter->hw) {
+		rsi_dbg(ERR_ZONE, "##### No Hardware #####\n");
+		return;
+	}
+        
+	if (adapter->priv->iface_down) {
+		rsi_dbg(ERR_ZONE, "#####Interface is down#####\n");
+		return;
+	}
 
 	if (!status)
 		info->flags |= IEEE80211_TX_STAT_ACK;
 
+	tx_params = (struct skb_info *)info->driver_data;
+	skb_pull(skb, tx_params->internal_hdr_size);
+	memset(info->driver_data, 0, IEEE80211_TX_INFO_DRIVER_DATA_SIZE);
+
 	ieee80211_tx_status_irqsafe(adapter->hw, skb);
 }
 
@@ -243,8 +561,35 @@ static void rsi_mac80211_tx(struct ieee80211_hw *hw,
 {
 	struct rsi_hw *adapter = hw->priv;
 	struct rsi_common *common = adapter->priv;
+	struct ieee80211_hdr *wlh = (struct ieee80211_hdr *)skb->data;
+	struct ieee80211_vif *vif = adapter->vifs[adapter->sc_nvifs - 1];
+
+#ifdef CONFIG_RSI_WOW
+	if (common->wow_flags & RSI_WOW_ENABLED) {
+		ieee80211_free_txskb(common->priv->hw, skb);
+		return;
+	}
+#endif
+	if (ieee80211_is_beacon(wlh->frame_control)) {
+		ieee80211_free_txskb(common->priv->hw, skb);
+		return;
+	}
+
+	if ((common->coex_mode == 4) &&
+	    (vif->type == NL80211_IFTYPE_STATION) &&
+	    ((ieee80211_is_probe_req(wlh->frame_control) ||
+	      (ieee80211_is_auth(wlh->frame_control))))) {
+		rsi_dbg(ERR_ZONE,
+			"Dropping Station packets in AP+BT dual mode\n");
+		ieee80211_free_txskb(common->priv->hw, skb);
+		return;
+	}
 
+#if defined(CONFIG_RSI_BT_ALONE) && !defined(CONFIG_RSI_COEX)
+        ieee80211_free_txskb(common->priv->hw, skb); 
+#else
 	rsi_core_xmit(common, skb);
+#endif
 }
 
 /**
@@ -260,8 +605,16 @@ static int rsi_mac80211_start(struct ieee80211_hw *hw)
 	struct rsi_hw *adapter = hw->priv;
 	struct rsi_common *common = adapter->priv;
 
+	rsi_dbg(ERR_ZONE, "===> Interface UP <===\n");
 	mutex_lock(&common->mutex);
+
+#ifdef CONFIG_HW_SCAN_OFFLOAD
+	common->scan_in_prog = false;
+#endif
 	common->iface_down = false;
+        wiphy_rfkill_start_polling(hw->wiphy);
+	rsi_send_rx_filter_frame(common, 0);
+
 	mutex_unlock(&common->mutex);
 
 	return 0;
@@ -277,9 +630,23 @@ static void rsi_mac80211_stop(struct ieee80211_hw *hw)
 {
 	struct rsi_hw *adapter = hw->priv;
 	struct rsi_common *common = adapter->priv;
+	
+	rsi_dbg(ERR_ZONE, "===> Interface DOWN <===\n");
 
 	mutex_lock(&common->mutex);
+	
 	common->iface_down = true;
+#ifdef CONFIG_HW_SCAN_OFFLOAD
+	if (common->scan_in_prog) 
+		common->scan_in_prog = false;
+#endif
+
+	wiphy_rfkill_stop_polling(hw->wiphy);
+
+	/* Block all rx frames */
+	if (common->fsm_state == FSM_MAC_INIT_DONE)
+		rsi_send_rx_filter_frame(common, 0xffff);
+	
 	mutex_unlock(&common->mutex);
 }
 
@@ -295,23 +662,104 @@ static int rsi_mac80211_add_interface(struct ieee80211_hw *hw,
 				      struct ieee80211_vif *vif)
 {
 	struct rsi_hw *adapter = hw->priv;
-	struct rsi_common *common = adapter->priv;
-	int ret = -EOPNOTSUPP;
+	struct rsi_common *common = NULL;
+	enum opmode intf_mode;
+	int ret = 0;
+	struct vif_priv *vif_info = (struct vif_priv *)vif->drv_priv;
+	enum vap_status vap_status = VAP_ADD;
+
+	rsi_dbg(INFO_ZONE, "Add Interface Called\n");
+
+	if (!adapter)
+		return -ENODEV;
+	common = adapter->priv;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 0, 0))
+	vif->driver_flags |= IEEE80211_VIF_SUPPORTS_UAPSD;
+#endif
 
 	mutex_lock(&common->mutex);
+
+	/* Not supporting concurrent mode now */	
+	if (adapter->sc_nvifs > 0) {
+		if ((!common->p2p_enabled) &&
+		    (vif->type != NL80211_IFTYPE_P2P_DEVICE)) {
+			ret = -EINVAL;
+			goto out;
+		}
+		if (adapter->vifs[0]->bss_conf.assoc)
+			return -EOPNOTSUPP;
+	}
+
 	switch (vif->type) {
 	case NL80211_IFTYPE_STATION:
-		if (!adapter->sc_nvifs) {
-			++adapter->sc_nvifs;
-			adapter->vifs[0] = vif;
-			ret = rsi_set_vap_capabilities(common, STA_OPMODE);
-		}
+		rsi_dbg(INFO_ZONE, "Station Mode");
+		intf_mode = STA_OPMODE;
+		break;
+	case NL80211_IFTYPE_AP:
+		rsi_dbg(INFO_ZONE, "AP Mode");
+		intf_mode = AP_OPMODE;
+		break;
+	case NL80211_IFTYPE_P2P_DEVICE:
+		rsi_dbg(INFO_ZONE, "P2P Device Mode");
+		common->p2p_enabled = 1;
+		intf_mode = STA_OPMODE;
+		break;
+	case NL80211_IFTYPE_P2P_GO:
+		rsi_dbg(INFO_ZONE, "P2P GO Mode");
+		intf_mode = P2P_GO_OPMODE;
+		common->p2p_enabled = 1;
+		break;
+	case NL80211_IFTYPE_P2P_CLIENT:
+		rsi_dbg(INFO_ZONE, "P2P Client Mode");
+		intf_mode = P2P_CLIENT_OPMODE;
+		common->p2p_enabled = 1;
 		break;
 	default:
-		rsi_dbg(ERR_ZONE,
-			"%s: Interface type %d not supported\n", __func__,
-			vif->type);
+		rsi_dbg(ERR_ZONE, "Unsupported mode");
+		ret = -EINVAL;
+		goto out;
+	}
+	if (adapter->sc_nvifs >= RSI_MAX_VIFS)
+		adapter->vifs[adapter->sc_nvifs - 1] = vif;
+	else
+		adapter->vifs[adapter->sc_nvifs++] = vif;
+
+	if (!common->p2p_enabled) {
+		vif_info->vap_id = 0;
+		common->last_vap_id = 0;
+	} else {
+		if ((intf_mode == AP_OPMODE) ||
+		    (intf_mode == P2P_GO_OPMODE)) {
+			vif_info->vap_id = common->last_vap_id + 1;
+		} else {
+			vif_info->vap_id = common->last_vap_id;
+			vap_status = VAP_UPDATE;
+		}
+	}
+	ret = rsi_set_vap_capabilities(common, intf_mode,
+				       vif->addr, vif_info->vap_id,
+				       vap_status);
+	if (ret) {
+		rsi_dbg(ERR_ZONE, "Failed to set VAP capabilities\n");
+		goto out;
 	}
+	memset(vif_info->rx_bcmc_pn, 0, IEEE80211_CCMP_PN_LEN);
+	vif_info->rx_pn_valid = false;
+	vif_info->key = NULL;
+
+	if ((vif->type == NL80211_IFTYPE_AP) ||
+	    (vif->type == NL80211_IFTYPE_P2P_GO)) {
+		int i;
+
+		common->bc_mc_seqno = 1;
+		rsi_send_rx_filter_frame(common, DISALLOW_BEACONS);
+		common->min_rate = 0xffff;
+		for (i = 0; i < common->max_stations; i++)
+			common->stations[i].sta = NULL;
+	}
+
+out:
 	mutex_unlock(&common->mutex);
 
 	return ret;
@@ -330,14 +778,133 @@ static void rsi_mac80211_remove_interface(struct ieee80211_hw *hw,
 {
 	struct rsi_hw *adapter = hw->priv;
 	struct rsi_common *common = adapter->priv;
+	struct vif_priv *vif_info = (struct vif_priv *)vif->drv_priv;
+	int i;
+
+	rsi_dbg(INFO_ZONE, "Remove Interface Called\n");
+	
+	if (adapter->sc_nvifs <= 0)
+		return;
+	
+	mutex_lock(&common->mutex);
+
+	for (i = 0; i < RSI_MAX_VIFS; i++) {
+		if (adapter->vifs[i] == vif) {
+			adapter->sc_nvifs--;
+			switch (adapter->vifs[i]->type) {
+				case NL80211_IFTYPE_STATION:
+					rsi_set_vap_capabilities(common,
+								STA_OPMODE,
+								vif->addr,
+								vif_info->vap_id,
+								VAP_DELETE);
+					break;
+				case NL80211_IFTYPE_AP:
+					rsi_set_vap_capabilities(common,
+								AP_OPMODE,
+								vif->addr,
+								vif_info->vap_id,
+								VAP_DELETE);
+					break;
+				case NL80211_IFTYPE_P2P_CLIENT:
+					rsi_set_vap_capabilities(common,
+								P2P_CLIENT_OPMODE,
+								vif->addr,
+								vif_info->vap_id,
+								VAP_DELETE);
+					break;
+				case NL80211_IFTYPE_P2P_GO:
+					rsi_set_vap_capabilities(common,
+								P2P_GO_OPMODE,
+								vif->addr,
+								vif_info->vap_id,
+								VAP_DELETE);
+					break;
+				default:
+					goto out;
+			}
+			adapter->vifs[i] = NULL;
+			break;
+		}
+	}
+
+out:
+	mutex_unlock(&common->mutex);
+}
+
+static int rsi_mac80211_change_interface(struct ieee80211_hw *hw,
+					 struct ieee80211_vif *vif,
+					 enum nl80211_iftype newtype,
+					 bool newp2p)
+{
+	struct rsi_hw *adapter = (struct rsi_hw *)hw->priv;
+	struct rsi_common *common = (struct rsi_common *)adapter->priv;
+	struct vif_priv *vif_info = (struct vif_priv *)vif->drv_priv;
+	int status = 0;
+	enum opmode intf_mode;
+
+	rsi_dbg(INFO_ZONE,
+		"Change Interface: New_type = %d, New_p2p = %d\n",
+		newtype, newp2p);
 
 	mutex_lock(&common->mutex);
-	if (vif->type == NL80211_IFTYPE_STATION)
-		adapter->sc_nvifs--;
 
-	if (!memcmp(adapter->vifs[0], vif, sizeof(struct ieee80211_vif)))
-		adapter->vifs[0] = NULL;
+	vif->type = newtype;
+	vif->p2p = newp2p;
+	
+	switch (newtype) {
+		case NL80211_IFTYPE_AP:
+			rsi_dbg(INFO_ZONE, "Change to AP Mode\n");
+			intf_mode = AP_OPMODE;
+			break;
+		case NL80211_IFTYPE_STATION:
+			intf_mode = STA_OPMODE;
+			rsi_dbg(INFO_ZONE, "Change to Station Mode\n");
+			break;
+		case NL80211_IFTYPE_P2P_CLIENT:
+			rsi_dbg(INFO_ZONE, "Change to P2P Client Mode\n");
+			intf_mode = P2P_CLIENT_OPMODE;
+			break;
+		case NL80211_IFTYPE_P2P_GO:
+			rsi_dbg(INFO_ZONE, "Change to P2P Go Mode\n");
+			intf_mode = P2P_GO_OPMODE;
+			break;
+		default:
+			status = -EINVAL;
+			goto out;
+	}
+//	if (intf_mode == AP_OPMODE) {
+		rsi_set_vap_capabilities(common,
+					 //STA_OPMODE,
+					 common->last_vap_type,
+					 vif->addr,
+					 vif_info->vap_id,
+					 VAP_DELETE);
+		status = rsi_set_vap_capabilities(common,
+						  intf_mode,
+						  vif->addr,
+						  vif_info->vap_id,
+						  VAP_ADD);
+#if 0
+	} else if ((intf_mode != common->last_vap_type) ||
+		   (!ether_addr_equal(vif->addr, common->last_vap_addr))) {
+		status = rsi_set_vap_capabilities(common,
+						  intf_mode,
+						  vif->addr,
+						  vif_info->vap_id,
+						  VAP_UPDATE);
+	}
+#endif
+	if ((vif->type == NL80211_IFTYPE_AP) ||
+	    (vif->type == NL80211_IFTYPE_P2P_GO)) {
+		common->bc_mc_seqno = 1;
+		rsi_send_rx_filter_frame(common, DISALLOW_BEACONS);
+		common->min_rate = 0xffff;
+	}
+
+out:
 	mutex_unlock(&common->mutex);
+	return status;
 }
 
 /**
@@ -355,25 +922,55 @@ static int rsi_channel_change(struct ieee80211_hw *hw)
 	int status = -EOPNOTSUPP;
 	struct ieee80211_channel *curchan = hw->conf.chandef.chan;
 	u16 channel = curchan->hw_value;
-	struct ieee80211_bss_conf *bss = &adapter->vifs[0]->bss_conf;
+	struct ieee80211_bss_conf *bss = NULL;
+	struct ieee80211_vif *vif = adapter->vifs[adapter->sc_nvifs - 1];
+
+	if (adapter->sc_nvifs <= 0) {
+		rsi_dbg(ERR_ZONE, "%s: No virtual interface found\n", __func__);
+		return -EINVAL;
+	}
+	bss = &vif->bss_conf;
 
 	rsi_dbg(INFO_ZONE,
 		"%s: Set channel: %d MHz type: %d channel_no %d\n",
 		__func__, curchan->center_freq,
 		curchan->flags, channel);
 
+	if ((vif->type == NL80211_IFTYPE_AP) ||
+	    (vif->type == NL80211_IFTYPE_P2P_GO)) {
+		rsi_dbg(INFO_ZONE, "Configure channel %d for AP\n", channel);
+		if (rsi_band_check(common, curchan)) {
+			rsi_dbg(ERR_ZONE, "Failed to set band\n");
+			return -EINVAL;
+		}
+		if (rsi_set_channel(common, curchan)) {
+			rsi_dbg(ERR_ZONE, "Failed to set the channel\n");
+			return -EINVAL;
+		}
+		common->ap_channel = curchan;
+		return 0;
+	}
+	common->mac80211_cur_channel = channel;
 	if (bss->assoc) {
+		rsi_dbg(INFO_ZONE, "%s: connected\n", __func__);
+
+		if (common->bgscan_en)
+			return 0;
+
 		if (!common->hw_data_qs_blocked &&
 		    (rsi_get_connected_channel(adapter) != channel)) {
 			rsi_dbg(INFO_ZONE, "blk data q %d\n", channel);
 			if (!rsi_send_block_unblock_frame(common, true))
 				common->hw_data_qs_blocked = true;
 		}
+	} else {
+		rsi_dbg(INFO_ZONE, "assoc status:%d channel:%d\n",
+			bss->assoc, channel);
 	}
 
-	status = rsi_band_check(common);
+	status = rsi_band_check(common, curchan);
 	if (!status)
-		status = rsi_set_channel(adapter->priv, channel);
+		status = rsi_set_channel(adapter->priv, curchan);
 
 	if (bss->assoc) {
 		if (common->hw_data_qs_blocked &&
@@ -383,13 +980,46 @@ static int rsi_channel_change(struct ieee80211_hw *hw)
 				common->hw_data_qs_blocked = false;
 		}
 	} else {
+#if 0
 		if (common->hw_data_qs_blocked) {
 			rsi_dbg(INFO_ZONE, "unblk data q %d\n", channel);
 			if (!rsi_send_block_unblock_frame(common, false))
 				common->hw_data_qs_blocked = false;
 		}
+#endif
+	}
+
+	return status;
+}
+
+/**
+ * rsi_config_power() - This function configures tx power in device
+ * @hw: Pointer to the ieee80211_hw structure.
+ *
+ * Return: 0 on success, negative error code on failure.
+ */
+static int rsi_config_power(struct ieee80211_hw *hw)
+{
+	struct rsi_hw *adapter = hw->priv;
+	struct rsi_common *common = adapter->priv;
+	struct ieee80211_conf *conf = &hw->conf;
+	int status;
+
+	if (adapter->sc_nvifs <= 0) {
+		rsi_dbg(ERR_ZONE, "%s: No virtual interface found\n", __func__);
+		return -EINVAL;
 	}
 
+	rsi_dbg(INFO_ZONE,
+		"%s: Set tx power: %d dBM\n", __func__, conf->power_level);
+
+	if (conf->power_level == common->tx_power)
+		return 0;
+
+	common->tx_power = conf->power_level;
+
+	status = rsi_send_radio_params_update(common);
+
 	return status;
 }
 
@@ -407,13 +1037,74 @@ static int rsi_mac80211_config(struct ieee80211_hw *hw,
 {
 	struct rsi_hw *adapter = hw->priv;
 	struct rsi_common *common = adapter->priv;
+	struct ieee80211_vif *vif = adapter->vifs[adapter->sc_nvifs - 1];
+	struct ieee80211_bss_conf *bss = &vif->bss_conf;
+	struct ieee80211_conf *conf = &hw->conf;
 	int status = -EOPNOTSUPP;
 
+	if (common->fsm_state != FSM_MAC_INIT_DONE)
+		return -ENODEV;
+
 	mutex_lock(&common->mutex);
 
+	/* channel */
 	if (changed & IEEE80211_CONF_CHANGE_CHANNEL)
 		status = rsi_channel_change(hw);
 
+	/* listen interval */
+	if (changed & IEEE80211_CONF_CHANGE_LISTEN_INTERVAL) {
+		rsi_dbg(INFO_ZONE,
+			"listen_int = %d\n", conf->listen_interval);
+		if (bss->dtim_period < conf->listen_interval)
+			adapter->ps_info.num_bcns_per_lis_int =
+				bss->dtim_period;
+		else
+			adapter->ps_info.num_bcns_per_lis_int =
+				conf->listen_interval;
+	}
+
+	/* tx power */
+	if (changed & IEEE80211_CONF_CHANGE_POWER) {
+		rsi_dbg(INFO_ZONE, "%s: Configuring Power\n", __func__);
+		status = rsi_config_power(hw);
+	}
+
+	/* retry limit */
+	if (changed & IEEE80211_CONF_CHANGE_RETRY_LIMITS) {
+		/* FIXME */
+	}
+
+	/* Power save parameters */
+	if ((changed & IEEE80211_CONF_CHANGE_PS) &&
+	    (vif->type == NL80211_IFTYPE_STATION)) {
+		unsigned long flags;
+
+		spin_lock_irqsave(&adapter->ps_lock, flags);
+		if (conf->flags & IEEE80211_CONF_PS) {
+			rsi_enable_ps(adapter);
+			rsi_reset_event(&common->mgmt_cfm_event);
+			rsi_wait_event(&common->mgmt_cfm_event,
+				       msecs_to_jiffies(1000));
+
+		} else {
+			rsi_disable_ps(adapter);
+			rsi_reset_event(&common->mgmt_cfm_event);
+			rsi_wait_event(&common->mgmt_cfm_event,
+				       msecs_to_jiffies(1000));
+		}
+		spin_unlock_irqrestore(&adapter->ps_lock, flags);
+	}
+
+	/* RTS threshold */
+	if (changed & WIPHY_PARAM_RTS_THRESHOLD) {
+		rsi_dbg(INFO_ZONE,"RTS threshold\n");
+		if ((common->rts_threshold) <= IEEE80211_MAX_RTS_THRESHOLD) {
+			rsi_dbg(INFO_ZONE,
+				"%s: Sending vap updates....\n", __func__);
+			status = rsi_send_vap_dynamic_update(common);
+		}
+	}
+
 	mutex_unlock(&common->mutex);
 
 	return status;
@@ -428,16 +1119,53 @@ static int rsi_mac80211_config(struct ieee80211_hw *hw,
  */
 u16 rsi_get_connected_channel(struct rsi_hw *adapter)
 {
-	struct ieee80211_vif *vif = adapter->vifs[0];
+	struct ieee80211_vif *vif = adapter->vifs[adapter->sc_nvifs - 1];
+	struct rsi_common *common = adapter->priv;
+
+	if (common->iface_down)
+		return -EINVAL;
+	if ((!adapter->vifs[0]) || (!vif))
+		return -EINVAL;
 	if (vif) {
 		struct ieee80211_bss_conf *bss = &vif->bss_conf;
 		struct ieee80211_channel *channel = bss->chandef.chan;
+
+		if (!channel)
+			return 0;
 		return channel->hw_value;
 	}
 
 	return 0;
 }
 
+void rsi_resume_conn_channel(struct rsi_hw *adapter,
+			     struct ieee80211_vif *vif)
+{
+	struct rsi_common *common = adapter->priv;
+	struct ieee80211_bss_conf *bss = NULL;
+
+	if (common->iface_down)
+		return;
+	if ((!adapter->vifs[0]) || (!vif))
+		return;
+
+	bss = &vif->bss_conf;
+	if ((bss->assoc) ||
+	    (vif->type == NL80211_IFTYPE_AP) ||
+	    (vif->type == NL80211_IFTYPE_P2P_GO)) {
+		struct ieee80211_channel *channel = bss->chandef.chan;
+
+		if (!channel)
+			return;
+		
+		rsi_band_check(common, channel);
+
+		rsi_set_channel(common, channel);
+		rsi_dbg(INFO_ZONE, "resumed to channel %d\n",
+			channel->hw_value);
+	}
+}
+
 /**
  * rsi_mac80211_bss_info_changed() - This function is a handler for config
  *				     requests related to BSS parameters that
@@ -456,19 +1184,65 @@ static void rsi_mac80211_bss_info_changed(struct ieee80211_hw *hw,
 {
 	struct rsi_hw *adapter = hw->priv;
 	struct rsi_common *common = adapter->priv;
+	struct ieee80211_bss_conf *bss = &vif->bss_conf;
+	struct ieee80211_conf *conf = &hw->conf;
+	u16 rx_filter_word = 0;
+
+	rsi_dbg(INFO_ZONE, "%s: BSS status changed; changed=%08x\n",
+		__func__, changed);
+
+	if (common->fsm_state != FSM_MAC_INIT_DONE)
+		return;
 
 	mutex_lock(&common->mutex);
-	if (changed & BSS_CHANGED_ASSOC) {
+
+	if ((changed & BSS_CHANGED_ASSOC) &&
+	    (vif->type == NL80211_IFTYPE_STATION)) {
 		rsi_dbg(INFO_ZONE, "%s: Changed Association status: %d\n",
 			__func__, bss_conf->assoc);
-		rsi_inform_bss_status(common,
-				      bss_conf->assoc,
-				      bss_conf->bssid,
-				      bss_conf->qos,
-				      bss_conf->aid);
+		bss->assoc = bss_conf->assoc;
+		if (bss->assoc) {
+			/* Send the RX filter frame */
+			rx_filter_word = (ALLOW_DATA_ASSOC_PEER |
+					  ALLOW_CTRL_ASSOC_PEER |
+					  ALLOW_MGMT_ASSOC_PEER |
+					  0);
+			rsi_send_rx_filter_frame(common, rx_filter_word);
+		}
+		rsi_dbg(INFO_ZONE,
+			"assoc_status=%d, qos=%d, aid=%d\n",
+			bss->assoc, bss->qos, bss->aid);
+		rsi_dbg(INFO_ZONE,
+				"bssid=%02x:%02x:%02x:%02x:%02x:%02x",
+				bss->bssid[0], bss->bssid[1], bss->bssid[2],
+				bss->bssid[3], bss->bssid[4], bss->bssid[5]);
+
+		/* Send peer notify to device */
+		rsi_dbg(INFO_ZONE, "Indicate bss status to device\n");
+		rsi_inform_bss_status(common, STA_OPMODE, bss->assoc,
+				      bss->bssid, bss->qos, bss->aid, NULL, 0,
+				      bss->assoc_capability);
+
+		/* Update DTIM period and listen interval */
+		adapter->ps_info.dtim_interval_duration = bss->dtim_period;
+		adapter->ps_info.listen_interval = conf->listen_interval;
+		rsi_dbg(INFO_ZONE, "Beacon_Int = %d Lis_Int = %d Dtim = %d\n",
+			bss->beacon_int, adapter->ps_info.num_bcns_per_lis_int,
+			bss->dtim_period);
+
+		/* If UAPSD is updated send ps params */
+		if (bss->assoc) {
+			if (common->uapsd_bitmap) {
+				rsi_dbg(INFO_ZONE, "Configuring UAPSD\n");
+				rsi_conf_uapsd(adapter);
+			}
+		} else
+			common->uapsd_bitmap = 0;
 	}
 
-	if (changed & BSS_CHANGED_CQM) {
+	if ((vif->type == NL80211_IFTYPE_STATION) &&
+	    changed & BSS_CHANGED_CQM) {
+		rsi_dbg(INFO_ZONE, "%s: Changed CQM\n", __func__);
 		common->cqm_info.last_cqm_event_rssi = 0;
 		common->cqm_info.rssi_thold = bss_conf->cqm_rssi_thold;
 		common->cqm_info.rssi_hyst = bss_conf->cqm_rssi_hyst;
@@ -476,6 +1250,32 @@ static void rsi_mac80211_bss_info_changed(struct ieee80211_hw *hw,
 			common->cqm_info.rssi_thold,
 			common->cqm_info.rssi_hyst);
 	}
+
+	if (changed & BSS_CHANGED_TXPOWER) {
+		rsi_dbg(INFO_ZONE, "%s: Changed TX power: %d\n",
+			__func__, bss_conf->txpower);
+	}
+
+	if (changed & BSS_CHANGED_BEACON_INT) {
+		rsi_dbg(INFO_ZONE, "%s: Changed Beacon interval: %d\n",
+			__func__, bss_conf->beacon_int);
+		common->beacon_interval = bss->beacon_int; 
+		adapter->ps_info.listen_interval =
+			bss->beacon_int * adapter->ps_info.num_bcns_per_lis_int;
+	}
+
+	if ((changed & BSS_CHANGED_BEACON_ENABLED) &&
+	    ((vif->type == NL80211_IFTYPE_AP) ||
+	     (vif->type == NL80211_IFTYPE_P2P_GO))) {
+		if (bss->enable_beacon) {
+			rsi_dbg(INFO_ZONE, "===> BEACON ENABLED <===\n");
+			common->beacon_enabled = 1;
+		} else {
+			rsi_dbg(INFO_ZONE, "===> BEACON DISABLED <===\n");
+			common->beacon_enabled = 0;
+		}
+	}
+
 	mutex_unlock(&common->mutex);
 }
 
@@ -493,8 +1293,16 @@ static void rsi_mac80211_conf_filter(struct ieee80211_hw *hw,
 				     u32 *total_flags,
 				     u64 multicast)
 {
+#if 0
+	struct rsi_hw *adapter = hw->priv;
+	struct rsi_common *common = adapter->priv;
+	u16 rx_filter_word = 0;
+#endif
+
 	/* Not doing much here as of now */
 	*total_flags &= RSI_SUPP_FILTERS;
+
+//	rsi_send_rx_filter_frame(common, rx_filter_word);
 }
 
 /**
@@ -520,9 +1328,9 @@ static int rsi_mac80211_conf_tx(struct ieee80211_hw *hw,
 		return 0;
 
 	rsi_dbg(INFO_ZONE,
-		"%s: Conf queue %d, aifs: %d, cwmin: %d cwmax: %d, txop: %d\n",
-		__func__, queue, params->aifs,
-		params->cw_min, params->cw_max, params->txop);
+		"[Conf] queue:%d, aifs:%d, cwmin:%d cwmax:%d, txop:%d uapsd:%d\n",
+		queue, params->aifs, params->cw_min, params->cw_max,
+		params->txop, params->uapsd);
 
 	mutex_lock(&common->mutex);
 	/* Map into the way the f/w expects */
@@ -547,8 +1355,13 @@ static int rsi_mac80211_conf_tx(struct ieee80211_hw *hw,
 	memcpy(&common->edca_params[idx],
 	       params,
 	       sizeof(struct ieee80211_tx_queue_params));
-	mutex_unlock(&common->mutex);
 
+	if (params->uapsd)
+		common->uapsd_bitmap |= idx;
+	else
+		common->uapsd_bitmap &= (~idx);
+
+	mutex_unlock(&common->mutex);
 	return 0;
 }
 
@@ -562,11 +1375,14 @@ static int rsi_mac80211_conf_tx(struct ieee80211_hw *hw,
  */
 static int rsi_hal_key_config(struct ieee80211_hw *hw,
 			      struct ieee80211_vif *vif,
-			      struct ieee80211_key_conf *key)
+			      struct ieee80211_key_conf *key,
+			      struct ieee80211_sta *sta)
 {
 	struct rsi_hw *adapter = hw->priv;
+	struct rsi_sta *rsta = NULL;
 	int status;
 	u8 key_type;
+	s16 sta_id = 0;
 
 	if (key->flags & IEEE80211_KEY_FLAG_PAIRWISE)
 		key_type = RSI_PAIRWISE_KEY;
@@ -575,24 +1391,48 @@ static int rsi_hal_key_config(struct ieee80211_hw *hw,
 
 	rsi_dbg(ERR_ZONE, "%s: Cipher 0x%x key_type: %d key_len: %d\n",
 		__func__, key->cipher, key_type, key->keylen);
+	rsi_dbg(INFO_ZONE, "hw_key_idx %d\n", key->hw_key_idx);
 
-	if ((key->cipher == WLAN_CIPHER_SUITE_WEP104) ||
-	    (key->cipher == WLAN_CIPHER_SUITE_WEP40)) {
-		status = rsi_hal_load_key(adapter->priv,
-					  key->key,
-					  key->keylen,
-					  RSI_PAIRWISE_KEY,
-					  key->keyidx,
-					  key->cipher);
-		if (status)
-			return status;
+	if ((vif->type == NL80211_IFTYPE_AP) ||
+	    (vif->type == NL80211_IFTYPE_P2P_GO)) {
+		if (sta){
+			rsta = rsi_find_sta(adapter->priv, sta->addr);
+
+			if (rsta)
+				sta_id = rsta->sta_id;
+		}
+		adapter->priv->key = key;
+	} else {
+		if ((key->cipher == WLAN_CIPHER_SUITE_WEP104) ||
+		    (key->cipher == WLAN_CIPHER_SUITE_WEP40)) {
+			status = rsi_load_key(adapter->priv,
+					      key->key,
+					      key->keylen,
+					      RSI_PAIRWISE_KEY,
+					      key->keyidx,
+					      key->cipher,
+					      sta_id);
+			if (status)
+				return status;
+		}
 	}
-	return rsi_hal_load_key(adapter->priv,
-				key->key,
-				key->keylen,
-				key_type,
-				key->keyidx,
-				key->cipher);
+
+	status = rsi_load_key(adapter->priv,
+			      key->key,
+			      key->keylen,
+			      key_type,
+			      key->keyidx,
+			      key->cipher,
+			      sta_id);
+
+	if ((vif->type == NL80211_IFTYPE_STATION) && (key->key) &&
+	    ((key->cipher == WLAN_CIPHER_SUITE_WEP104) ||
+	    (key->cipher == WLAN_CIPHER_SUITE_WEP40))) {
+		adapter->priv->start_bgscan = 1;
+		if (!rsi_send_block_unblock_frame(adapter->priv, false))
+			adapter->priv->hw_data_qs_blocked = false;
+	}
+	return status;
 }
 
 /**
@@ -614,22 +1454,64 @@ static int rsi_mac80211_set_key(struct ieee80211_hw *hw,
 	struct rsi_hw *adapter = hw->priv;
 	struct rsi_common *common = adapter->priv;
 	struct security_info *secinfo = &common->secinfo;
+	struct vif_priv *vif_info = (struct vif_priv *)vif->drv_priv;
 	int status;
 
 	mutex_lock(&common->mutex);
 	switch (cmd) {
 	case SET_KEY:
 		secinfo->security_enable = true;
-		status = rsi_hal_key_config(hw, vif, key);
+		status = rsi_hal_key_config(hw, vif, key, sta);
 		if (status) {
 			mutex_unlock(&common->mutex);
 			return status;
 		}
 
-		if (key->flags & IEEE80211_KEY_FLAG_PAIRWISE)
+		if (key->flags & IEEE80211_KEY_FLAG_PAIRWISE) {
 			secinfo->ptk_cipher = key->cipher;
-		else
+		} else {
+			struct ieee80211_key_seq seq;
+
 			secinfo->gtk_cipher = key->cipher;
+			ieee80211_get_key_rx_seq(key, 0, &seq);
+			switch (key->cipher) {
+			case WLAN_CIPHER_SUITE_CCMP:
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 0, 0))
+			case WLAN_CIPHER_SUITE_CCMP_256:
+#endif
+				memcpy(vif_info->rx_bcmc_pn, seq.ccmp.pn,
+				       IEEE80211_CCMP_PN_LEN);
+				vif_info->rx_pn_valid = true;
+				vif_info->key = key;
+				break;
+			case WLAN_CIPHER_SUITE_TKIP:
+				vif_info->rx_bcmc_pn[0] = seq.tkip.iv16 & 0xff;
+				vif_info->rx_bcmc_pn[1] =
+					(seq.tkip.iv16 >> 8) & 0xff;
+				vif_info->rx_bcmc_pn[2] = seq.tkip.iv32 & 0xff;
+				vif_info->rx_bcmc_pn[3] =
+					(seq.tkip.iv32 >> 8) & 0xff;
+				vif_info->rx_bcmc_pn[4] =
+					(seq.tkip.iv32 >> 16) & 0xff;
+				vif_info->rx_bcmc_pn[5] =
+					(seq.tkip.iv32 >> 24) & 0xff;
+				vif_info->rx_pn_valid = true;
+				vif_info->key = key;
+				break;
+			case WLAN_CIPHER_SUITE_AES_CMAC:
+				memcpy(vif_info->rx_bcmc_pn,
+				       seq.aes_cmac.pn, 6);
+				vif_info->rx_pn_valid = true;
+				vif_info->key = key;
+				break;
+			}
+			rsi_dbg(INFO_ZONE,
+				"%s: RX PN: %02x-%02x-%02x-%02x-%02x-%02x",
+				__func__, vif_info->rx_bcmc_pn[5],
+				vif_info->rx_bcmc_pn[4], vif_info->rx_bcmc_pn[3],
+				vif_info->rx_bcmc_pn[2], vif_info->rx_bcmc_pn[1],
+				vif_info->rx_bcmc_pn[0]);
+		}
 
 		key->hw_key_idx = key->keyidx;
 		key->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;
@@ -638,10 +1520,15 @@ static int rsi_mac80211_set_key(struct ieee80211_hw *hw,
 		break;
 
 	case DISABLE_KEY:
-		secinfo->security_enable = false;
+		if ((vif->type == NL80211_IFTYPE_STATION) ||
+		    (vif->type == NL80211_IFTYPE_P2P_CLIENT))
+			secinfo->security_enable = false;
 		rsi_dbg(ERR_ZONE, "%s: RSI del key\n", __func__);
 		memset(key, 0, sizeof(struct ieee80211_key_conf));
-		status = rsi_hal_key_config(hw, vif, key);
+		memset(vif_info->rx_bcmc_pn, 0, IEEE80211_CCMP_PN_LEN);
+		vif_info->rx_pn_valid = false;
+		vif_info->key = NULL;
+		status = rsi_hal_key_config(hw, vif, key, sta);
 		break;
 
 	default:
@@ -659,24 +1546,62 @@ static int rsi_mac80211_set_key(struct ieee80211_hw *hw,
  *				 informs the f/w regarding this.
  * @hw: Pointer to the ieee80211_hw structure.
  * @vif: Pointer to the ieee80211_vif structure.
- * @params: Pointer to A-MPDU action parameters
+ * @action: ieee80211_ampdu_mlme_action enum.
+ * @sta: Pointer to the ieee80211_sta structure.
+ * @tid: Traffic identifier.
+ * @ssn: Pointer to ssn value.
+ * @buf_size: Buffer size (for kernel version > 2.6.38).
  *
  * Return: status: 0 on success, negative error code on failure.
  */
+#ifndef CONFIG_CARACALLA_BOARD
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 4, 0))
+static int rsi_mac80211_ampdu_action(struct ieee80211_hw *hw,
+				     struct ieee80211_vif *vif,
+				     enum ieee80211_ampdu_mlme_action action,
+				     struct ieee80211_sta *sta,
+				     u16 tid,
+				     u16 *ssn,
+				     u8 buf_size)
+#elif ((LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)) && \
+	(LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)))
+static int rsi_mac80211_ampdu_action(struct ieee80211_hw *hw,
+				     struct ieee80211_vif *vif,
+				     enum ieee80211_ampdu_mlme_action action,
+				     struct ieee80211_sta *sta,
+				     u16 tid,
+				     u16 *ssn,
+				     u8 buf_size,
+				     bool amsdu)
+#else
+static int rsi_mac80211_ampdu_action(struct ieee80211_hw *hw,
+				     struct ieee80211_vif *vif,
+				     struct ieee80211_ampdu_params *params)
+#endif
+#else
 static int rsi_mac80211_ampdu_action(struct ieee80211_hw *hw,
 				     struct ieee80211_vif *vif,
 				     struct ieee80211_ampdu_params *params)
+#endif
+	
 {
-	int status = -EOPNOTSUPP;
+	int status = 1;
 	struct rsi_hw *adapter = hw->priv;
 	struct rsi_common *common = adapter->priv;
-	u16 seq_no = 0;
+  struct rsi_sta *rsta = NULL;
+	u16 seq_no = 0, seq_start = 0;
 	u8 ii = 0;
-	struct ieee80211_sta *sta = params->sta;
-	enum ieee80211_ampdu_mlme_action action = params->action;
+	u8 sta_id = 0;
+
+#if (((LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)) && \
+      (LINUX_VERSION_CODE < KERNEL_VERSION(4, 5, 0))) || \
+     (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0)) || \
+     (defined(CONFIG_CARACALLA_BOARD)))
 	u16 tid = params->tid;
-	u16 *ssn = &params->ssn;
 	u8 buf_size = params->buf_size;
+	enum ieee80211_ampdu_mlme_action action = params->action;
+	struct ieee80211_sta *sta = params->sta;
+#endif
 
 	for (ii = 0; ii < RSI_MAX_VIFS; ii++) {
 		if (vif == adapter->vifs[ii])
@@ -684,29 +1609,62 @@ static int rsi_mac80211_ampdu_action(struct ieee80211_hw *hw,
 	}
 
 	mutex_lock(&common->mutex);
-	rsi_dbg(INFO_ZONE, "%s: AMPDU action %d called\n", __func__, action);
+
+#if ((LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)) && \
+	!(defined(CONFIG_CARACALLA_BOARD)))
 	if (ssn != NULL)
 		seq_no = *ssn;
+#else
+	seq_no = params->ssn;
+#endif
+	if ((vif->type == NL80211_IFTYPE_AP) ||
+	    (vif->type == NL80211_IFTYPE_P2P_GO)) {
+		rsta = rsi_find_sta(common, sta->addr);
+
+		if (!rsta) {
+			rsi_dbg(ERR_ZONE, "No station mapped\n");
+			return 0;
+		}
+		sta_id = rsta->sta_id;
+	}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 4, 0))
+	rsi_dbg(INFO_ZONE,
+		"%s: AMPDU action tid=%d ssn=0x%x, buf_size=%d\n",
+		__func__, tid, seq_no, buf_size);
+#endif
 
 	switch (action) {
 	case IEEE80211_AMPDU_RX_START:
-		status = rsi_send_aggregation_params_frame(common,
-							   tid,
-							   seq_no,
-							   buf_size,
-							   STA_RX_ADDBA_DONE);
+		rsi_dbg(INFO_ZONE, "AMPDU action RX_START (%d)\n", action);
+		status = rsi_send_aggr_params_frame(common,
+						    tid,
+						    seq_no,
+						    buf_size,
+						    STA_RX_ADDBA_DONE,
+						    sta_id);
 		break;
 
 	case IEEE80211_AMPDU_RX_STOP:
-		status = rsi_send_aggregation_params_frame(common,
-							   tid,
-							   0,
-							   buf_size,
-							   STA_RX_DELBA);
+		rsi_dbg(INFO_ZONE,
+			"AMPDU action RX_STOP (%d) called\n", action);
+		status = rsi_send_aggr_params_frame(common,
+						    tid,
+						    0,
+						    buf_size,
+						    STA_RX_DELBA,
+						    sta_id);
 		break;
 
 	case IEEE80211_AMPDU_TX_START:
-		common->vif_info[ii].seq_start = seq_no;
+		rsi_dbg(INFO_ZONE,
+			"AMPDU action TX_START (%d) called\n", action);
+		if ((vif->type == NL80211_IFTYPE_STATION) ||
+		    (vif->type == NL80211_IFTYPE_P2P_CLIENT))
+			common->vif_info[ii].seq_start = seq_no;
+		else if ((vif->type == NL80211_IFTYPE_AP) ||
+			 (vif->type == NL80211_IFTYPE_P2P_GO))
+			rsta->seq_start[ii] = seq_no;
 		ieee80211_start_tx_ba_cb_irqsafe(vif, sta->addr, tid);
 		status = 0;
 		break;
@@ -714,22 +1672,35 @@ static int rsi_mac80211_ampdu_action(struct ieee80211_hw *hw,
 	case IEEE80211_AMPDU_TX_STOP_CONT:
 	case IEEE80211_AMPDU_TX_STOP_FLUSH:
 	case IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:
-		status = rsi_send_aggregation_params_frame(common,
-							   tid,
-							   seq_no,
-							   buf_size,
-							   STA_TX_DELBA);
+		rsi_dbg(INFO_ZONE,
+			"AMPDU action TX_STOP_CONT / TX_STOP_FLUSH /"
+			" TX_STOP_FLUSH_CONT (%d) called\n", action);
+		status = rsi_send_aggr_params_frame(common,
+						    tid,
+						    seq_no,
+						    buf_size,
+						    STA_TX_DELBA,
+						    sta_id);
 		if (!status)
 			ieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);
 		break;
 
 	case IEEE80211_AMPDU_TX_OPERATIONAL:
-		status = rsi_send_aggregation_params_frame(common,
-							   tid,
-							   common->vif_info[ii]
-								.seq_start,
-							   buf_size,
-							   STA_TX_ADDBA_DONE);
+		rsi_dbg(INFO_ZONE,
+			"AMPDU action TX_OPERATIONAL(%d) called\n",
+			action);
+    if ((vif->type == NL80211_IFTYPE_STATION) ||
+        (vif->type == NL80211_IFTYPE_P2P_CLIENT))
+      seq_start = common->vif_info[ii].seq_start;
+    else if ((vif->type == NL80211_IFTYPE_AP) ||
+        (vif->type == NL80211_IFTYPE_P2P_GO))
+      seq_start = rsta->seq_start[ii];
+		status = rsi_send_aggr_params_frame(common,
+						tid,
+						seq_start,
+						buf_size,
+						STA_TX_ADDBA_DONE,
+						sta_id);
 		break;
 
 	default:
@@ -784,8 +1755,7 @@ static int rsi_mac80211_set_rate_mask(struct ieee80211_hw *hw,
 		common->fixedrate_mask[band] =
 			(mask->control[band].ht_mcs[0] << 12);
 	} else {
-		common->fixedrate_mask[band] =
-			mask->control[band].legacy;
+		common->fixedrate_mask[band] = mask->control[band].legacy;
 	}
 	mutex_unlock(&common->mutex);
 
@@ -808,6 +1778,9 @@ static void rsi_perform_cqm(struct rsi_common *common,
 	u32 hyst = common->cqm_info.rssi_hyst;
 	enum nl80211_cqm_rssi_threshold_event event;
 
+	if (common->iface_down)
+		return;
+
 	if (rssi < thold && (last_event == 0 || rssi < (last_event - hyst)))
 		event = NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW;
 	else if (rssi > thold &&
@@ -817,12 +1790,127 @@ static void rsi_perform_cqm(struct rsi_common *common,
 		return;
 
 	common->cqm_info.last_cqm_event_rssi = rssi;
-	rsi_dbg(INFO_ZONE, "CQM: Notifying event: %d\n", event);
-	ieee80211_cqm_rssi_notify(adapter->vifs[0], event, GFP_KERNEL);
+	rsi_dbg(INFO_ZONE, "CQM: Notifying event: %s\n",
+		(event == NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW) ? "LOW" : "HIGH");
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0))
+	ieee80211_cqm_rssi_notify(adapter->vifs[adapter->sc_nvifs - 1],
+				  rssi, event, GFP_KERNEL);
+#else
+	ieee80211_cqm_rssi_notify(adapter->vifs[adapter->sc_nvifs - 1],
+				  event, GFP_KERNEL);
+#endif
+}
+
+void rsi_indicate_bcnmiss(struct rsi_common *common)
+{
+	struct rsi_hw *adapter = common->priv;
+
+	rsi_dbg(INFO_ZONE, "CQM: Notifying beacon miss\n" );
+
+	if (common->iface_down)
+		return;
 
+	ieee80211_beacon_loss(adapter->vifs[0]);
 	return;
 }
 
+struct dot11_ccmp_hdr {
+	u8 pn5;
+	u8 pn4;
+	u8 reserved;
+	u8 keyid_info;
+	u8 pn3;
+	u8 pn2;
+	u8 pn1;
+	u8 pn0;
+};
+struct dot11_tkip_hdr {
+	u8 tsc1;
+	u8 wep_seed;
+	u8 tsc0;
+	u8 keyid_info;
+	u8 tsc2;
+	u8 tsc3;
+	u8 tsc4;
+	u8 tsc5;
+};
+
+int rsi_validate_pn(struct rsi_hw *adapter, struct ieee80211_hdr *hdr)
+{
+	struct ieee80211_vif *vif;
+	struct ieee80211_bss_conf *bss;
+	struct vif_priv *vif_info = NULL;
+	u8 cur_pn[IEEE80211_CCMP_PN_LEN];
+	u8 *last_pn;
+	int i, hdrlen;
+
+	if (!is_broadcast_ether_addr(hdr->addr1) &&
+	    !is_multicast_ether_addr(hdr->addr1))
+		return 1;
+
+	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+	for (i = 0; i < adapter->sc_nvifs; i++) {
+		vif = adapter->vifs[i];
+
+		if (!vif)
+			continue;
+		if ((vif->type != NL80211_IFTYPE_STATION) &&
+		    (vif->type != NL80211_IFTYPE_P2P_CLIENT))
+			continue;
+		bss = &vif->bss_conf;
+		if (!bss->assoc)
+			continue;
+		if (!ether_addr_equal(bss->bssid, hdr->addr2))
+			continue;
+		vif_info = (struct vif_priv *)vif->drv_priv;
+		if (!vif_info->key) {
+			vif_info = NULL;
+			continue;
+		}
+		if (!vif_info->rx_pn_valid) {
+			vif_info = NULL;
+			continue;
+		}
+	}
+	if (!vif_info)
+		return 1;
+	last_pn = vif_info->rx_bcmc_pn;
+	if (vif_info->key->cipher == WLAN_CIPHER_SUITE_CCMP) {
+		struct dot11_ccmp_hdr *ccmp =
+			(struct dot11_ccmp_hdr *)&((u8 *)hdr)[hdrlen];
+
+		cur_pn[0] = ccmp->pn0;
+		cur_pn[1] = ccmp->pn1;
+		cur_pn[2] = ccmp->pn2;
+		cur_pn[3] = ccmp->pn3;
+		cur_pn[4] = ccmp->pn4;
+		cur_pn[5] = ccmp->pn5;
+	} else {
+		struct dot11_tkip_hdr *tkip =
+			(struct dot11_tkip_hdr *)&((u8 *)hdr)[hdrlen];
+
+		cur_pn[0] = tkip->tsc0;
+		cur_pn[1] = tkip->tsc1;
+		cur_pn[2] = tkip->tsc2;
+		cur_pn[3] = tkip->tsc3;
+		cur_pn[4] = tkip->tsc4;
+		cur_pn[5] = tkip->tsc5;
+	}
+	for (i = (IEEE80211_CCMP_PN_LEN - 1); i >= 0; i--)
+		if (last_pn[i] ^ cur_pn[i])
+			break;
+	if (i < 0)
+		return -1;
+
+	if (last_pn[i] >= cur_pn[i])
+		return -1;
+
+	memcpy(vif_info->rx_bcmc_pn, cur_pn, IEEE80211_CCMP_PN_LEN);
+
+	return 0;
+}
+
 /**
  * rsi_fill_rx_status() - This function fills rx status in
  *			  ieee80211_rx_status structure.
@@ -833,12 +1921,14 @@ static void rsi_perform_cqm(struct rsi_common *common,
  *
  * Return: None.
  */
-static void rsi_fill_rx_status(struct ieee80211_hw *hw,
+static int rsi_fill_rx_status(struct ieee80211_hw *hw,
 			       struct sk_buff *skb,
 			       struct rsi_common *common,
 			       struct ieee80211_rx_status *rxs)
 {
-	struct ieee80211_bss_conf *bss = &common->priv->vifs[0]->bss_conf;
+	struct rsi_hw *adapter = common->priv;
+	struct ieee80211_vif *vif = adapter->vifs[adapter->sc_nvifs - 1];
+	struct ieee80211_bss_conf *bss = NULL;
 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
 	struct skb_info *rx_params = (struct skb_info *)info->driver_data;
 	struct ieee80211_hdr *hdr;
@@ -866,25 +1956,43 @@ static void rsi_fill_rx_status(struct ieee80211_hw *hw,
 			memmove(skb->data + 4, skb->data, hdrlen);
 			skb_pull(skb, 4);
 		} else {
-			memmove(skb->data + 8, skb->data, hdrlen);
-			skb_pull(skb, 8);
+			if (skb->len < (hdrlen + IEEE80211_CCMP_HDR_LEN)) {
+				rsi_dbg(ERR_ZONE, "Invalid encrypted packet\n");
+				dev_kfree_skb(skb);
+				return -EINVAL;
+			}
+			if (rsi_validate_pn(adapter, hdr) < 0) {
+				rsi_dbg(INFO_ZONE,
+					"Invalid RX PN; Dropping\n");
+				dev_kfree_skb(skb);
+				return -EINVAL;
+			}
+			memmove(skb->data + IEEE80211_CCMP_HDR_LEN, skb->data,
+				hdrlen);
+			skb_pull(skb, IEEE80211_CCMP_HDR_LEN);
 			rxs->flag |= RX_FLAG_MMIC_STRIPPED;
 		}
 		rxs->flag |= RX_FLAG_DECRYPTED;
 		rxs->flag |= RX_FLAG_IV_STRIPPED;
 	}
 
+	if (!vif) {
+		rsi_dbg(INFO_ZONE, "No virtual interface\n");
+		return 0;
+	}
+	bss = &vif->bss_conf;
+
 	/* CQM only for connected AP beacons, the RSSI is a weighted avg */
-	if (bss->assoc && !(memcmp(bss->bssid, hdr->addr2, ETH_ALEN))) {
+	if ((vif->type == NL80211_IFTYPE_STATION) && bss->assoc &&
+	    ether_addr_equal(bss->bssid, hdr->addr2)) {
 		if (ieee80211_is_beacon(hdr->frame_control))
 			rsi_perform_cqm(common, hdr->addr2, rxs->signal);
 	}
-
-	return;
+	return 0;
 }
 
 /**
- * rsi_indicate_pkt_to_os() - This function sends recieved packet to mac80211.
+ * rsi_indicate_pkt_to_os() - This function sends received packet to mac80211.
  * @common: Pointer to the driver private structure.
  * @skb: Pointer to the socket buffer structure.
  *
@@ -903,51 +2011,15 @@ void rsi_indicate_pkt_to_os(struct rsi_common *common,
 	}
 
 	/* filling in the ieee80211_rx_status flags */
-	rsi_fill_rx_status(hw, skb, common, rx_status);
+	if (rsi_fill_rx_status(hw, skb, common, rx_status))
+		return;
 
+	rsi_dbg(INFO_ZONE, "RX Packet Type: %s\n",
+		dot11_pkt_type(skb->data[0]));
+	rsi_hex_dump(DATA_RX_ZONE, "802.11 RX packet", skb->data, skb->len);
 	ieee80211_rx_irqsafe(hw, skb);
 }
 
-static void rsi_set_min_rate(struct ieee80211_hw *hw,
-			     struct ieee80211_sta *sta,
-			     struct rsi_common *common)
-{
-	u8 band = hw->conf.chandef.chan->band;
-	u8 ii;
-	u32 rate_bitmap;
-	bool matched = false;
-
-	common->bitrate_mask[band] = sta->supp_rates[band];
-
-	rate_bitmap = (common->fixedrate_mask[band] & sta->supp_rates[band]);
-
-	if (rate_bitmap & 0xfff) {
-		/* Find out the min rate */
-		for (ii = 0; ii < ARRAY_SIZE(rsi_rates); ii++) {
-			if (rate_bitmap & BIT(ii)) {
-				common->min_rate = rsi_rates[ii].hw_value;
-				matched = true;
-				break;
-			}
-		}
-	}
-
-	common->vif_info[0].is_ht = sta->ht_cap.ht_supported;
-
-	if ((common->vif_info[0].is_ht) && (rate_bitmap >> 12)) {
-		for (ii = 0; ii < ARRAY_SIZE(rsi_mcsrates); ii++) {
-			if ((rate_bitmap >> 12) & BIT(ii)) {
-				common->min_rate = rsi_mcsrates[ii];
-				matched = true;
-				break;
-			}
-		}
-	}
-
-	if (!matched)
-		common->min_rate = 0xffff;
-}
-
 /**
  * rsi_mac80211_sta_add() - This function notifies driver about a peer getting
  *			    connected.
@@ -963,18 +2035,102 @@ static int rsi_mac80211_sta_add(struct ieee80211_hw *hw,
 {
 	struct rsi_hw *adapter = hw->priv;
 	struct rsi_common *common = adapter->priv;
+	bool sta_exist = 0;
+
+	rsi_hex_dump(INFO_ZONE, "Station Add", sta->addr, ETH_ALEN);
 
 	mutex_lock(&common->mutex);
 
-	rsi_set_min_rate(hw, sta, common);
+	if ((vif->type == NL80211_IFTYPE_AP) ||
+	    (vif->type == NL80211_IFTYPE_P2P_GO)) {
+		u8 i, j;
+		int free_index = -1;
+
+		/* Check if max stations reached */
+		if (common->num_stations >= common->max_stations) {
+			rsi_dbg(ERR_ZONE, "Reject: Max Stations exists\n");
+			mutex_unlock(&common->mutex);
+			return -EOPNOTSUPP;
+		}
+
+		/* Send peer notify to device */
+		rsi_dbg(INFO_ZONE, "Indicate bss status to device\n");
+		for (i = 0; i < common->max_stations; i++) {
+			if (!common->stations[i].sta) {
+				if (free_index < 0)
+					free_index = i;
+				continue; 
+			}
+			if (!memcmp(common->stations[i].sta->addr,
+				    sta->addr, ETH_ALEN)) {
+				rsi_dbg(INFO_ZONE, "Station exists\n");
+				sta_exist = 1;
+				break;
+			}
+		}
+		if (!sta_exist) {
+			rsi_dbg(INFO_ZONE, "New Station\n");
+			if (free_index >= 0)
+				i = free_index;
+			common->stations[i].sta = sta;
+			common->stations[i].sta_id = i;
+			rsi_inform_bss_status(common, AP_OPMODE, 1, sta->addr,
+					      sta->wme, sta->aid, sta, i, 0);
+		
+			if (common->key &&
+			    ((common->key->cipher == WLAN_CIPHER_SUITE_WEP104) ||
+			    (common->key->cipher == WLAN_CIPHER_SUITE_WEP40))) {
+				rsi_load_key(adapter->priv,
+					     common->key->key,
+					     common->key->keylen,
+					     RSI_PAIRWISE_KEY,
+					     common->key->keyidx,
+					     common->key->cipher,
+					     i);
+			}
+			for (j = 0; j < IEEE80211_NUM_ACS; j++)
+				common->stations[i].seq_no[j] = 1;
+			for (j = 0; j < IEEE80211_NUM_TIDS; j++)
+				common->stations[i].start_tx_aggr[j] = false;
+			common->num_stations++;
+		} else {
+			common->stations[i].sta = sta;
+			common->stations[i].sta_id = i;
+			for (j = 0; j < IEEE80211_NUM_ACS; j++)
+				common->stations[i].seq_no[j] = 1;
+			for (j = 0; j < IEEE80211_NUM_TIDS; j++)
+				common->stations[i].start_tx_aggr[j] = false;
+		}
+	}
 
 	if ((sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_20) ||
 	    (sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_40)) {
 		common->vif_info[0].sgi = true;
 	}
+	if (vif->type == NL80211_IFTYPE_STATION) {
+		rsi_set_min_rate(hw, sta, common);
+		if (g_bgscan_enable) {
+			if (!rsi_send_bgscan_params(common, 1)) {
+				if (!rsi_send_bgscan_probe_req(common)) {
+					rsi_dbg(INFO_ZONE,
+						"Bgscan started ===>\n");
+					common->bgscan_en = 1;
+				}
+			}
+		}
+	}
 
-	if (sta->ht_cap.ht_supported)
+	if (((vif->type == NL80211_IFTYPE_STATION) ||
+	     (vif->type == NL80211_IFTYPE_P2P_CLIENT)) &&
+	    (sta->ht_cap.ht_supported)) {
+		common->vif_info[0].is_ht = true;
+		common->bitrate_mask[NL80211_BAND_2GHZ] =
+				sta->supp_rates[NL80211_BAND_2GHZ];
+		if ((sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_20) ||
+		    (sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_40))
+			common->vif_info[0].sgi = true;
 		ieee80211_start_tx_ba_session(sta, 0, 0);
+	}
 
 	mutex_unlock(&common->mutex);
 
@@ -996,28 +2152,694 @@ static int rsi_mac80211_sta_remove(struct ieee80211_hw *hw,
 {
 	struct rsi_hw *adapter = hw->priv;
 	struct rsi_common *common = adapter->priv;
+	struct ieee80211_bss_conf *bss = &vif->bss_conf;
+
+	rsi_hex_dump(INFO_ZONE, "Station Removed", sta->addr, ETH_ALEN);
+
+	mutex_lock(&common->mutex);
+	if ((vif->type == NL80211_IFTYPE_AP) ||
+	    (vif->type == NL80211_IFTYPE_P2P_GO)) {
+		u8 i, j;
+
+		/* Send peer notify to device */
+		rsi_dbg(INFO_ZONE, "Indicate bss status to device\n");
+		for (i = 0; i < common->max_stations; i++) {
+			if (!common->stations[i].sta)
+				continue;
+			if (!memcmp(common->stations[i].sta->addr,
+				    sta->addr, ETH_ALEN)) {
+				rsi_inform_bss_status(common, AP_OPMODE, 0,
+						      sta->addr, sta->wme,
+						      sta->aid, sta, i, 0);
+				common->stations[i].sta = NULL;
+				common->stations[i].sta_id = -1;
+				for (j = 0; j < IEEE80211_NUM_ACS; j++)
+					common->stations[i].seq_no[j] = 0;
+				if (common->num_stations > 0)
+					common->num_stations--;
+				break;
+			}
+		}
+		if (i >= common->max_stations)
+			rsi_dbg(ERR_ZONE, "%s: No station found\n", __func__);
+	}
+
+	if (vif->type == NL80211_IFTYPE_STATION) {
+		/* Resetting all the fields to default values */
+		memcpy((u8 *)bss->bssid, (u8 *)sta->addr, ETH_ALEN);
+		bss->qos = sta->wme;
+		common->bitrate_mask[NL80211_BAND_2GHZ] = 0;
+		common->bitrate_mask[NL80211_BAND_5GHZ] = 0;
+		common->min_rate = 0xffff;
+		common->vif_info[0].is_ht = false;
+		common->vif_info[0].sgi = false;
+		common->vif_info[0].seq_start = 0;
+		common->secinfo.ptk_cipher = 0;
+		common->secinfo.gtk_cipher = 0;
+#ifndef CONFIG_HW_SCAN_OFFLOAD
+		if (common->bgscan_en)
+			common->bgscan_en = 0;
+#endif
+		if (!common->iface_down)
+			rsi_send_rx_filter_frame(common, 0);
+	}
+	mutex_unlock(&common->mutex);
+	return 0;
+}
+
+#ifndef CONFIG_HW_SCAN_OFFLOAD
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(3, 18, 0))
+static void rsi_mac80211_sw_scan_start(struct ieee80211_hw *hw)
+#else
+static void rsi_mac80211_sw_scan_start(struct ieee80211_hw *hw,
+				       struct ieee80211_vif *vif,
+				       const u8 *mac_addr)
+#endif
+{
+	struct rsi_hw *adapter = hw->priv;
+	struct rsi_common *common = adapter->priv;
+	struct ieee80211_bss_conf *bss = &adapter->vifs[0]->bss_conf;
+
+	if (common->fsm_state != FSM_MAC_INIT_DONE)
+		return;
+
+#ifdef CONFIG_RSI_WOW
+	if (common->wow_flags & RSI_WOW_ENABLED)
+		return;
+#endif
+
+	if (common->p2p_enabled)
+		return;
+	if (!bss->assoc)
+		return;
+
+	mutex_lock(&common->mutex);
+
+	if (!rsi_send_bgscan_params(common, 1)) {
+		if (!rsi_send_bgscan_probe_req(common)) {
+			rsi_dbg(INFO_ZONE,
+				"Background scan started\n");
+			common->bgscan_en = 1;
+		}
+	}
+	
+	mutex_unlock(&common->mutex);
+
+	return ;
+}
+
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(3, 18, 0))
+static void rsi_mac80211_sw_scan_stop(struct ieee80211_hw *hw)
+#else
+static void rsi_mac80211_sw_scan_stop(struct ieee80211_hw *hw,
+				      struct ieee80211_vif *vif)
+#endif
+{
+	struct rsi_hw *adapter = hw->priv;
+	struct rsi_common *common = adapter->priv;
+
+	if (common->p2p_enabled)
+		return;
+
+	mutex_lock(&common->mutex);
+	
+	if (common->bgscan_en) {
+		if (!rsi_send_bgscan_params(common, 0)) {
+			common->bgscan_en = 0;
+			rsi_dbg(INFO_ZONE,"Bg scan stopped");
+		}
+	}
+
+	mutex_unlock(&common->mutex);
+
+	return;
+}
+#endif
+
+/**
+ * rsi_mac80211_set_antenna() - This function is used to configure
+ *				tx and rx antennas.
+ * @hw: Pointer to the ieee80211_hw structure.
+ * @tx_ant: Bitmap for tx antenna
+ * @rx_ant: Bitmap for rx antenna
+ *
+ * Return: 0 on success, -1 on failure.
+ */
+static int rsi_mac80211_set_antenna(struct ieee80211_hw *hw,
+				    u32 tx_ant, u32 rx_ant)
+{
+	struct rsi_hw *adapter = hw->priv;
+	struct rsi_common *common = adapter->priv;
+	u32 antenna = 0;
+
+	if (tx_ant > 1 || rx_ant > 1) {
+		rsi_dbg(ERR_ZONE,
+			"Invalid antenna selection (tx: %d, rx:%d)\n",
+			tx_ant, rx_ant);
+		rsi_dbg(ERR_ZONE,
+			"Use 0 for int_ant, 1 for ext_ant\n");
+		return -EINVAL; 
+	}
+
+	rsi_dbg(INFO_ZONE, "%s: Antenna map Tx %x Rx %d\n",
+			__func__, tx_ant, rx_ant);
+
+	mutex_lock(&common->mutex);
+
+	antenna = tx_ant ? ANTENNA_SEL_UFL : ANTENNA_SEL_INT;
+	if (common->ant_in_use != antenna)
+		if (rsi_set_antenna(common, antenna))
+			goto fail_set_antenna;
+
+	rsi_dbg(INFO_ZONE, "(%s) Antenna path configured successfully\n",
+		tx_ant ? "UFL" : "INT");
+
+	common->ant_in_use = antenna;
+	
+	mutex_unlock(&common->mutex);
+	
+	return 0;
+
+fail_set_antenna:
+	rsi_dbg(ERR_ZONE, "%s: Failed.\n", __func__);
+	mutex_unlock(&common->mutex);
+	return -EINVAL;
+}
+
+/**
+ * rsi_mac80211_get_antenna() - This function is used to configure 
+ * 				tx and rx antennas.
+ *
+ * @hw: Pointer to the ieee80211_hw structure.
+ * @tx_ant: Bitmap for tx antenna
+ * @rx_ant: Bitmap for rx antenna
+ * 
+ * Return: 0 on success, -1 on failure.
+ */
+static int rsi_mac80211_get_antenna(struct ieee80211_hw *hw,
+				    u32 *tx_ant, u32 *rx_ant)
+{
+	struct rsi_hw *adapter = hw->priv;
+	struct rsi_common *common = adapter->priv;
+
+	mutex_lock(&common->mutex);
+
+	*tx_ant = (common->ant_in_use == ANTENNA_SEL_UFL) ? 1 : 0;
+	*rx_ant = 0;
+
+	mutex_unlock(&common->mutex);
+	
+	return 0;	
+}
+
+static const char *regdfs_region_str(u8 dfs_region)
+{
+        switch (dfs_region) {
+        case NL80211_DFS_UNSET:
+                return "unset";
+        case NL80211_DFS_FCC:
+                return "FCC";
+        case NL80211_DFS_ETSI:
+                return "ETSI";
+        case NL80211_DFS_JP:
+                return "JP";
+	case NL80211_DFS_WORLD:
+		return "WORLD";
+        }
+        return "Unknown";
+}
+
+static void rsi_reg_notify(struct wiphy *wiphy,
+			   struct regulatory_request *request)
+{
+	struct ieee80211_supported_band *sband;
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct rsi_hw * adapter = hw->priv; 
+	struct rsi_common *common = adapter->priv;
+	struct ieee80211_channel *ch;
+#ifdef CONFIG_CARACALLA_BOARD
+	struct ieee80211_vif *vif = adapter->vifs[adapter->sc_nvifs -1];
+#endif
+	int i;
+	u8 region_code;
+
+	mutex_lock(&common->mutex);
+
+	rsi_dbg(INFO_ZONE,
+		"%s: country = %s dfs_region = %s\n",
+		__func__, request->alpha2,
+		regdfs_region_str(request->dfs_region));
+
+	region_code = request->dfs_region;
+#ifdef CONFIG_CARACALLA_BOARD
+	for (i = 0; i < ARRAY_SIZE(rsi_caracalla_reg_db); i++) {
+		if (!memcmp(rsi_caracalla_reg_db[i].country_code,
+		            request->alpha2, 2)) {
+			region_code = rsi_caracalla_reg_db[i].region_code;
+			break;
+		}
+	}
+	if (!memcmp(request->alpha2, "00", 2))
+		region_code = NL80211_DFS_JP;
+
+	rsi_dbg(ERR_ZONE, "%s: Updating regulatory for region %s\n",
+		__func__, regdfs_region_str(region_code));
+#endif
+
+#ifdef CONFIG_CARACALLA_BOARD
+	sband = wiphy->bands[NL80211_BAND_2GHZ];
+	for (i = 0; i < sband->n_channels; i++) {
+		ch = &sband->channels[i];
+
+		if ((region_code == NL80211_DFS_FCC) &&
+		    (ch->hw_value == 12 || ch->hw_value == 13)) {
+			if (ch->flags & IEEE80211_CHAN_DISABLED)
+				ch->flags &= ~IEEE80211_CHAN_DISABLED;
+			if (ch->flags & IEEE80211_CHAN_NO_IR)
+				ch->flags &= ~IEEE80211_CHAN_NO_IR;
+		}
+		if ((ch->flags & IEEE80211_CHAN_DISABLED) ||
+		    (ch->flags & IEEE80211_CHAN_NO_IR))
+			continue;
+		
+		rsi_apply_carcalla_power_values(adapter, vif, ch);
+	}
+#endif
+
+	if (common->num_supp_bands > 1) {
+		sband = wiphy->bands[NL80211_BAND_5GHZ];
+
+		for (i = 0; i < sband->n_channels; i++) {
+			ch = &sband->channels[i];
+			if (ch->flags & IEEE80211_CHAN_DISABLED)
+				continue;
+
+			if (ch->flags & IEEE80211_CHAN_RADAR)
+				ch->flags |= IEEE80211_CHAN_NO_IR;
+		}
+	}
+
+#ifndef CONFIG_HW_SCAN_OFFLOAD 
+	/* If DFS region or country is changed configure back ground scan
+	 * params to device again */
+	if ((adapter->dfs_region != region_code) ||
+	    (memcmp(adapter->country, request->alpha2, 2))) {
+		if (common->bgscan_en) {
+			rsi_send_bgscan_params(common, 0);
+			common->bgscan_en = 0;
+			mdelay(10);
+			rsi_send_bgscan_params(common, 1);
+			common->bgscan_en = 1;
+		}
+	}
+#endif
+
+	if (region_code == NL80211_DFS_UNSET)
+		region_code = NL80211_DFS_WORLD;
+
+	/* Firmware region code values 1 less than the standard
+	 * linux values; At this point DFS_UNSET is not set
+	 * as this is set to WORLD (4)
+	 */
+	adapter->dfs_region = region_code - 1;
+	adapter->country[0] = request->alpha2[0];
+	adapter->country[1] = request->alpha2[1];
+
+	mutex_unlock(&common->mutex);
+}
+
+static void rsi_mac80211_rfkill_poll(struct ieee80211_hw *hw)
+{
+	struct rsi_hw *adapter = hw->priv;
+	struct rsi_common *common = adapter->priv;
+	
+	mutex_lock(&common->mutex);
+
+	if (common->fsm_state != FSM_MAC_INIT_DONE)
+		wiphy_rfkill_set_hw_state(hw->wiphy, true);
+	else
+		wiphy_rfkill_set_hw_state(hw->wiphy, false);
+
+	mutex_unlock(&common->mutex);
+}
+
+#ifdef CONFIG_RSI_WOW
+static const struct wiphy_wowlan_support rsi_wowlan_support = {
+	.flags = WIPHY_WOWLAN_ANY |
+		 WIPHY_WOWLAN_MAGIC_PKT |
+		 WIPHY_WOWLAN_DISCONNECT |
+		 WIPHY_WOWLAN_GTK_REKEY_FAILURE  |
+		 WIPHY_WOWLAN_SUPPORTS_GTK_REKEY |
+		 WIPHY_WOWLAN_EAP_IDENTITY_REQ   |
+		 WIPHY_WOWLAN_4WAY_HANDSHAKE,
+	.n_patterns = 0,
+	.pattern_min_len = 1,
+	.pattern_max_len = 0,
+};
+
+static u16 rsi_wow_map_triggers(struct rsi_common *common,
+				struct cfg80211_wowlan *wowlan)
+{
+	u16 wow_triggers = 0;
+
+        rsi_dbg(INFO_ZONE,"Mapping wowlan triggers\n");
+
+	if (wowlan->any)
+		wow_triggers |= RSI_WOW_ANY;
+	if (wowlan->magic_pkt)
+		wow_triggers |= RSI_WOW_MAGIC_PKT;
+	if (wowlan->disconnect)
+		wow_triggers |= RSI_WOW_DISCONNECT;
+	if (wowlan->gtk_rekey_failure || wowlan->eap_identity_req ||
+	    wowlan->four_way_handshake)
+		wow_triggers |= RSI_WOW_GTK_REKEY;
+	
+	return wow_triggers;
+}
+#endif
+
+#ifdef CONFIG_RSI_WOW
+int rsi_config_wowlan(struct rsi_hw *adapter, struct cfg80211_wowlan *wowlan)
+{
+	struct rsi_common *common = adapter->priv;
+	u16 triggers = 0;
+       	u16 rx_filter_word = 0;
+	struct ieee80211_bss_conf *bss = &adapter->vifs[0]->bss_conf;
+
+	rsi_dbg(INFO_ZONE, "Config WoWLAN to device\n");
+
+	if (WARN_ON(!wowlan)) {
+		rsi_dbg(ERR_ZONE, "WoW triggers not enabled\n");
+		return -EINVAL;
+	}
+
+	triggers = rsi_wow_map_triggers(common, wowlan);
+	if (!triggers) {
+		rsi_dbg(ERR_ZONE, "%s:No valid WoW triggers\n",__func__);
+		return -EINVAL;
+	}
+	if (!bss->assoc) {
+		rsi_dbg(ERR_ZONE,
+			"Cannot configure WoWLAN (Station not connected)\n");
+		common->wow_flags |= RSI_WOW_NO_CONNECTION;
+		return 0;
+	}
+	rsi_dbg(INFO_ZONE, "TRIGGERS %x\n", triggers);
+	rsi_send_wowlan_request(common, triggers, 1);
+
+	/* Send updated vap caps */
+	rsi_send_vap_dynamic_update(common);
+
+	rx_filter_word = (ALLOW_DATA_ASSOC_PEER |
+			  DISALLOW_BEACONS |
+			  0);
+	rsi_send_rx_filter_frame(common, rx_filter_word);
+
+        common->wow_flags |= RSI_WOW_ENABLED;
+        
+	return 0;
+}
+EXPORT_SYMBOL_GPL(rsi_config_wowlan);
+#endif
+
+#ifdef CONFIG_PM
+static int rsi_mac80211_suspend(struct ieee80211_hw *hw,
+				struct cfg80211_wowlan *wowlan)
+{
+#ifdef CONFIG_RSI_WOW
+	struct rsi_hw *adapter = hw->priv;
+	struct rsi_common *common = adapter->priv;
+
+	mutex_lock(&common->mutex);
+	if (common->coex_mode > 1) {
+		rsi_disable_ps(adapter);
+		rsi_reset_event(&common->mgmt_cfm_event);
+		rsi_wait_event(&common->mgmt_cfm_event,
+			       msecs_to_jiffies(1000));
+
+	}
+
+	if (rsi_config_wowlan(adapter, wowlan)) {
+		rsi_dbg(ERR_ZONE, "Failed to configure WoWLAN\n");
+		mutex_unlock(&common->mutex);
+		return 1;
+	}
+	/* Cancel back ground scan in suspend */
+	if (common->bgscan_en) {
+		if (!rsi_send_bgscan_params(common, 0)) {
+			common->bgscan_en = 0;
+			rsi_dbg(INFO_ZONE,"Bg scan canceled");
+		}
+	}
+	mutex_unlock(&common->mutex);
+#endif
+
+	return 0;
+}
+
+static int rsi_mac80211_resume(struct ieee80211_hw *hw)
+{
+	struct rsi_hw *adapter = hw->priv;
+	struct rsi_common *common = adapter->priv;
+#ifdef CONFIG_RSI_WOW
+	u16 rx_filter_word = 0;
+        
+	adapter->priv->wow_flags = 0;
+#endif
+	
+	rsi_dbg(INFO_ZONE, "%s: mac80211 resume\n", __func__);
+
+	if (common->hibernate_resume) {
+		if (common->reinit_hw)
+			wait_for_completion(&common->wlan_init_completion);
+		return 0;
+	}
 
+#ifdef CONFIG_RSI_WOW
 	mutex_lock(&common->mutex);
-	/* Resetting all the fields to default values */
-	common->bitrate_mask[NL80211_BAND_2GHZ] = 0;
-	common->bitrate_mask[NL80211_BAND_5GHZ] = 0;
-	common->min_rate = 0xffff;
-	common->vif_info[0].is_ht = false;
-	common->vif_info[0].sgi = false;
-	common->vif_info[0].seq_start = 0;
-	common->secinfo.ptk_cipher = 0;
-	common->secinfo.gtk_cipher = 0;
+	rsi_send_wowlan_request(common, 0, 0);
+
+	rx_filter_word = (ALLOW_DATA_ASSOC_PEER |
+			  ALLOW_CTRL_ASSOC_PEER |
+			  ALLOW_MGMT_ASSOC_PEER |
+			  0);
+	rsi_send_rx_filter_frame(common, rx_filter_word);
 	mutex_unlock(&common->mutex);
+#endif
+
+	return 0;
+}
+#endif
+
+char *rsi_vif_type_to_name(enum nl80211_iftype vif_type)
+{
+	switch (vif_type) {
+	case NL80211_IFTYPE_STATION:
+		return "Station";
+		break;
+	case NL80211_IFTYPE_AP:
+		return "AP";
+		break;
+	case NL80211_IFTYPE_P2P_DEVICE:
+		return "P2P_Device";
+		break;
+	case NL80211_IFTYPE_P2P_CLIENT:
+		return "P2P_Client";
+		break;
+	case NL80211_IFTYPE_P2P_GO:
+		return "P2P_GO";
+		break;
+	default:
+		return "Unknown";
+		break;
+	}
+	return "Unknown";
+}
+
+static enum opmode rsi_map_vif_type(enum nl80211_iftype vif_type)
+{
+	switch (vif_type) {
+	case NL80211_IFTYPE_STATION:
+		return STA_OPMODE;
+		break;
+	case NL80211_IFTYPE_AP:
+		return AP_OPMODE;
+		break;
+	case NL80211_IFTYPE_P2P_DEVICE:
+		return STA_OPMODE;
+		break;
+	case NL80211_IFTYPE_P2P_CLIENT:
+		return P2P_CLIENT_OPMODE;
+		break;
+	case NL80211_IFTYPE_P2P_GO:
+		return P2P_GO_OPMODE;
+		break;
+	default:
+		return UNKNOW_OPMODE;
+	}
+	return UNKNOW_OPMODE;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION (4, 15, 0)
+void rsi_roc_timeout(unsigned long data)
+{
+	struct rsi_common *common = (struct rsi_common *)data;
+#else
+void rsi_roc_timeout(struct timer_list *t)
+{
+	struct rsi_common *common = from_timer(common, t, roc_timer);
+#endif
+	struct ieee80211_vif *vif = common->roc_vif;
+	struct vif_priv *vif_info = (struct vif_priv *)vif->drv_priv;
+	enum opmode intf_mode; 
+
+	rsi_dbg(INFO_ZONE, "Remain on channel expired\n");	
+	
+	mutex_lock(&common->mutex);
+	
+	ieee80211_remain_on_channel_expired(common->priv->hw);
+	
+	if (timer_pending(&common->roc_timer))
+		del_timer(&common->roc_timer);
+
+	if ((vif->type == NL80211_IFTYPE_STATION) ||
+	    (vif->type == NL80211_IFTYPE_AP) ||
+	    (vif->type == NL80211_IFTYPE_P2P_GO)) {
+		rsi_dbg(INFO_ZONE, "Resume to connected channel\n");
+		rsi_resume_conn_channel(common->priv, vif);
+	}
+
+	intf_mode = rsi_map_vif_type(vif->type);
+	if ((common->last_vap_type != intf_mode) ||
+	    (!ether_addr_equal(common->last_vap_addr, vif->addr))) {
+		rsi_dbg(INFO_ZONE, "Resume the vap caps to orig mode\n");	
+		if (rsi_set_vap_capabilities(common, intf_mode,
+					     vif->addr,
+					     vif_info->vap_id,
+					     VAP_UPDATE))
+			rsi_dbg(ERR_ZONE, "Failed to update VAP caps\n");
+	}
+
+	mutex_unlock(&common->mutex);
+}
+
+static int rsi_mac80211_cancel_roc(struct ieee80211_hw *hw)
+{
+	struct rsi_hw *adapter = hw->priv;
+	struct rsi_common *common = adapter->priv;
+	struct ieee80211_vif *vif = common->roc_vif;
+	struct vif_priv *vif_info = (struct vif_priv *)vif->drv_priv;
+	enum opmode intf_mode; 
+	
+	rsi_dbg(INFO_ZONE, "Cancel remain on channel\n");
+
+	mutex_lock(&common->mutex);
+	if (!timer_pending(&adapter->priv->roc_timer))
+		return 0;
+
+	if (timer_pending(&adapter->priv->roc_timer))
+		del_timer(&adapter->priv->roc_timer);
+
+	if ((vif->type == NL80211_IFTYPE_STATION) ||
+	    (vif->type == NL80211_IFTYPE_AP) ||
+	    (vif->type == NL80211_IFTYPE_P2P_GO)) {
+		rsi_dbg(INFO_ZONE, "Resume to connected channel\n");
+		rsi_resume_conn_channel(adapter, vif);
+	}
 
+	intf_mode = rsi_map_vif_type(vif->type);
+	if ((common->last_vap_type != intf_mode) ||
+	    (!ether_addr_equal(common->last_vap_addr, vif->addr))) {
+		rsi_dbg(INFO_ZONE, "Resume the vap caps to orig mode\n");
+		if (rsi_set_vap_capabilities(common, intf_mode,
+					     vif->addr, vif_info->vap_id,
+					     VAP_UPDATE))
+			rsi_dbg(ERR_ZONE, "Failed to update VAP caps\n");
+	}
+
+	mutex_unlock(&common->mutex);
+	
 	return 0;
 }
 
+static int rsi_mac80211_roc(struct ieee80211_hw *hw,
+			    struct ieee80211_vif *vif,
+			    struct ieee80211_channel *chan,
+			    int duration,
+			    enum ieee80211_roc_type type)
+{
+	struct vif_priv *vif_info = (struct vif_priv *)vif->drv_priv;
+	struct rsi_hw *adapter = (struct rsi_hw *)hw->priv;
+	struct rsi_common *common = (struct rsi_common *)adapter->priv;
+	int status = 0;
+
+	rsi_dbg(INFO_ZONE, "***** Remain on channel *****\n");
+
+	if (common->priv->sc_nvifs <= 0) {
+		rsi_dbg(ERR_ZONE,
+			"%s: No virtual interface found\n", __func__);
+		return -EINVAL;
+	}
+
+	mutex_lock(&common->mutex);
+
+	rsi_dbg(INFO_ZONE,
+		"%s: channel_no: %d duration: %dms\n",
+		__func__, chan->hw_value, duration);
+
+	if (timer_pending(&common->roc_timer)) {
+		rsi_dbg(INFO_ZONE, "Stop on-going ROC\n");
+		del_timer(&common->roc_timer);
+	}
+	common->roc_timer.expires = msecs_to_jiffies(duration) + jiffies;
+        add_timer(&common->roc_timer);	
+
+	/* Configure band */
+	if (rsi_band_check(common, chan)) {
+		rsi_dbg(ERR_ZONE, "Failed to set band\n");
+		status = -EINVAL;
+		goto out;
+	}
+
+	/* Configure channel */
+	if (rsi_set_channel(common, chan)) {
+		rsi_dbg(ERR_ZONE, "Failed to set the channel\n");
+		status = -EINVAL;
+		goto out;
+	}
+
+	/* For listen phase, configure vap as AP mode */
+	if (vif->type == NL80211_IFTYPE_P2P_DEVICE) {
+		rsi_dbg(INFO_ZONE, "Update VAP mode to p2p_client mode\n");	
+		if (rsi_set_vap_capabilities(common, P2P_CLIENT_OPMODE,
+					     vif->addr, vif_info->vap_id,
+					     VAP_UPDATE)) {
+			rsi_dbg(ERR_ZONE,
+				"Failed to update VAP capabilities\n");
+			goto out;
+		}
+	}
+
+	common->roc_vif = vif;
+	ieee80211_ready_on_channel(hw);
+	rsi_dbg(INFO_ZONE, "%s: Ready on channel :%d\n",
+		__func__, chan->hw_value);	
+
+out:
+	mutex_unlock(&common->mutex);
+
+	return status;
+}
+
+
+
 static struct ieee80211_ops mac80211_ops = {
 	.tx = rsi_mac80211_tx,
 	.start = rsi_mac80211_start,
 	.stop = rsi_mac80211_stop,
 	.add_interface = rsi_mac80211_add_interface,
 	.remove_interface = rsi_mac80211_remove_interface,
+	.change_interface = rsi_mac80211_change_interface,
 	.config = rsi_mac80211_config,
 	.bss_info_changed = rsi_mac80211_bss_info_changed,
 	.conf_tx = rsi_mac80211_conf_tx,
@@ -1028,6 +2850,22 @@ static int rsi_mac80211_sta_remove(struct ieee80211_hw *hw,
 	.ampdu_action = rsi_mac80211_ampdu_action,
 	.sta_add = rsi_mac80211_sta_add,
 	.sta_remove = rsi_mac80211_sta_remove,
+	.set_antenna = rsi_mac80211_set_antenna,
+	.get_antenna = rsi_mac80211_get_antenna,
+        .rfkill_poll = rsi_mac80211_rfkill_poll,
+#ifdef CONFIG_PM 
+	.suspend = rsi_mac80211_suspend,
+	.resume  = rsi_mac80211_resume,
+#endif
+#ifdef CONFIG_HW_SCAN_OFFLOAD
+	.hw_scan          = rsi_mac80211_hw_scan_start,
+	.cancel_hw_scan   = rsi_mac80211_hw_scan_cancel, 
+#else
+	.sw_scan_start = rsi_mac80211_sw_scan_start,
+	.sw_scan_complete = rsi_mac80211_sw_scan_stop,
+#endif
+	.remain_on_channel = rsi_mac80211_roc,
+	.cancel_remain_on_channel = rsi_mac80211_cancel_roc,
 };
 
 /**
@@ -1059,42 +2897,118 @@ int rsi_mac80211_attach(struct rsi_common *common)
 	hw->priv = adapter;
 	adapter->hw = hw;
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 2, 0))
 	ieee80211_hw_set(hw, SIGNAL_DBM);
 	ieee80211_hw_set(hw, HAS_RATE_CONTROL);
 	ieee80211_hw_set(hw, AMPDU_AGGREGATION);
+	ieee80211_hw_set(hw, SUPPORTS_PS);
+	ieee80211_hw_set(hw, SUPPORTS_DYNAMIC_PS);
+//	ieee80211_hw_set(hw, CONNECTION_MONITOR);
+	ieee80211_hw_set(hw, SPECTRUM_MGMT);
+	ieee80211_hw_set(hw, MFP_CAPABLE);
+#else
+	hw->flags = IEEE80211_HW_SIGNAL_DBM |
+		    IEEE80211_HW_HAS_RATE_CONTROL |
+		    IEEE80211_HW_AMPDU_AGGREGATION |
+		    IEEE80211_HW_SUPPORTS_PS |
+		    IEEE80211_HW_SUPPORTS_DYNAMIC_PS |
+	//	    IEEE80211_HW_CONNECTION_MONITOR |
+		    IEEE80211_HW_SPECTRUM_MGMT |
+		    IEEE80211_HW_MFP_CAPABLE |
+		    0;
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0))
+	wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_RRM);
+#endif
 
 	hw->queues = MAX_HW_QUEUES;
 	hw->extra_tx_headroom = RSI_NEEDED_HEADROOM;
 
 	hw->max_rates = 1;
 	hw->max_rate_tries = MAX_RETRIES;
+	hw->uapsd_queues = IEEE80211_MARKALL_UAPSD_QUEUES;
+	hw->uapsd_max_sp_len = IEEE80211_WMM_IE_STA_QOSINFO_SP_ALL;
+	hw->max_tx_aggregation_subframes = 8;
+	hw->max_rx_aggregation_subframes = 8;
 
-	hw->max_tx_aggregation_subframes = 6;
 	rsi_register_rates_channels(adapter, NL80211_BAND_2GHZ);
-	rsi_register_rates_channels(adapter, NL80211_BAND_5GHZ);
+	wiphy->bands[NL80211_BAND_2GHZ] =
+		&adapter->sbands[NL80211_BAND_2GHZ];
+	if (common->num_supp_bands > 1) {
+		rsi_register_rates_channels(adapter, NL80211_BAND_5GHZ);
+		wiphy->bands[NL80211_BAND_5GHZ] =
+			&adapter->sbands[NL80211_BAND_5GHZ];
+	}
 	hw->rate_control_algorithm = "AARF";
+	hw->sta_data_size = sizeof(struct rsi_sta);
+	hw->vif_data_size = sizeof(struct vif_priv);
 
 	SET_IEEE80211_PERM_ADDR(hw, common->mac_addr);
 	ether_addr_copy(hw->wiphy->addr_mask, addr_mask);
 
-	wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION);
+	if (common->coex_mode == 4) {
+		  wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |
+			  		   BIT(NL80211_IFTYPE_AP);
+	} else if (common->coex_mode == 2) {
+		  wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION);
+	} else {
+		  wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |
+			  		   BIT(NL80211_IFTYPE_AP) |
+					   BIT(NL80211_IFTYPE_P2P_DEVICE) |
+					   BIT(NL80211_IFTYPE_P2P_CLIENT) |
+					   BIT(NL80211_IFTYPE_P2P_GO);
+	}
 	wiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;
 	wiphy->retry_short = RETRY_SHORT;
 	wiphy->retry_long  = RETRY_LONG;
 	wiphy->frag_threshold = IEEE80211_MAX_FRAG_THRESHOLD;
 	wiphy->rts_threshold = IEEE80211_MAX_RTS_THRESHOLD;
-	wiphy->flags = 0;
-
-	wiphy->available_antennas_rx = 1;
 	wiphy->available_antennas_tx = 1;
-	wiphy->bands[NL80211_BAND_2GHZ] =
-		&adapter->sbands[NL80211_BAND_2GHZ];
-	wiphy->bands[NL80211_BAND_5GHZ] =
-		&adapter->sbands[NL80211_BAND_5GHZ];
+	wiphy->available_antennas_rx = 1;
+
+	wiphy->max_ap_assoc_sta = rsi_max_ap_stas[common->oper_mode - 1];
+	common->max_stations = wiphy->max_ap_assoc_sta;
+	rsi_dbg(ERR_ZONE, "Max Stations Allowed = %d\n", common->max_stations);
+
+	wiphy->max_scan_ssids = 16;
+#ifdef CONFIG_HW_SCAN_OFFLOAD
+	wiphy->max_scan_ie_len = 256;
+#endif	
+	/* AP Parameters */
+	wiphy->flags = WIPHY_FLAG_REPORTS_OBSS;
+	wiphy->flags |= WIPHY_FLAG_AP_UAPSD;
+	wiphy->features |= NL80211_FEATURE_INACTIVITY_TIMER;
+
+	/*wiphy->regulatory_flags = (REGULATORY_STRICT_REG |
+				   REGULATORY_CUSTOM_REG);
+	wiphy_apply_custom_regulatory(wiphy,&rsi_regdom);*/
+	wiphy->reg_notifier = rsi_reg_notify;
+
+#ifdef CONFIG_RSI_WOW
+	wiphy->wowlan = &rsi_wowlan_support;
+#endif
+
+#ifdef CONFIG_RSI_P2P
+	/* Wi-Fi direct related parameters */
+	wiphy->flags |= WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;
+	wiphy->flags |= WIPHY_FLAG_OFFCHAN_TX;
+	wiphy->max_remain_on_channel_duration = 10000;
+	hw->max_listen_interval = 10;
+	wiphy->iface_combinations = rsi_iface_combinations;
+	wiphy->n_iface_combinations = ARRAY_SIZE(rsi_iface_combinations);
+//	wiphy->features |= (NL80211_FEATURE_P2P_GO_CTWIN |
+//			    NL80211_FEATURE_P2P_GO_OPPPS);
+#endif
+
+	if (common->coex_mode > 1)
+		wiphy->flags |= WIPHY_FLAG_PS_ON_BY_DEFAULT;
 
 	status = ieee80211_register_hw(hw);
-	if (status)
+	if (status) {
+		rsi_dbg(ERR_ZONE, "Failed to register to mac80211\n");
 		return status;
+	}
 
 	return rsi_init_dbgfs(adapter);
 }
diff --git a/drivers/net/wireless/rsi/rsi_91x_main.c b/drivers/net/wireless/rsi/rsi_91x_main.c
index 8810862..1c01c5e 100644
--- a/drivers/net/wireless/rsi/rsi_91x_main.c
+++ b/drivers/net/wireless/rsi/rsi_91x_main.c
@@ -1,17 +1,31 @@
-/**
- * Copyright (c) 2014 Redpine Signals Inc.
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
+ *
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
  *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
  *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
@@ -20,18 +34,74 @@
 #include <linux/firmware.h>
 #include "rsi_mgmt.h"
 #include "rsi_common.h"
-
-u32 rsi_zone_enabled = /* INFO_ZONE |
+#include "rsi_hal.h"
+#if defined(CONFIG_RSI_BT_ALONE) || defined(CONFIG_RSI_COEX)
+#include "rsi_hci.h"
+#endif
+#ifdef CONFIG_RSI_COEX
+#include "rsi_coex.h"
+#endif
+
+u16 rsi_zone_enabled =	INFO_ZONE |
 			INIT_ZONE |
 			MGMT_TX_ZONE |
 			MGMT_RX_ZONE |
-			DATA_TX_ZONE |
-			DATA_RX_ZONE |
-			FSM_ZONE |
-			ISR_ZONE | */
+			//DATA_TX_ZONE |
+			//DATA_RX_ZONE |
+			//FSM_ZONE |
+			//ISR_ZONE |
 			ERR_ZONE |
 			0;
-EXPORT_SYMBOL_GPL(rsi_zone_enabled);
+module_param(rsi_zone_enabled, ushort, S_IRUGO);
+MODULE_PARM_DESC(rsi_zone_enabled,
+		 "BIT(0) - ERROR ZONE \
+		  BIT(1) - INFO ZONE \
+		  BIT(2) - INIT ZONE \
+		  BIT(3) - MGMT TX ZONE \
+		  BIT(4) - MGMT RX ZONE \
+		  BIT(5) - DATA TX ZONE \
+		  BIT(6) - DATA RX ZONE \
+		  BIT(7) - FSM ZONE \
+		  BIT(8) - ISR ZONE");
+
+/* Default operating mode is Wi-Fi alone */
+int dev_oper_mode_count;
+#ifdef CONFIG_CARACALLA_BOARD
+#if defined (CONFIG_RSI_COEX) || defined(CONFIG_RSI_BT_ALONE)
+u16 dev_oper_mode[5] = {DEV_OPMODE_STA_BT_DUAL,
+						0xff, 0xff, 0xff, 0xff};
+#else
+u16 dev_oper_mode[5] = {DEV_OPMODE_WIFI_ALONE,
+						0xff, 0xff, 0xff, 0xff};
+#endif
+#else
+u16 dev_oper_mode[5] = {DEV_OPMODE_WIFI_ALONE,
+						0xff, 0xff, 0xff, 0xff};
+#endif
+
+module_param_array(dev_oper_mode, ushort, &dev_oper_mode_count, S_IRUGO);
+MODULE_PARM_DESC(dev_oper_mode,
+		 "1 -	Wi-Fi Alone \
+		  4 -	BT Alone \
+		  8 -	BT LE Alone \
+		  5 -	Wi-Fi STA + BT classic \
+		  9 -	Wi-Fi STA + BT LE \
+		  13 -	Wi-Fi STA + BT classic + BT LE \
+		  6 -	AP + BT classic \
+		  14 -	AP + BT classic + BT LE \
+		  16 -	ZIGB ALONE  \
+		  17 -	Wi-Fi STA + ZIGB  \
+		  32 -	ZIGB COORDINATOR  \
+		  48 -	ZIGB ROUTER");
+
+#if defined(CONFIG_RSI_COEX) && defined(CONFIG_RSI_ZIGB)
+static struct rsi_proto_ops g_proto_ops = {
+	.coex_send_pkt = rsi_coex_send_pkt,
+	.get_host_intf = rsi_get_host_intf,
+	.set_zb_context = rsi_set_zb_context,
+	.get_zb_context = rsi_get_zb_context,
+};
+#endif
 
 /**
  * rsi_dbg() - This function outputs informational messages.
@@ -57,6 +127,82 @@ void rsi_dbg(u32 zone, const char *fmt, ...)
 EXPORT_SYMBOL_GPL(rsi_dbg);
 
 /**
+ * rsi_hex_dump() - This function prints the packet (/msg) in hex bytes.
+ * @zone: Zone of interest for output message.
+ * @msg_str: Message to be printed with packet
+ * @msg: Packet to be printed
+ * @len: Length of the packet
+ *
+ * Return: none
+ */
+void rsi_hex_dump(u32 zone, char *msg_str, const u8 *msg, u32 len)
+{
+	int ii;
+
+	if (!(zone & rsi_zone_enabled))
+		return;
+	printk("%s: (length = %d)\n", msg_str, len);
+	for (ii = 0; ii < len; ii++) {
+		if (ii && !(ii % 16))
+			printk("\n");
+		printk("%02x ", msg[ii]);
+	}
+	printk("\n");
+}
+EXPORT_SYMBOL_GPL(rsi_hex_dump);
+
+static char *opmode_str(int oper_mode)
+{
+	switch (oper_mode) {
+	case DEV_OPMODE_WIFI_ALONE:
+	       return "Wi-Fi alone";
+	case DEV_OPMODE_BT_ALONE:
+	       return "BT EDR alone";
+	case DEV_OPMODE_BT_LE_ALONE:
+	       return "BT LE alone";
+	case DEV_OPMODE_BT_DUAL:
+	       return "BT Dual";
+	case DEV_OPMODE_STA_BT:
+	       return "Wi-Fi STA + BT EDR";
+	case DEV_OPMODE_STA_BT_LE:
+	       return "Wi-Fi STA + BT LE";
+	case DEV_OPMODE_STA_BT_DUAL:
+	       return "Wi-Fi STA + BT DUAL";
+	case DEV_OPMODE_AP_BT:
+	       return "Wi-Fi AP + BT EDR";
+	case DEV_OPMODE_AP_BT_DUAL:
+	       return "Wi-Fi AP + BT DUAL";
+	case DEV_OPMODE_ZB_ALONE:
+	       return "ZIGB alone";
+	case DEV_OPMODE_STA_ZB:
+	       return "Wi-Fi STA + ZIGB STA";
+	case DEV_OPMODE_ZB_COORDINATOR:
+	       return "Wi-Fi STA + ZIGB Coordinator";
+	case DEV_OPMODE_ZB_ROUTER:
+	       return "Wi-Fi STA + ZIBG Router";
+	}
+	return "Unknown";
+}
+
+void rsi_print_version(struct rsi_common *common)
+{
+	memcpy(common->driver_ver, DRV_VER, ARRAY_SIZE(DRV_VER));
+	common->driver_ver[ARRAY_SIZE(DRV_VER)] = '\0';
+
+	rsi_dbg(ERR_ZONE, "================================================\n");
+	rsi_dbg(ERR_ZONE, "================ RSI Version Info ==============\n");
+	rsi_dbg(ERR_ZONE, "================================================\n");
+	rsi_dbg(ERR_ZONE, "FW Version\t: %d.%d.%d\n",
+		common->lmac_ver.major, common->lmac_ver.minor,
+		common->lmac_ver.release_num);
+	rsi_dbg(ERR_ZONE, "Driver Version\t: %s", common->driver_ver);
+	rsi_dbg(ERR_ZONE, "Operating mode\t: %d [%s]",
+		common->oper_mode, opmode_str(common->oper_mode));
+	rsi_dbg(ERR_ZONE, "Firmware file\t: %s", common->priv->fw_file_name);
+	rsi_dbg(ERR_ZONE, "================================================\n");
+}
+
+/**
  * rsi_prepare_skb() - This function prepares the skb.
  * @common: Pointer to the driver private structure.
  * @buffer: Pointer to the packet data.
@@ -86,7 +232,7 @@ static struct sk_buff *rsi_prepare_skb(struct rsi_common *common,
 
 	pkt_len -= extended_desc;
 	skb = dev_alloc_skb(pkt_len + FRAME_DESC_SZ);
-	if (skb == NULL)
+	if (!skb)
 		return NULL;
 
 	payload_offset = (extended_desc + FRAME_DESC_SZ);
@@ -96,6 +242,7 @@ static struct sk_buff *rsi_prepare_skb(struct rsi_common *common,
 	info = IEEE80211_SKB_CB(skb);
 	rx_params = (struct skb_info *)info->driver_data;
 	rx_params->rssi = rsi_get_rssi(buffer);
+
 	rx_params->channel = rsi_get_connected_channel(common->priv);
 
 	return skb;
@@ -108,30 +255,60 @@ static struct sk_buff *rsi_prepare_skb(struct rsi_common *common,
  *
  * Return: 0 on success, -1 on failure.
  */
-int rsi_read_pkt(struct rsi_common *common, s32 rcv_pkt_len)
+int rsi_read_pkt(struct rsi_common *common, u8 *rx_pkt, s32 rcv_pkt_len)
 {
 	u8 *frame_desc = NULL, extended_desc = 0;
-	u32 index, length = 0, queueno = 0;
+	u32 index = 0, length = 0, queueno = 0;
 	u16 actual_length = 0, offset;
 	struct sk_buff *skb = NULL;
+#if defined(CONFIG_RSI_COEX) && defined(CONFIG_RSI_ZIGB)
+	struct rsi_mod_ops *zb_ops = g_proto_ops.zb_ops;
+	u8 zb_pkt_type;
+#endif
 
-	index = 0;
 	do {
-		frame_desc = &common->rx_data_pkt[index];
+		frame_desc = &rx_pkt[index];
 		actual_length = *(u16 *)&frame_desc[0];
 		offset = *(u16 *)&frame_desc[2];
 
 		queueno = rsi_get_queueno(frame_desc, offset);
 		length = rsi_get_length(frame_desc, offset);
-		extended_desc = rsi_get_extended_desc(frame_desc, offset);
+
+		if (queueno != RSI_ZIGB_Q) {
+			if ((actual_length < (4 + FRAME_DESC_SZ)) || (offset < 4)) {
+				rsi_dbg(ERR_ZONE,
+					"%s: actual_length (%d) is less than 20 or"
+					" offset(%d) is less than 4\n",
+					__func__, actual_length, offset);
+				break;
+			}
+		}
+		if (queueno == RSI_WIFI_DATA_Q || queueno == RSI_WIFI_MGMT_Q)
+			extended_desc = rsi_get_extended_desc(frame_desc,
+							      offset);
 
 		switch (queueno) {
+		case RSI_COEX_Q:
+			rsi_hex_dump(MGMT_RX_ZONE,
+				     "RX Command co ex packet",
+				     frame_desc + offset,
+				     FRAME_DESC_SZ + length);
+#ifdef CONFIG_RSI_COEX
+			rsi_coex_recv_pkt(common, (frame_desc + offset));
+#else
+			rsi_mgmt_pkt_recv(common, (frame_desc + offset));
+#endif
+			break;
 		case RSI_WIFI_DATA_Q:
+			rsi_hex_dump(DATA_RX_ZONE,
+				     "RX Data pkt",
+				     frame_desc + offset,
+				     FRAME_DESC_SZ + length);
 			skb = rsi_prepare_skb(common,
 					      (frame_desc + offset),
 					      length,
 					      extended_desc);
-			if (skb == NULL)
+			if (!skb)
 				goto fail;
 
 			rsi_indicate_pkt_to_os(common, skb);
@@ -140,6 +317,44 @@ int rsi_read_pkt(struct rsi_common *common, s32 rcv_pkt_len)
 		case RSI_WIFI_MGMT_Q:
 			rsi_mgmt_pkt_recv(common, (frame_desc + offset));
 			break;
+#if defined(CONFIG_RSI_BT_ALONE) || defined(CONFIG_RSI_COEX)
+		case RSI_BT_MGMT_Q:
+		case RSI_BT_DATA_Q:
+			rsi_hex_dump(DATA_RX_ZONE,
+				     "RX BT Pkt",
+				     frame_desc + offset,
+				     FRAME_DESC_SZ + length);
+			rsi_hci_recv_pkt(common, frame_desc + offset);
+			break;
+#endif
+
+#if defined(CONFIG_RSI_COEX) && defined(CONFIG_RSI_ZIGB)
+		case RSI_ZIGB_Q:
+			rsi_hex_dump(DATA_RX_ZONE,
+					"RX ZB Pkt",
+					frame_desc + offset,
+					FRAME_DESC_SZ + length);
+#define ZB_RX_PKT_TYPE_OFST	15
+#define ZB_CARD_READY_IND	0xff
+			zb_pkt_type = frame_desc[offset + ZB_RX_PKT_TYPE_OFST];
+			if ((zb_pkt_type == ZB_CARD_READY_IND) &&
+			    (common->zb_fsm_state == ZB_DEVICE_NOT_READY)) {
+				rsi_dbg(INFO_ZONE, "ZIGB Card ready recvd\n");
+				common->zb_fsm_state = ZB_DEVICE_READY;
+				if (zb_ops && zb_ops->attach) {
+					if (zb_ops->attach(common,
+							   &g_proto_ops))
+						rsi_dbg(ERR_ZONE,
+							"Failed to attach ZIGB module\n");
+				}
+			} else {
+				if ((common->zb_fsm_state == ZB_DEVICE_READY) &&
+				    zb_ops && zb_ops->recv_pkt)
+					zb_ops->recv_pkt(common,
+							 frame_desc + offset);
+			}
+			break;
+#endif
 
 		default:
 			rsi_dbg(ERR_ZONE, "%s: pkt from invalid queue: %d\n",
@@ -181,11 +396,64 @@ static void rsi_tx_scheduler_thread(struct rsi_common *common)
 	complete_and_exit(&common->tx_thread.completion, 0);
 }
 
+#ifdef CONFIG_SDIO_INTR_POLL
+void rsi_sdio_intr_poll_scheduler_thread(struct rsi_common *common)
+{
+        struct rsi_hw *adapter = common->priv;
+        int status = 0;
+
+        do {
+                status = adapter->check_intr_status_reg(adapter);
+                if (adapter->isr_pending)
+                        adapter->isr_pending = 0;
+                msleep(20);
+
+        } while (atomic_read(&common->sdio_intr_poll_thread.thread_done) == 0);
+        complete_and_exit(&common->sdio_intr_poll_thread.completion, 0);
+}
+
+void init_sdio_intr_status_poll_thread(struct rsi_common *common)
+{
+	rsi_init_event(&common->sdio_intr_poll_thread.event);
+	if (rsi_create_kthread(common,
+			       &common->sdio_intr_poll_thread,
+			       rsi_sdio_intr_poll_scheduler_thread,
+			       "Sdio Intr poll-Thread")) {
+		rsi_dbg(ERR_ZONE, "%s: Unable to init sdio intr poll thrd\n",
+				__func__);
+	}
+}
+EXPORT_SYMBOL_GPL(init_sdio_intr_status_poll_thread);
+#endif
+
+#ifdef CONFIG_RSI_COEX
+enum host_intf rsi_get_host_intf(void *priv)
+{
+	struct rsi_common *common = (struct rsi_common *)priv;
+
+	return common->priv->rsi_host_intf;
+}
+
+void rsi_set_zb_context(void *priv, void *zb_context)
+{
+	struct rsi_common *common = (struct rsi_common *)priv;
+
+	common->zb_adapter = zb_context;
+}
+
+void *rsi_get_zb_context(void *priv)
+{
+	struct rsi_common *common = (struct rsi_common *)priv;
+
+	return common->zb_adapter;
+}
+#endif
+
 /**
  * rsi_91x_init() - This function initializes os interface operations.
  * @void: Void.
  *
- * Return: Pointer to the adapter structure on success, NULL on failure .
+ * Return: Pointer to the adapter structure on success, NULL on failure.
  */
 struct rsi_hw *rsi_91x_init(void)
 {
@@ -198,22 +466,39 @@ struct rsi_hw *rsi_91x_init(void)
 		return NULL;
 
 	adapter->priv = kzalloc(sizeof(*common), GFP_KERNEL);
-	if (adapter->priv == NULL) {
-		rsi_dbg(ERR_ZONE, "%s: Failed in allocation of memory\n",
+	if (!adapter->priv) {
+		rsi_dbg(ERR_ZONE, "%s: Failed in allocation of priv\n",
 			__func__);
 		kfree(adapter);
 		return NULL;
-	} else {
-		common = adapter->priv;
-		common->priv = adapter;
 	}
+	common = adapter->priv;
+	common->priv = adapter;
 
 	for (ii = 0; ii < NUM_SOFT_QUEUES; ii++)
 		skb_queue_head_init(&common->tx_queue[ii]);
 
+#ifdef CONFIG_RSI_11K
+	skb_queue_head_init(&common->rrm_queue);
+#endif
 	rsi_init_event(&common->tx_thread.event);
 	mutex_init(&common->mutex);
-	mutex_init(&common->tx_rxlock);
+	mutex_init(&common->tx_lock);
+	mutex_init(&common->rx_lock);
+	sema_init(&common->tx_bus_lock, 1);
+
+#ifdef CONFIG_HW_SCAN_OFFLOAD
+	rsi_init_event(&common->chan_set_event);
+	rsi_init_event(&common->probe_cfm_event);
+	rsi_init_event(&common->mgmt_cfm_event);
+	rsi_init_event(&common->chan_change_event);
+	rsi_init_event(&common->cancel_hw_scan_event);
+	common->scan_workqueue = 
+		create_singlethread_workqueue("rsi_scan_worker");
+	INIT_WORK(&common->scan_work, rsi_scan_start);
+#endif
+	common->dev_oper_mode[0] = dev_oper_mode_count;
+	memcpy(&common->dev_oper_mode[1], &dev_oper_mode, 5 * sizeof(u16));
 
 	if (rsi_create_kthread(common,
 			       &common->tx_thread,
@@ -223,6 +508,30 @@ struct rsi_hw *rsi_91x_init(void)
 		goto err;
 	}
 
+#ifdef CONFIG_RSI_COEX
+	if (rsi_coex_init(common)) {
+		rsi_dbg(ERR_ZONE, "Failed to init COEX module\n");
+		goto err;
+	}
+#endif
+	/* Power save related */
+	rsi_default_ps_params(adapter);
+	spin_lock_init(&adapter->ps_lock);
+	common->uapsd_bitmap = 0;
+
+	/* BGScan related */
+	init_bgscan_params(common);
+
+	/* Wi-Fi direct related */
+#if LINUX_VERSION_CODE < KERNEL_VERSION (4, 15, 0)
+	common->roc_timer.data = (unsigned long)common;
+	common->roc_timer.function = (void *)&rsi_roc_timeout;
+	init_timer(&common->roc_timer);
+#else
+	timer_setup(&common->roc_timer, rsi_roc_timeout, 0);
+#endif
+	init_completion(&common->wlan_init_completion);
+
 	common->init_done = true;
 	return adapter;
 
@@ -244,13 +553,34 @@ void rsi_91x_deinit(struct rsi_hw *adapter)
 	struct rsi_common *common = adapter->priv;
 	u8 ii;
 
-	rsi_dbg(INFO_ZONE, "%s: Performing deinit os ops\n", __func__);
+	rsi_dbg(INFO_ZONE, "%s: Deinit core module...\n", __func__);
+
+#ifdef CONFIG_HW_SCAN_OFFLOAD
+	flush_workqueue(common->scan_workqueue);
+	destroy_workqueue(common->scan_workqueue);
+#endif
 
 	rsi_kill_thread(&common->tx_thread);
 
 	for (ii = 0; ii < NUM_SOFT_QUEUES; ii++)
 		skb_queue_purge(&common->tx_queue[ii]);
 
+#ifdef CONFIG_RSI_COEX
+	if (common->coex_mode > 1) {
+#ifdef CONFIG_RSI_ZIGB
+		if ((common->zb_fsm_state == ZB_DEVICE_READY) &&
+		    g_proto_ops.zb_ops->detach) {
+			rsi_dbg(INFO_ZONE,
+				"%s: Detaching the zigbee module\n", __func__);
+			g_proto_ops.zb_ops->detach(common);
+		}
+#endif
+	}
+	rsi_coex_deinit(common);
+#endif
+	rsi_dbg(ERR_ZONE, "%s: reset drv instance: %d\n",
+			__func__, adapter->drv_instance_index);
+	DRV_INSTANCE_SET(adapter->drv_instance_index, 0);
 	common->init_done = false;
 
 	kfree(common);
@@ -270,6 +600,12 @@ void rsi_91x_deinit(struct rsi_hw *adapter)
 static int rsi_91x_hal_module_init(void)
 {
 	rsi_dbg(INIT_ZONE, "%s: Module init called\n", __func__);
+#if defined(CONFIG_RSI_COEX) && defined(CONFIG_RSI_ZIGB)
+	g_proto_ops.zb_ops = rsi_get_zb_ops();
+	if (!g_proto_ops.zb_ops)
+		rsi_dbg(ERR_ZONE, "Failed to get ZIGB ops\n");
+#endif
+
 	return 0;
 }
 
@@ -291,5 +627,5 @@ static void rsi_91x_hal_module_exit(void)
 MODULE_AUTHOR("Redpine Signals Inc");
 MODULE_DESCRIPTION("Station driver for RSI 91x devices");
 MODULE_SUPPORTED_DEVICE("RSI-91x");
-MODULE_VERSION("0.1");
+MODULE_VERSION(DRV_VER);
 MODULE_LICENSE("Dual BSD/GPL");
diff --git a/drivers/net/wireless/rsi/rsi_91x_mgmt.c b/drivers/net/wireless/rsi/rsi_91x_mgmt.c
index 35c14cc..0829c73 100644
--- a/drivers/net/wireless/rsi/rsi_91x_mgmt.c
+++ b/drivers/net/wireless/rsi/rsi_91x_mgmt.c
@@ -1,23 +1,199 @@
-/**
- * Copyright (c) 2014 Redpine Signals Inc.
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
  *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
  *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include <linux/etherdevice.h>
 #include "rsi_mgmt.h"
 #include "rsi_common.h"
+#include "rsi_ps.h"
+#include "rsi_hal.h"
+#ifdef CONFIG_RSI_COEX
+#include "rsi_coex.h"
+#endif
+#ifdef CONFIG_RSI_11K
+#include "rsi_rrm.h"
+#endif
+
+#if 0
+static struct rsi_config_vals dev_config_vals[] = {
+	{
+		.lp_ps_handshake = 0,
+		.ulp_ps_handshake = 0,
+		.sleep_config_params = 0,
+		.ext_pa_or_bt_coex_en = 0,
+	},
+};
+#endif
+
+#ifdef CONFIG_RSI_11K
+struct reg_class reg_db[MAX_REGIONS][MAX_REG_CLASS] = { {
+	{ 1, 20, {36, 40, 44, 48} },
+	{ 2, 20, {52, 56, 60, 64} },
+	{ 3, 20, {149, 153, 157, 161} },
+	{ 4, 20, {100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140} },
+	{ 5, 20, {149, 153, 157, 161, 165} },
+	{ 6, 5, {1, 2, 3, 4, 5, 6, 7, 8, 9, 10} },
+	{ 7, 5, {1, 2, 3, 4, 5, 6, 7, 8, 9, 10} },
+	{ 8, 10, {11, 13, 15, 17, 19} },
+	{ 9, 10, {11, 13, 15, 17, 19} },
+	{ 10, 20, {21, 25} },
+	{ 11, 20, {21, 25} },
+	{ 12, 25, {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11} },
+	{ 13, 20, {133, 137} },
+	{ 14, 10, {132, 134, 136, 138} },
+	{ 15, 5, {131, 132, 133, 134, 135, 136, 137, 138} },
+	{ 22, 40, {36, 44} },
+	{ 23, 40, {52, 60} },
+	{ 24, 40, {100, 108, 116, 124, 132} },
+	{ 25, 40, {149, 157} },
+	{ 26, 40, {149, 157} },
+	{ 27, 40, {40, 48} },
+	{ 28, 40, {56, 64} },
+	{ 29, 40, {104, 112, 120, 128, 136} },
+	{ 30, 40, {153, 161} },
+	{ 31, 40, {153, 161} },
+	{ 32, 40, {1, 2, 3, 4, 5, 6, 7} },
+	{ 33, 40, {5, 6, 7, 8, 9, 10, 11 } }
+	}, {
+	{ 1, 20, {36, 40, 44, 48} },
+	{ 2, 20, {52, 56, 60, 64} },
+	{ 3, 20, {100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140} },
+	{ 4, 25, {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13} },
+	{ 5, 40, {36, 44} },
+	{ 6, 40, {52, 60} },
+	{ 7, 40, {100, 108, 116, 124, 132} },
+	{ 8, 40, {40, 48} },
+	{ 9, 40, {56, 64} },
+	{ 10, 40, {104, 112, 120, 128, 136} },
+	{ 11, 40, {1, 2, 3, 4, 5, 6, 7, 8, 9} },
+	{ 12, 40, {5, 6, 7, 8, 9, 10, 11, 12, 13} },
+	{ 16, 20, {100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140} },
+	{ 17, 20, {149, 153, 157, 161, 165, 169} }
+	}, {
+	{ 1, 20, {34, 38, 42, 46, 36, 40, 44, 48} },
+	{ 2, 20, {8, 12, 16} },
+	{ 3, 20, {8, 12, 16} },
+	{ 4, 20, {8, 12, 16} },
+	{ 5, 20, {8, 12, 16} },
+	{ 6, 20, {8, 12, 16} },
+	{ 7, 20, {184, 188, 192, 196} },
+	{ 8, 20, {184, 188, 192, 196} },
+	{ 9, 20, {184, 188, 192, 196} },
+	{ 10, 20, {184, 188, 192, 196} },
+	{ 11, 20, {184, 188, 192, 196} },
+	{ 12, 10, {7, 8, 9, 11} },
+	{ 13, 10, {7, 8, 9, 11} },
+	{ 14, 10, {7, 8, 9, 11} },
+	{ 15, 10, {7, 8, 9, 11} },
+	{ 16, 10, {183, 184, 185, 187, 188, 189} },
+	{ 17, 10, {183, 184, 185, 187, 188, 189} },
+	{ 18, 10, {183, 184, 185, 187, 188, 189} },
+	{ 19, 10, {183, 184, 185, 187, 188, 189} },
+	{ 20, 10, {183, 184, 185, 187, 188, 189} },
+	{ 21, 5, {6, 7, 8, 9, 10, 11} },
+	{ 22, 5, {6, 7, 8, 9, 10, 11} },
+	{ 23, 5, {6, 7, 8, 9, 10, 11} },
+	{ 24, 5, {6, 7, 8, 9, 10, 11} },
+	{ 25, 5, {182, 183, 184, 185, 186, 187, 188, 189} },
+	{ 26, 5, {182, 183, 184, 185, 186, 187, 188, 189} },
+	{ 27, 5, {182, 183, 184, 185, 186, 187, 188, 189} },
+	{ 28, 5, {182, 183, 184, 185, 186, 187, 188, 189} },
+	{ 29, 5, {182, 183, 184, 185, 186, 187, 188, 189} },
+	{ 30, 25, {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13} },
+	{ 31, 25, {14} },
+	{ 32, 20, {52, 56, 60, 64} },
+	{ 33, 20, {52, 56, 60, 64} },
+	{ 34, 20, {100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140} },
+	{ 35, 20, {100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140} },
+	{ 36, 40, {36, 44} },
+	{ 37, 40, {52, 60} },
+	{ 38, 40, {52, 60} },
+	{ 39, 40, {100, 108, 116, 124, 132} },
+	{ 40, 40, {100, 108, 116, 124, 132} },
+	{ 41, 40, {40, 48} },
+	{ 42, 40, {56, 64} },
+	{ 43, 40, {56, 64} },
+	{ 44, 40, {104, 112, 120, 128, 136} },
+	{ 45, 40, {104, 112, 120, 128, 136} },
+	{ 46, 40, {184, 192} },
+	{ 47, 40, {184, 192} },
+	{ 48, 40, {184, 192} },
+	{ 49, 40, {184, 192} },
+	{ 50, 40, {184, 192} },
+	{ 51, 40, {188, 196} },
+	{ 52, 40, {188, 196} },
+	{ 53, 40, {188, 196} },
+	{ 54, 40, {188, 196} },
+	{ 55, 40, {188, 196} },
+	{ 56, 40, {1, 2, 3, 4, 5, 6, 7, 8, 9} },
+	{ 57, 40, {5, 6, 7, 8, 9, 10, 11, 12, 13} },
+	{ 58, 20, {100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140} },
+	}, {
+	{ 81, 25, {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13} },
+	{ 82, 25, {14} },
+	{ 83, 40, {1, 2, 3, 4, 5, 6, 7, 8, 9} },
+	{ 84, 40, {5, 6, 7, 8, 9, 10, 11, 12, 13} },
+	{ 94, 20, {133, 137} },
+	{ 95, 10, {132, 134, 136, 138} },
+	{ 96, 5, {131, 132, 133, 134, 135, 136, 137, 138} },
+	{ 101, 20, {21, 25} },
+	{ 102, 10, {11, 13, 15, 17, 19} },
+	{ 103, 5, {1, 2, 3, 4, 5, 6, 7, 8, 9, 10} },
+	{ 104, 40, {184, 192} },
+	{ 105, 40, {188, 196} },
+	{ 106, 20, {191, 195} },
+	{ 107, 10, {189, 191, 193, 195, 197} },
+	{ 108, 5, {188, 189, 190, 191, 192, 193, 194, 195, 196, 197} },
+	{ 109, 20, {184, 188, 192, 196} },
+	{ 110, 10, {183, 184, 185, 186, 187, 188, 189} },
+	{ 111, 5, {183, 184, 185, 186, 187, 188, 189} },
+	{ 112, 20, {8, 12, 16} },
+	{ 113, 10, {7, 8, 9, 10, 11} },
+	{ 114, 5, {6, 7, 8, 9, 10, 11} },
+	{ 115, 20, {36, 40, 44, 48} },
+	{ 116, 40, {36, 44} },
+	{ 117, 40, {40, 48} },
+	{ 118, 20, {52, 56, 60, 64} },
+	{ 119, 40, {52, 60}, },
+	{ 120, 40, {56, 64}, },
+	{ 121, 20, {100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140} },
+	{ 122, 40, {100, 108, 116, 124, 132} },
+	{ 123, 40, {104, 112, 120, 128, 136} },
+	{ 124, 20, {149, 153, 157, 161} },
+	{ 125, 20, {149, 153, 157, 161, 165, 169} },
+	{ 126, 40, {149, 157} },
+	{ 127, 40, {153, 161} }
+	}
+};
+#endif
 
+/* Bootup Parameters for 20MHz */
 static struct bootup_params boot_params_20 = {
 	.magic_number = cpu_to_le16(0x5aa5),
 	.crystal_good_time = 0x0,
@@ -28,15 +204,17 @@
 	.rtls_timestamp_en = 0x0,
 	.host_spi_intr_cfg = 0x0,
 	.device_clk_info = {{
+		/* WLAN params */
 		.pll_config_g = {
 			.tapll_info_g = {
-				.pll_reg_1 = cpu_to_le16((TA_PLL_N_VAL_20 << 8)|
-					      (TA_PLL_M_VAL_20)),
-				.pll_reg_2 = cpu_to_le16(TA_PLL_P_VAL_20),
+				.pll_reg_1 = cpu_to_le16((TAPLL_N_VAL_20 << 8) |
+							 (TAPLL_M_VAL_20)),
+				.pll_reg_2 = cpu_to_le16(TAPLL_P_VAL_20),
 			},
 			.pll960_info_g = {
-				.pll_reg_1 = cpu_to_le16((PLL960_P_VAL_20 << 8)|
-							 (PLL960_N_VAL_20)),
+				.pll_reg_1 =
+					cpu_to_le16((PLL960_P_VAL_20 << 8) |
+						    (PLL960_N_VAL_20)),
 				.pll_reg_2 = cpu_to_le16(PLL960_M_VAL_20),
 				.pll_reg_3 = 0x0,
 			},
@@ -45,22 +223,29 @@
 			}
 		},
 		.switch_clk_g = {
-			.switch_clk_info = cpu_to_le16(BIT(3)),
-			.bbp_lmac_clk_reg_val = cpu_to_le16(0x121),
-			.umac_clock_reg_config = 0x0,
-			.qspi_uart_clock_reg_config = 0x0
+			.switch_umac_clk = 0x1,
+			.switch_qspi_clk = 0x1,
+			.switch_slp_clk_2_32 = 0x0,
+			.switch_bbp_lmac_clk_reg = 0x1,
+			.switch_mem_ctrl_cfg = 0x0,
+			.reserved = 0x0,
+			.bbp_lmac_clk_reg_val = cpu_to_le16(0x111),
+			.umac_clock_reg_config = cpu_to_le16(0x48),
+			.qspi_uart_clock_reg_config = cpu_to_le16(0x1211)
 		}
 	},
+	/* Bluetooth params */
 	{
 		.pll_config_g = {
 			.tapll_info_g = {
-				.pll_reg_1 = cpu_to_le16((TA_PLL_N_VAL_20 << 8)|
-							 (TA_PLL_M_VAL_20)),
-				.pll_reg_2 = cpu_to_le16(TA_PLL_P_VAL_20),
+				.pll_reg_1 = cpu_to_le16((TAPLL_N_VAL_20 << 8) |
+							 (TAPLL_M_VAL_20)),
+				.pll_reg_2 = cpu_to_le16(TAPLL_P_VAL_20),
 			},
 			.pll960_info_g = {
-				.pll_reg_1 = cpu_to_le16((PLL960_P_VAL_20 << 8)|
-							 (PLL960_N_VAL_20)),
+				.pll_reg_1 =
+					cpu_to_le16((PLL960_P_VAL_20 << 8) |
+						    (PLL960_N_VAL_20)),
 				.pll_reg_2 = cpu_to_le16(PLL960_M_VAL_20),
 				.pll_reg_3 = 0x0,
 			},
@@ -69,22 +254,29 @@
 			}
 		},
 		.switch_clk_g = {
-			.switch_clk_info = 0x0,
+			.switch_umac_clk = 0x0,
+			.switch_qspi_clk = 0x0,
+			.switch_slp_clk_2_32 = 0x0,
+			.switch_bbp_lmac_clk_reg = 0x0,
+			.switch_mem_ctrl_cfg = 0x0,
+			.reserved = 0x0,
 			.bbp_lmac_clk_reg_val = 0x0,
 			.umac_clock_reg_config = 0x0,
 			.qspi_uart_clock_reg_config = 0x0
 		}
 	},
+	/* Zigbee params */
 	{
 		.pll_config_g = {
 			.tapll_info_g = {
-				.pll_reg_1 = cpu_to_le16((TA_PLL_N_VAL_20 << 8)|
-							 (TA_PLL_M_VAL_20)),
-				.pll_reg_2 = cpu_to_le16(TA_PLL_P_VAL_20),
+				.pll_reg_1 = cpu_to_le16((TAPLL_N_VAL_20 << 8) |
+							 (TAPLL_M_VAL_20)),
+				.pll_reg_2 = cpu_to_le16(TAPLL_P_VAL_20),
 			},
 			.pll960_info_g = {
-				.pll_reg_1 = cpu_to_le16((PLL960_P_VAL_20 << 8)|
-							 (PLL960_N_VAL_20)),
+				.pll_reg_1 =
+					cpu_to_le16((PLL960_P_VAL_20 << 8) |
+						    (PLL960_N_VAL_20)),
 				.pll_reg_2 = cpu_to_le16(PLL960_M_VAL_20),
 				.pll_reg_3 = 0x0,
 			},
@@ -93,12 +285,65 @@
 			}
 		},
 		.switch_clk_g = {
-			.switch_clk_info = 0x0,
+			.switch_umac_clk = 0x0,
+			.switch_qspi_clk = 0x0,
+			.switch_slp_clk_2_32 = 0x0,
+			.switch_bbp_lmac_clk_reg = 0x0,
+			.switch_mem_ctrl_cfg = 0x0,
+			.reserved = 0x0,
 			.bbp_lmac_clk_reg_val = 0x0,
 			.umac_clock_reg_config = 0x0,
 			.qspi_uart_clock_reg_config = 0x0
 		}
-	} },
+	}
+	},
+	/* ULP Params */
+	.buckboost_wakeup_cnt = 0x0,
+	.pmu_wakeup_wait = 0x0,
+	.shutdown_wait_time = 0x0,
+	.pmu_slp_clkout_sel = 0x0,
+	.wdt_prog_value = 0x0,
+	.wdt_soc_rst_delay = 0x0,
+	.dcdc_operation_mode = 0x0,
+	.soc_reset_wait_cnt = 0x0,
+	.waiting_time_at_fresh_sleep = 0x0,
+	.max_threshold_to_avoid_sleep = 0x0,
+	.beacon_resedue_alg_en = 0,
+};
+
+/* Bootup Parameters for 20MHz */
+static struct bootup_params_9116 boot_params_9116_20 = {
+	.magic_number = cpu_to_le16(0x5aa5),
+	.crystal_good_time = 0x0,
+	.valid = cpu_to_le32(VALID_20),
+	.reserved_for_valids = 0x0,
+	.bootup_mode_info = 0x0,
+	.digital_loop_back_params = 0x0,
+	.rtls_timestamp_en = 0x0,
+	.host_spi_intr_cfg = 0x0,
+	.device_clk_info_9116 = {{
+		/* WLAN params */
+		.pll_config_9116_g = {
+			.pll_ctrl_set_reg = 0xd518,
+			.pll_ctrl_clr_reg = 0x2ae7,
+			.pll_modem_conig_reg = 0x2000,
+			.soc_clk_config_reg = 0x0C18,
+			.adc_dac_strm1_config_reg = 0x1100,
+			.adc_dac_strm2_config_reg = 0x6600,
+		},
+		.switch_clk_9116_g = {
+			.switch_clk_info =
+				cpu_to_le32((RSI_SWITCH_TASS_CLK |
+					    RSI_SWITCH_WLAN_BBP_LMAC_CLK_REG |
+					    RSI_SWITCH_BBP_LMAC_CLK_REG)),
+			.tass_clock_reg = 0x083C0503,
+			.wlan_bbp_lmac_clk_reg_val = 0x01042001,
+			.zbbt_bbp_lmac_clk_reg_val = 0x02010001,
+			.bbp_lmac_clk_en_val = 0x0000003b,
+		}
+	},
+	},
+	/* ULP Params */
 	.buckboost_wakeup_cnt = 0x0,
 	.pmu_wakeup_wait = 0x0,
 	.shutdown_wait_time = 0x0,
@@ -106,9 +351,13 @@
 	.wdt_prog_value = 0x0,
 	.wdt_soc_rst_delay = 0x0,
 	.dcdc_operation_mode = 0x0,
-	.soc_reset_wait_cnt = 0x0
+	.soc_reset_wait_cnt = 0x0,
+	.waiting_time_at_fresh_sleep = 0x0,
+	.max_threshold_to_avoid_sleep = 0x0,
+	.beacon_resedue_alg_en = 0,
 };
 
+/* Bootup parameters for 40MHz */
 static struct bootup_params boot_params_40 = {
 	.magic_number = cpu_to_le16(0x5aa5),
 	.crystal_good_time = 0x0,
@@ -119,15 +368,17 @@
 	.rtls_timestamp_en = 0x0,
 	.host_spi_intr_cfg = 0x0,
 	.device_clk_info = {{
+		/* WLAN params */
 		.pll_config_g = {
 			.tapll_info_g = {
-				.pll_reg_1 = cpu_to_le16((TA_PLL_N_VAL_40 << 8)|
-							 (TA_PLL_M_VAL_40)),
-				.pll_reg_2 = cpu_to_le16(TA_PLL_P_VAL_40),
+				.pll_reg_1 = cpu_to_le16((TAPLL_N_VAL_40 << 8) |
+							 (TAPLL_M_VAL_40)),
+				.pll_reg_2 = cpu_to_le16(TAPLL_P_VAL_40),
 			},
 			.pll960_info_g = {
-				.pll_reg_1 = cpu_to_le16((PLL960_P_VAL_40 << 8)|
-							 (PLL960_N_VAL_40)),
+				.pll_reg_1 =
+					cpu_to_le16((PLL960_P_VAL_40 << 8) |
+						    (PLL960_N_VAL_40)),
 				.pll_reg_2 = cpu_to_le16(PLL960_M_VAL_40),
 				.pll_reg_3 = 0x0,
 			},
@@ -136,22 +387,29 @@
 			}
 		},
 		.switch_clk_g = {
-			.switch_clk_info = cpu_to_le16(0x09),
+			.switch_umac_clk = 0x1,
+			.switch_qspi_clk = 0x1,
+			.switch_slp_clk_2_32 = 0x0,
+			.switch_bbp_lmac_clk_reg = 0x1,
+			.switch_mem_ctrl_cfg = 0x0,
+			.reserved = 0x0,
 			.bbp_lmac_clk_reg_val = cpu_to_le16(0x1121),
 			.umac_clock_reg_config = cpu_to_le16(0x48),
-			.qspi_uart_clock_reg_config = 0x0
+			.qspi_uart_clock_reg_config = cpu_to_le16(0x1211)
 		}
 	},
+	/* Bluetooth Params */
 	{
 		.pll_config_g = {
 			.tapll_info_g = {
-				.pll_reg_1 = cpu_to_le16((TA_PLL_N_VAL_40 << 8)|
-							 (TA_PLL_M_VAL_40)),
-				.pll_reg_2 = cpu_to_le16(TA_PLL_P_VAL_40),
+				.pll_reg_1 = cpu_to_le16((TAPLL_N_VAL_40 << 8) |
+							 (TAPLL_M_VAL_40)),
+				.pll_reg_2 = cpu_to_le16(TAPLL_P_VAL_40),
 			},
 			.pll960_info_g = {
-				.pll_reg_1 = cpu_to_le16((PLL960_P_VAL_40 << 8)|
-							 (PLL960_N_VAL_40)),
+				.pll_reg_1 =
+					cpu_to_le16((PLL960_P_VAL_40 << 8) |
+						    (PLL960_N_VAL_40)),
 				.pll_reg_2 = cpu_to_le16(PLL960_M_VAL_40),
 				.pll_reg_3 = 0x0,
 			},
@@ -160,22 +418,29 @@
 			}
 		},
 		.switch_clk_g = {
-			.switch_clk_info = 0x0,
+			.switch_umac_clk = 0x0,
+			.switch_qspi_clk = 0x0,
+			.switch_slp_clk_2_32 = 0x0,
+			.switch_bbp_lmac_clk_reg = 0x0,
+			.switch_mem_ctrl_cfg = 0x0,
+			.reserved = 0x0,
 			.bbp_lmac_clk_reg_val = 0x0,
 			.umac_clock_reg_config = 0x0,
 			.qspi_uart_clock_reg_config = 0x0
 		}
 	},
+	/* Zigbee Params */
 	{
 		.pll_config_g = {
 			.tapll_info_g = {
-				.pll_reg_1 = cpu_to_le16((TA_PLL_N_VAL_40 << 8)|
-							 (TA_PLL_M_VAL_40)),
-				.pll_reg_2 = cpu_to_le16(TA_PLL_P_VAL_40),
+				.pll_reg_1 = cpu_to_le16((TAPLL_N_VAL_40 << 8) |
+							 (TAPLL_M_VAL_40)),
+				.pll_reg_2 = cpu_to_le16(TAPLL_P_VAL_40),
 			},
 			.pll960_info_g = {
-				.pll_reg_1 = cpu_to_le16((PLL960_P_VAL_40 << 8)|
-							 (PLL960_N_VAL_40)),
+				.pll_reg_1 =
+					cpu_to_le16((PLL960_P_VAL_40 << 8) |
+						    (PLL960_N_VAL_40)),
 				.pll_reg_2 = cpu_to_le16(PLL960_M_VAL_40),
 				.pll_reg_3 = 0x0,
 			},
@@ -184,12 +449,70 @@
 			}
 		},
 		.switch_clk_g = {
-			.switch_clk_info = 0x0,
+			.switch_umac_clk = 0x0,
+			.switch_qspi_clk = 0x0,
+			.switch_slp_clk_2_32 = 0x0,
+			.switch_bbp_lmac_clk_reg = 0x0,
+			.switch_mem_ctrl_cfg = 0x0,
+			.reserved = 0x0,
 			.bbp_lmac_clk_reg_val = 0x0,
 			.umac_clock_reg_config = 0x0,
 			.qspi_uart_clock_reg_config = 0x0
 		}
-	} },
+	}
+	},
+	/* ULP Params */
+	.buckboost_wakeup_cnt = 0x0,
+	.pmu_wakeup_wait = 0x0,
+	.shutdown_wait_time = 0x0,
+	.pmu_slp_clkout_sel = 0x0,
+	.wdt_prog_value = 0x0,
+	.wdt_soc_rst_delay = 0x0,
+	.dcdc_operation_mode = 0x0,
+	.soc_reset_wait_cnt = 0x0,
+	.waiting_time_at_fresh_sleep = 0x0,
+	.max_threshold_to_avoid_sleep = 0x0,
+	.beacon_resedue_alg_en = 0,
+};
+
+/* Bootup parameters for 40MHz - 9116 */
+static struct bootup_params_9116 boot_params_9116_40 = {
+	.magic_number = cpu_to_le16(0x5aa5),
+	.crystal_good_time = 0x0,
+	.valid = cpu_to_le32(VALID_40),
+	.reserved_for_valids = 0x0,
+	.bootup_mode_info = 0x0,
+	.digital_loop_back_params = 0x0,
+	.rtls_timestamp_en = 0x0,
+	.host_spi_intr_cfg = 0x0,
+	.device_clk_info_9116 = {{
+		/* WLAN params */
+		.pll_config_9116_g = {
+			.pll_ctrl_set_reg = 0xd518,
+			.pll_ctrl_clr_reg = 0x2ae7,
+			.pll_modem_conig_reg = 0x3000,
+			.soc_clk_config_reg = 0x0C18,
+			.adc_dac_strm1_config_reg = 0x0000,
+			.adc_dac_strm2_config_reg = 0x6600,
+		},
+		.switch_clk_9116_g = {
+			.switch_clk_info =
+				cpu_to_le32((RSI_SWITCH_TASS_CLK |
+					    RSI_SWITCH_WLAN_BBP_LMAC_CLK_REG |
+					    RSI_SWITCH_BBP_LMAC_CLK_REG |
+					    RSI_MODEM_CLK_160MHZ)),
+			.tass_clock_reg = 0x083C0503,
+#ifdef CONFIG_FPGA_40MHZ
+			.wlan_bbp_lmac_clk_reg_val = 0x01081002,
+#else
+			.wlan_bbp_lmac_clk_reg_val = 0x01042002,
+#endif
+			.zbbt_bbp_lmac_clk_reg_val = 0x04010002,
+			.bbp_lmac_clk_en_val = 0x0000003b,
+		}
+	},
+	},
+	/* ULP Params */
 	.buckboost_wakeup_cnt = 0x0,
 	.pmu_wakeup_wait = 0x0,
 	.shutdown_wait_time = 0x0,
@@ -197,11 +520,87 @@
 	.wdt_prog_value = 0x0,
 	.wdt_soc_rst_delay = 0x0,
 	.dcdc_operation_mode = 0x0,
-	.soc_reset_wait_cnt = 0x0
+	.soc_reset_wait_cnt = 0x0,
+	.waiting_time_at_fresh_sleep = 0x0,
+	.max_threshold_to_avoid_sleep = 0x0,
+	.beacon_resedue_alg_en = 0,
+};
+
+#define UNUSED_GPIO	1
+#define USED_GPIO	0
+static struct rsi_ulp_gpio_vals unused_ulp_gpio_bitmap = {
+	.motion_sensor_gpio_ulp_wakeup = UNUSED_GPIO,
+	.sleep_ind_from_device = UNUSED_GPIO,
+	.ulp_gpio_2 = UNUSED_GPIO,
+	.push_button_ulp_wakeup = UNUSED_GPIO,
+};
+
+struct rsi_soc_gpio_vals unused_soc_gpio_bitmap = {
+	.pspi_csn_0		= USED_GPIO,	//GPIO_0
+	.pspi_csn_1		= USED_GPIO,	//GPIO_1
+	.host_wakeup_intr	= USED_GPIO,	//GPIO_2
+	.pspi_data_0		= USED_GPIO,	//GPIO_3
+	.pspi_data_1		= USED_GPIO,	//GPIO_4
+	.pspi_data_2		= USED_GPIO,	//GPIO_5
+	.pspi_data_3		= USED_GPIO,	//GPIO_6
+	.i2c_scl		= USED_GPIO,	//GPIO_7
+	.i2c_sda		= USED_GPIO,	//GPIO_8
+	.uart1_rx		= UNUSED_GPIO,	//GPIO_9
+	.uart1_tx		= UNUSED_GPIO,	//GPIO_10
+	.uart1_rts_i2s_clk	= UNUSED_GPIO,	//GPIO_11
+	.uart1_cts_i2s_ws	= UNUSED_GPIO,	//GPIO_12
+	.dbg_uart_rx_i2s_din	= UNUSED_GPIO,	//GPIO_13
+	.dbg_uart_tx_i2s_dout	= UNUSED_GPIO,	//GPIO_14
+	.lp_wakeup_boot_bypass	= UNUSED_GPIO,	//GPIO_15
+	.led_0			= USED_GPIO,	//GPIO_16
+	.btcoex_wlan_active_ext_pa_ant_sel_A = UNUSED_GPIO, //GPIO_17
+	.btcoex_bt_priority_ext_pa_ant_sel_B = UNUSED_GPIO, //GPIO_18
+	.btcoex_bt_active_ext_pa_on_off = UNUSED_GPIO, //GPIO_19
+	.rf_reset		= USED_GPIO, //GPIO_20
+	.sleep_ind_from_device	= UNUSED_GPIO,
 };
 
 static u16 mcs[] = {13, 26, 39, 52, 78, 104, 117, 130};
 
+#ifdef CONFIG_RSI_11K
+int ieee80211_chan_to_bw(struct rsi_hw *adapter, u8 op_class, u8 channel_num)
+{
+	int i, j;
+	u8 region = adapter->dfs_region;
+
+	for (i = 0; i < ARRAY_SIZE(reg_db[region - 1]); i++) {
+		if (reg_db[region - 1][i].op_class == op_class) {
+			for (j = 0; j < ARRAY_SIZE(reg_db[region - 1][i].chans);
+					j++) {
+				if (reg_db[region - 1][i].chans[j] ==
+				    channel_num)
+					return reg_db[region - 1][i].bandwidth;
+			}
+		}
+	}
+	return -1;
+}
+
+int is_dfs_channel(struct rsi_hw *adapter, int channel)
+{
+	struct ieee80211_supported_band *sband;
+	struct ieee80211_channel *ch;
+	struct wiphy *wiphy = adapter->hw->wiphy;
+	int i;
+
+	sband = wiphy->bands[NL80211_BAND_5GHZ];
+	for (i = 0; i < sband->n_channels; i++) {
+		ch = &sband->channels[i];
+		if (ch->flags & IEEE80211_CHAN_DISABLED)
+			continue;
+		if ((ch->hw_value == channel) &&
+		    (ch->flags & IEEE80211_CHAN_RADAR))
+			return 1;
+	}
+	return 0;
+}
+#endif
+
 /**
  * rsi_set_default_parameters() - This function sets default parameters.
  * @common: Pointer to the driver private structure.
@@ -218,6 +617,73 @@ static void rsi_set_default_parameters(struct rsi_common *common)
 	common->fsm_state = FSM_CARD_NOT_READY;
 	common->iface_down = true;
 	common->endpoint = EP_2GHZ_20MHZ;
+	common->driver_mode = 1; /* End-to-End Mode */
+
+	if (common->priv->device_model == RSI_DEV_9116)
+		common->ta_aggr = 3;
+	else
+		common->ta_aggr = 0;
+
+	common->skip_fw_load = 0; /* Default disable skipping fw loading */
+	common->lp_ps_handshake_mode = 0; /* Default No HandShake mode*/
+	common->ulp_ps_handshake_mode = 2; /* Default PKT HandShake mode*/
+	common->rf_power_val = 0; /* Default 1.9V */
+	common->device_gpio_type = TA_GPIO; /* Default TA GPIO */
+	common->country_code = 840; /* Default US */
+	common->wlan_rf_power_mode = 0;
+	common->bt_rf_power_mode = 0;
+	common->obm_ant_sel_val = 2;
+	common->antenna_diversity = 0;
+	common->tx_power = RSI_TXPOWER_MAX;
+	common->dtim_cnt = 2;
+	common->beacon_interval = 100;
+	common->antenna_gain[0] = 0;
+	common->antenna_gain[1] = 0;
+	common->w9116_features.pll_mode = 0x0 ;
+	common->w9116_features.rf_type = 1;
+	common->w9116_features.wireless_mode = 0;
+	common->w9116_features.enable_ppe = 0;
+	common->w9116_features.afe_type = 1;
+	common->w9116_features.dpd = 0;
+	common->w9116_features.sifs_tx_enable = 0;
+	common->w9116_features.ps_options = 0;
+}
+
+void init_bgscan_params(struct rsi_common *common)
+{
+	common->bgscan_info.bgscan_threshold = 0;
+	common->bgscan_info.roam_threshold = 10;
+	common->bgscan_info.bgscan_periodicity = 30;
+	common->bgscan_info.num_bg_channels = 0;
+	common->bgscan_info.two_probe = 1;
+	common->bgscan_info.active_scan_duration = 20;
+	common->bgscan_info.passive_scan_duration = 70;
+	common->bgscan_info.channels2scan[0] = 1;
+	common->bgscan_info.channels2scan[1] = 2;
+	common->bgscan_info.channels2scan[2] = 3;
+	common->bgscan_info.channels2scan[3] = 4;
+	common->bgscan_info.channels2scan[4] = 5;
+	common->bgscan_info.channels2scan[5] = 6;
+	common->bgscan_info.channels2scan[6] = 7;
+	common->bgscan_info.channels2scan[7] = 8;
+	common->bgscan_info.channels2scan[8] = 9;
+	common->bgscan_info.channels2scan[9] = 10;
+	common->bgscan_info.channels2scan[10] = 11;
+//	common->bgscan_info.channels2scan[11] = 12;
+//	common->bgscan_info.channels2scan[12] = 13;
+//	common->bgscan_info.channels2scan[13] = 14;
+#if 0
+	common->bgscan_info.channels2scan[11] = 36;
+	common->bgscan_info.channels2scan[12] = 40;
+	common->bgscan_info.channels2scan[13] = 44;
+	common->bgscan_info.channels2scan[14] = 48;
+	common->bgscan_info.channels2scan[15] = 52;
+	common->bgscan_info.channels2scan[16] = 56;
+	common->bgscan_info.channels2scan[17] = 60;
+	common->bgscan_info.channels2scan[18] = 64;
+	common->bgscan_info.channels2scan[19] = 100;
+	common->bgscan_info.channels2scan[20] = 104;
+#endif
 }
 
 /**
@@ -255,13 +721,18 @@ static int rsi_send_internal_mgmt_frame(struct rsi_common *common,
 {
 	struct skb_info *tx_params;
 
-	if (skb == NULL) {
-		rsi_dbg(ERR_ZONE, "%s: Unable to allocate skb\n", __func__);
-		return -ENOMEM;
+	if (!skb) {
+		rsi_dbg(ERR_ZONE, "%s: SKB is NULL\n", __func__);
+		return -EINVAL;
 	}
+	skb->data[1] |= BIT(7);
 	tx_params = (struct skb_info *)&IEEE80211_SKB_CB(skb)->driver_data;
 	tx_params->flags |= INTERNAL_MGMT_PKT;
-	skb_queue_tail(&common->tx_queue[MGMT_SOFT_Q], skb);
+	skb->priority = MGMT_SOFT_Q;
+	if (skb->data[2] == PEER_NOTIFY)
+		skb_queue_head(&common->tx_queue[MGMT_SOFT_Q], skb);
+	else
+		skb_queue_tail(&common->tx_queue[MGMT_SOFT_Q], skb);
 	rsi_set_event(&common->tx_thread.event);
 	return 0;
 }
@@ -278,7 +749,8 @@ static int rsi_load_radio_caps(struct rsi_common *common)
 	struct rsi_radio_caps *radio_caps;
 	struct rsi_hw *adapter = common->priv;
 	u16 inx = 0;
-	u8 ii;
+	u16 value;
+	int ii;
 	u8 radio_id = 0;
 	u16 gc[20] = {0xf0, 0xf0, 0xf0, 0xf0,
 		      0xf0, 0xf0, 0xf0, 0xf0,
@@ -290,26 +762,24 @@ static int rsi_load_radio_caps(struct rsi_common *common)
 	rsi_dbg(INFO_ZONE, "%s: Sending rate symbol req frame\n", __func__);
 
 	skb = dev_alloc_skb(sizeof(struct rsi_radio_caps));
-
-	if (!skb) {
-		rsi_dbg(ERR_ZONE, "%s: Failed in allocation of skb\n",
-			__func__);
+	if (!skb)
 		return -ENOMEM;
-	}
 
 	memset(skb->data, 0, sizeof(struct rsi_radio_caps));
 	radio_caps = (struct rsi_radio_caps *)skb->data;
 
 	radio_caps->desc_word[1] = cpu_to_le16(RADIO_CAPABILITIES);
-	radio_caps->desc_word[4] = cpu_to_le16(RSI_RF_TYPE << 8);
+	radio_caps->desc_word[4] = cpu_to_le16(common->channel);
+	radio_caps->desc_word[4] |= cpu_to_le16(RSI_RF_TYPE << 8);
 
+	radio_caps->desc_word[7] |= cpu_to_le16(RSI_LMAC_CLOCK_80MHZ);
 	if (common->channel_width == BW_40MHZ) {
-		radio_caps->desc_word[7] |= cpu_to_le16(RSI_LMAC_CLOCK_80MHZ);
 		radio_caps->desc_word[7] |= cpu_to_le16(RSI_ENABLE_40MHZ);
 
 		if (common->fsm_state == FSM_MAC_INIT_DONE) {
 			struct ieee80211_hw *hw = adapter->hw;
 			struct ieee80211_conf *conf = &hw->conf;
+
 			if (conf_is_ht40_plus(conf)) {
 				radio_caps->desc_word[5] =
 					cpu_to_le16(LOWER_20_ENABLE);
@@ -329,6 +799,14 @@ static int rsi_load_radio_caps(struct rsi_common *common)
 		}
 	}
 
+	if (adapter->device_model == RSI_DEV_9116) {
+		if (common->channel_width == BW_20MHZ) {
+			value = le16_to_cpu(radio_caps->desc_word[7]);
+			value = (value & (~0x3));
+			radio_caps->desc_word[7] = cpu_to_le16(value);
+		}
+	}
+
 	radio_caps->sifs_tx_11n = cpu_to_le16(SIFS_TX_11N_VALUE);
 	radio_caps->sifs_tx_11b = cpu_to_le16(SIFS_TX_11B_VALUE);
 	radio_caps->slot_rx_11n = cpu_to_le16(SHORT_SLOT_VALUE);
@@ -345,7 +823,7 @@ static int rsi_load_radio_caps(struct rsi_common *common)
 		radio_caps->qos_params[ii].txop_q = 0;
 	}
 
-	for (ii = 0; ii < MAX_HW_QUEUES - 4; ii++) {
+	for (ii = 0; ii < NUM_EDCA_QUEUES; ii++) {
 		radio_caps->qos_params[ii].cont_win_min_q =
 			cpu_to_le16(common->edca_params[ii].cw_min);
 		radio_caps->qos_params[ii].cont_win_max_q =
@@ -356,6 +834,10 @@ static int rsi_load_radio_caps(struct rsi_common *common)
 			cpu_to_le16(common->edca_params[ii].txop);
 	}
 
+	radio_caps->qos_params[BROADCAST_HW_Q].txop_q = 0xffff;
+	radio_caps->qos_params[MGMT_HW_Q].txop_q = 0;
+	radio_caps->qos_params[BEACON_HW_Q].txop_q = 0xffff;
+
 	memcpy(&common->rate_pwr[0], &gc[0], 40);
 	for (ii = 0; ii < 20; ii++)
 		radio_caps->gcpd_per_rate[inx++] =
@@ -363,8 +845,7 @@ static int rsi_load_radio_caps(struct rsi_common *common)
 
 	radio_caps->desc_word[0] = cpu_to_le16((sizeof(struct rsi_radio_caps) -
 						FRAME_DESC_SZ) |
-					       (RSI_WIFI_MGMT_Q << 12));
-
+						(RSI_WIFI_MGMT_Q << 12));
 
 	skb_put(skb, (sizeof(struct rsi_radio_caps)));
 
@@ -375,15 +856,14 @@ static int rsi_load_radio_caps(struct rsi_common *common)
  * rsi_mgmt_pkt_to_core() - This function is the entry point for Mgmt module.
  * @common: Pointer to the driver private structure.
  * @msg: Pointer to received packet.
- * @msg_len: Length of the recieved packet.
- * @type: Type of recieved packet.
+ * @msg_len: Length of the received packet.
+ * @type: Type of received packet.
  *
  * Return: 0 on success, -1 on failure.
  */
 static int rsi_mgmt_pkt_to_core(struct rsi_common *common,
 				u8 *msg,
-				s32 msg_len,
-				u8 type)
+				s32 msg_len)
 {
 	struct rsi_hw *adapter = common->priv;
 	struct ieee80211_tx_info *info;
@@ -392,48 +872,81 @@ static int rsi_mgmt_pkt_to_core(struct rsi_common *common,
 	u8 pkt_recv;
 	struct sk_buff *skb;
 	char *buffer;
+	struct ieee80211_hdr *wlh;
+#ifdef CONFIG_RSI_11K
+	u8 *data;
+#endif
+	if (!adapter->sc_nvifs)
+		return -ENOLINK;
+
+	if (common->iface_down)
+		return -ENODEV;
+
+	msg_len -= pad_bytes;
+	if ((msg_len <= 0) || (!msg)) {
+		rsi_dbg(MGMT_RX_ZONE,
+			"%s: Invalid rx msg of len = %d\n",
+			__func__, msg_len);
+		return -EINVAL;
+	}
+#ifdef CONFIG_RSI_11K
+	wlh = (struct ieee80211_hdr *)&msg[FRAME_DESC_SZ + pad_bytes];
+	rsi_hex_dump(ERR_ZONE, "RX RRM packet", (u8 *)wlh, msg_len);
 
-	if (type == RX_DOT11_MGMT) {
-		if (!adapter->sc_nvifs)
-			return -ENOLINK;
-
-		msg_len -= pad_bytes;
-		if (msg_len <= 0) {
+	if (ieee80211_is_action(wlh->frame_control)) {
+		data = (u8 *)wlh + MIN_802_11_HDR_LEN;
+		if (data[0] == WLAN_ACTION_RADIO_MEASUREMENT) {
 			rsi_dbg(MGMT_RX_ZONE,
-				"%s: Invalid rx msg of len = %d\n",
-				__func__, msg_len);
-			return -EINVAL;
-		}
-
-		skb = dev_alloc_skb(msg_len);
-		if (!skb) {
-			rsi_dbg(ERR_ZONE, "%s: Failed to allocate skb\n",
+				"%s: Received Radio Measurement Request\n",
 				__func__);
-			return -ENOMEM;
+			if (!rsi_rrm_parse_radio_action_frame(common,
+							      (u8 *)wlh,
+							      msg_len))
+				return 0;
+		} else if (data[0] == WLAN_ACTION_SPECTRUM_MANAGEMENT) {
+			rsi_dbg(MGMT_RX_ZONE,
+				"%s: Received spectrum Measurement Request\n",
+				__func__);
+			rsi_rrm_parse_spectrum_action_frame(common, wlh,
+							    data);
+				return 0;
+		} else {
+			rsi_dbg(MGMT_RX_ZONE,
+				"%s: Received invalid category code\n",
+				__func__);
+			return 0;
 		}
+	}
+#endif
+	skb = dev_alloc_skb(msg_len);
+	if (!skb)
+		return -ENOMEM;
 
-		buffer = skb_put(skb, msg_len);
+	buffer = skb_put(skb, msg_len);
 
-		memcpy(buffer,
-		       (u8 *)(msg +  FRAME_DESC_SZ + pad_bytes),
-		       msg_len);
+	memcpy(buffer,
+		(u8 *)(msg +  FRAME_DESC_SZ + pad_bytes),
+		msg_len);
 
-		pkt_recv = buffer[0];
+	pkt_recv = buffer[0];
 
-		info = IEEE80211_SKB_CB(skb);
-		rx_params = (struct skb_info *)info->driver_data;
-		rx_params->rssi = rsi_get_rssi(msg);
-		rx_params->channel = rsi_get_channel(msg);
-		rsi_indicate_pkt_to_os(common, skb);
-	} else {
-		rsi_dbg(MGMT_TX_ZONE, "%s: Internal Packet\n", __func__);
-	}
+	info = IEEE80211_SKB_CB(skb);
+	rx_params = (struct skb_info *)info->driver_data;
+	rx_params->rssi = rsi_get_rssi(msg);
+	rx_params->channel = rsi_get_channel(msg);
+	rsi_dbg(MGMT_RX_ZONE,
+		"%s: rssi=%d channel=%d\n",
+		__func__, rx_params->rssi, rx_params->channel);
+	wlh = (struct ieee80211_hdr *)skb->data;
+	rsi_dbg(INFO_ZONE, "RX Dot11 Mgmt Pkt Type: %s\n",
+		dot11_pkt_type(wlh->frame_control));
+	rsi_indicate_pkt_to_os(common, skb);
 
 	return 0;
 }
 
 /**
- * rsi_hal_send_sta_notify_frame() - This function sends the station notify
+ * rsi_send_sta_notify_frame() - This function sends the station notify
  *				     frame to firmware.
  * @common: Pointer to the driver private structure.
  * @opmode: Operating mode of device.
@@ -444,32 +957,38 @@ static int rsi_mgmt_pkt_to_core(struct rsi_common *common,
  *
  * Return: status: 0 on success, corresponding negative error code on failure.
  */
-static int rsi_hal_send_sta_notify_frame(struct rsi_common *common,
-					 u8 opmode,
-					 u8 notify_event,
-					 const unsigned char *bssid,
-					 u8 qos_enable,
-					 u16 aid)
+int rsi_send_sta_notify_frame(struct rsi_common *common,
+			      enum opmode opmode,
+			      u8 notify_event,
+			      const unsigned char *bssid,
+			      u8 qos_enable,
+			      u16 aid,
+			      u16 sta_id)
 {
+	struct rsi_hw *adapter = common->priv;
+	struct ieee80211_vif *vif = adapter->vifs[adapter->sc_nvifs - 1];
 	struct sk_buff *skb = NULL;
 	struct rsi_peer_notify *peer_notify;
-	u16 vap_id = 0;
 	int status;
+	u16 vap_id = 0;
+	int frame_len = sizeof(*peer_notify);
 
-	rsi_dbg(MGMT_TX_ZONE, "%s: Sending sta notify frame\n", __func__);
-
-	skb = dev_alloc_skb(sizeof(struct rsi_peer_notify));
+	rsi_dbg(MGMT_TX_ZONE, "%s: Sending station notify frame\n", __func__);
 
+	skb = dev_alloc_skb(frame_len);
 	if (!skb) {
 		rsi_dbg(ERR_ZONE, "%s: Failed in allocation of skb\n",
 			__func__);
 		return -ENOMEM;
 	}
+	memset(skb->data, 0, frame_len);
 
-	memset(skb->data, 0, sizeof(struct rsi_peer_notify));
 	peer_notify = (struct rsi_peer_notify *)skb->data;
 
-	peer_notify->command = cpu_to_le16(opmode << 1);
+	if (opmode == STA_OPMODE)
+		peer_notify->command = cpu_to_le16(PEER_TYPE_AP << 1);
+	else if (opmode == AP_OPMODE)
+		peer_notify->command = cpu_to_le16(PEER_TYPE_STA << 1);
 
 	switch (notify_event) {
 	case STA_CONNECTED:
@@ -481,31 +1000,31 @@ static int rsi_hal_send_sta_notify_frame(struct rsi_common *common,
 	default:
 		break;
 	}
-
+	adapter->peer_notify = true;
 	peer_notify->command |= cpu_to_le16((aid & 0xfff) << 4);
 	ether_addr_copy(peer_notify->mac_addr, bssid);
-
+	peer_notify->mpdu_density = cpu_to_le16(0x08); //FIXME check this
 	peer_notify->sta_flags = cpu_to_le32((qos_enable) ? 1 : 0);
-
-	peer_notify->desc_word[0] =
-		cpu_to_le16((sizeof(struct rsi_peer_notify) - FRAME_DESC_SZ) |
-			    (RSI_WIFI_MGMT_Q << 12));
+	peer_notify->desc_word[0] = cpu_to_le16((frame_len - FRAME_DESC_SZ) |
+						(RSI_WIFI_MGMT_Q << 12));
 	peer_notify->desc_word[1] = cpu_to_le16(PEER_NOTIFY);
-	peer_notify->desc_word[7] |= cpu_to_le16(vap_id << 8);
-
-	skb_put(skb, sizeof(struct rsi_peer_notify));
+	peer_notify->desc_word[7] |= cpu_to_le16(sta_id | vap_id << 8);
 
+	skb_put(skb, frame_len);
 	status = rsi_send_internal_mgmt_frame(common, skb);
 
-	if (!status && qos_enable) {
+	if ((vif->type == NL80211_IFTYPE_STATION) &&
+	    (!status) && qos_enable) {
 		rsi_set_contention_vals(common);
+		mdelay(1);
 		status = rsi_load_radio_caps(common);
 	}
+
 	return status;
 }
 
 /**
- * rsi_send_aggregation_params_frame() - This function sends the ampdu
+ * rsi_send_aggr_params_frame() - This function sends the ampdu
  *					 indication frame to firmware.
  * @common: Pointer to the driver private structure.
  * @tid: traffic identifier.
@@ -515,18 +1034,19 @@ static int rsi_hal_send_sta_notify_frame(struct rsi_common *common,
  *
  * Return: 0 on success, corresponding negative error code on failure.
  */
-int rsi_send_aggregation_params_frame(struct rsi_common *common,
-				      u16 tid,
-				      u16 ssn,
-				      u8 buf_size,
-				      u8 event)
+int rsi_send_aggr_params_frame(struct rsi_common *common,
+			       u16 tid,
+			       u16 ssn,
+			       u8 buf_size,
+			       u8 event,
+			       u8 sta_id)
 {
 	struct sk_buff *skb = NULL;
 	struct rsi_mac_frame *mgmt_frame;
 	u8 peer_id = 0;
+//	u8 window_size = 1;
 
 	skb = dev_alloc_skb(FRAME_DESC_SZ);
-
 	if (!skb) {
 		rsi_dbg(ERR_ZONE, "%s: Failed in allocation of skb\n",
 			__func__);
@@ -536,7 +1056,9 @@ int rsi_send_aggregation_params_frame(struct rsi_common *common,
 	memset(skb->data, 0, FRAME_DESC_SZ);
 	mgmt_frame = (struct rsi_mac_frame *)skb->data;
 
-	rsi_dbg(MGMT_TX_ZONE, "%s: Sending AMPDU indication frame\n", __func__);
+	rsi_dbg(MGMT_TX_ZONE,
+		"%s: Sending AMPDU indication frame\n",
+		__func__);
 
 	mgmt_frame->desc_word[0] = cpu_to_le16(RSI_WIFI_MGMT_Q << 12);
 	mgmt_frame->desc_word[1] = cpu_to_le16(AMPDU_IND);
@@ -544,8 +1066,11 @@ int rsi_send_aggregation_params_frame(struct rsi_common *common,
 	if (event == STA_TX_ADDBA_DONE) {
 		mgmt_frame->desc_word[4] = cpu_to_le16(ssn);
 		mgmt_frame->desc_word[5] = cpu_to_le16(buf_size);
+		//mgmt_frame->desc_word[5] = cpu_to_le16(window_size);
 		mgmt_frame->desc_word[7] =
-		cpu_to_le16((tid | (START_AMPDU_AGGR << 4) | (peer_id << 8)));
+			cpu_to_le16((tid |
+				    (START_AMPDU_AGGR << 4) |
+				    (peer_id << 8)));
 	} else if (event == STA_RX_ADDBA_DONE) {
 		mgmt_frame->desc_word[4] = cpu_to_le16(ssn);
 		mgmt_frame->desc_word[7] = cpu_to_le16(tid |
@@ -575,12 +1100,12 @@ int rsi_send_aggregation_params_frame(struct rsi_common *common,
  *
  * Return: 0 on success, corresponding negative error code on failure.
  */
-static int rsi_program_bb_rf(struct rsi_common *common)
+int rsi_program_bb_rf(struct rsi_common *common)
 {
 	struct sk_buff *skb;
 	struct rsi_mac_frame *mgmt_frame;
 
-	rsi_dbg(MGMT_TX_ZONE, "%s: Sending program BB/RF frame\n", __func__);
+	rsi_dbg(MGMT_TX_ZONE, "%s: Sending BB/RF program frame\n", __func__);
 
 	skb = dev_alloc_skb(FRAME_DESC_SZ);
 	if (!skb) {
@@ -595,6 +1120,7 @@ static int rsi_program_bb_rf(struct rsi_common *common)
 	mgmt_frame->desc_word[0] = cpu_to_le16(RSI_WIFI_MGMT_Q << 12);
 	mgmt_frame->desc_word[1] = cpu_to_le16(BBP_PROG_IN_TA);
 	mgmt_frame->desc_word[4] = cpu_to_le16(common->endpoint);
+	mgmt_frame->desc_word[3] = cpu_to_le16(common->rf_pwr_mode);
 
 	if (common->rf_reset) {
 		mgmt_frame->desc_word[7] =  cpu_to_le16(RF_RESET_ENABLE);
@@ -605,6 +1131,7 @@ static int rsi_program_bb_rf(struct rsi_common *common)
 	common->bb_rf_prog_count = 1;
 	mgmt_frame->desc_word[7] |= cpu_to_le16(PUT_BBP_RESET |
 				     BBP_REG_WRITE | (RSI_RF_TYPE << 4));
+
 	skb_put(skb, FRAME_DESC_SZ);
 
 	return rsi_send_internal_mgmt_frame(common, skb);
@@ -617,17 +1144,24 @@ static int rsi_program_bb_rf(struct rsi_common *common)
  *
  * Return: 0 on success, corresponding negative error code on failure.
  */
-int rsi_set_vap_capabilities(struct rsi_common *common, enum opmode mode)
+int rsi_set_vap_capabilities(struct rsi_common *common,
+			     enum opmode mode,
+			     u8 *mac_addr,
+			     u8 vap_id,
+			     u8 vap_status)
 {
 	struct sk_buff *skb = NULL;
 	struct rsi_vap_caps *vap_caps;
 	struct rsi_hw *adapter = common->priv;
 	struct ieee80211_hw *hw = adapter->hw;
 	struct ieee80211_conf *conf = &hw->conf;
-	u16 vap_id = 0;
 
-	rsi_dbg(MGMT_TX_ZONE, "%s: Sending VAP capabilities frame\n", __func__);
+	rsi_dbg(MGMT_TX_ZONE,
+		"%s: Sending VAP capabilities frame\n", __func__);
 
+	rsi_dbg(INFO_ZONE, "Config VAP: id=%d mode=%d status=%d ",
+		vap_id, mode, vap_status);
+	rsi_hex_dump(INFO_ZONE, "mac", mac_addr, 6);
 	skb = dev_alloc_skb(sizeof(struct rsi_vap_caps));
 	if (!skb) {
 		rsi_dbg(ERR_ZONE, "%s: Failed in allocation of skb\n",
@@ -642,46 +1176,63 @@ int rsi_set_vap_capabilities(struct rsi_common *common, enum opmode mode)
 					     FRAME_DESC_SZ) |
 					     (RSI_WIFI_MGMT_Q << 12));
 	vap_caps->desc_word[1] = cpu_to_le16(VAP_CAPABILITIES);
+	vap_caps->desc_word[2] = cpu_to_le16(vap_status << 8);
 	vap_caps->desc_word[4] = cpu_to_le16(mode |
 					     (common->channel_width << 8));
 	vap_caps->desc_word[7] = cpu_to_le16((vap_id << 8) |
 					     (common->mac_id << 4) |
 					     common->radio_id);
 
-	memcpy(vap_caps->mac_addr, common->mac_addr, IEEE80211_ADDR_LEN);
+	memcpy(vap_caps->mac_addr, mac_addr, IEEE80211_ADDR_LEN);
 	vap_caps->keep_alive_period = cpu_to_le16(90);
 	vap_caps->frag_threshold = cpu_to_le16(IEEE80211_MAX_FRAG_THRESHOLD);
 
 	vap_caps->rts_threshold = cpu_to_le16(common->rts_threshold);
-	vap_caps->default_mgmt_rate = cpu_to_le32(RSI_RATE_6);
 
 	if (common->band == NL80211_BAND_5GHZ) {
 		vap_caps->default_ctrl_rate = cpu_to_le32(RSI_RATE_6);
-		if (conf_is_ht40(&common->priv->hw->conf)) {
-			vap_caps->default_ctrl_rate |=
-				cpu_to_le32(FULL40M_ENABLE << 16);
-		}
+		vap_caps->default_mgmt_rate = cpu_to_le32(RSI_RATE_6);
 	} else {
+		if (common->p2p_enabled) {
+			vap_caps->default_ctrl_rate = cpu_to_le32(RSI_RATE_6);
+			vap_caps->default_mgmt_rate = cpu_to_le32(RSI_RATE_6);
+		} else {
 		vap_caps->default_ctrl_rate = cpu_to_le32(RSI_RATE_1);
+		vap_caps->default_mgmt_rate = cpu_to_le32(RSI_RATE_1);
+	}
+	}
+
+	if (conf_is_ht40(conf)) {
 		if (conf_is_ht40_minus(conf))
 			vap_caps->default_ctrl_rate |=
 				cpu_to_le32(UPPER_20_ENABLE << 16);
 		else if (conf_is_ht40_plus(conf))
 			vap_caps->default_ctrl_rate |=
 				cpu_to_le32(LOWER_20_ENABLE << 16);
+		else
+			vap_caps->default_ctrl_rate |=
+				cpu_to_le32(FULL40M_ENABLE << 16);
 	}
 
 	vap_caps->default_data_rate = 0;
-	vap_caps->beacon_interval = cpu_to_le16(200);
-	vap_caps->dtim_period = cpu_to_le16(4);
+	vap_caps->beacon_interval = cpu_to_le16(common->beacon_interval);
+	vap_caps->dtim_period = cpu_to_le16(common->dtim_cnt);
+#ifdef RSI_HW_CONN_MONITOR
+	vap_caps->beacon_miss_threshold = cpu_to_le16(10);
+#else
+	if (mode == AP_OPMODE)
+		vap_caps->beacon_miss_threshold = cpu_to_le16(10);
+#endif
 
 	skb_put(skb, sizeof(*vap_caps));
 
+	common->last_vap_type = mode;
+	ether_addr_copy(common->last_vap_addr, mac_addr);
 	return rsi_send_internal_mgmt_frame(common, skb);
 }
 
 /**
- * rsi_hal_load_key() - This function is used to load keys within the firmware.
+ * rsi_load_key() - This function is used to load keys within the firmware.
  * @common: Pointer to the driver private structure.
  * @data: Pointer to the key data.
  * @key_len: Key length to be loaded.
@@ -691,16 +1242,20 @@ int rsi_set_vap_capabilities(struct rsi_common *common, enum opmode mode)
  *
  * Return: 0 on success, -1 on failure.
  */
-int rsi_hal_load_key(struct rsi_common *common,
-		     u8 *data,
-		     u16 key_len,
-		     u8 key_type,
-		     u8 key_id,
-		     u32 cipher)
+int rsi_load_key(struct rsi_common *common,
+		 u8 *data,
+		 u16 key_len,
+		 u8 key_type,
+		 u8 key_id,
+		 u32 cipher,
+		 s16 sta_id)
 {
+	struct ieee80211_vif *vif = common->priv->vifs[common->priv->sc_nvifs - 1];
 	struct sk_buff *skb = NULL;
 	struct rsi_set_key *set_key;
 	u16 key_descriptor = 0;
+	u8 key_t1 = 0;
+	u8 vap_id = 0;
 
 	rsi_dbg(MGMT_TX_ZONE, "%s: Sending load key frame\n", __func__);
 
@@ -714,44 +1269,116 @@ int rsi_hal_load_key(struct rsi_common *common,
 	memset(skb->data, 0, sizeof(struct rsi_set_key));
 	set_key = (struct rsi_set_key *)skb->data;
 
+	switch (key_type) {
+	case RSI_GROUP_KEY:
+		key_t1 = 1 << 1;
+		if ((vif->type == NL80211_IFTYPE_AP) ||
+		    (vif->type == NL80211_IFTYPE_P2P_GO))
+			key_descriptor = BIT(7);
+		break;
+	case RSI_PAIRWISE_KEY:
+		if (((vif->type == NL80211_IFTYPE_AP) ||
+		     (vif->type == NL80211_IFTYPE_P2P_GO)) &&
+		    (sta_id >= common->max_stations)) {
+			rsi_dbg(INFO_ZONE, "Invalid Sta_id %d\n", sta_id);
+			return -1;
+		}
+		key_t1 = 0 << 1;
+		if ((cipher != WLAN_CIPHER_SUITE_WEP40) &&
+		    (cipher != WLAN_CIPHER_SUITE_WEP104))
+			key_id = 0;
+		break;
+	}
 	if ((cipher == WLAN_CIPHER_SUITE_WEP40) ||
 	    (cipher == WLAN_CIPHER_SUITE_WEP104)) {
-		key_len += 1;
 		key_descriptor |= BIT(2);
-		if (key_len >= 13)
+		if (key_len >= 13) {
 			key_descriptor |= BIT(3);
+		}
 	} else if (cipher != KEY_TYPE_CLEAR) {
 		key_descriptor |= BIT(4);
-		if (key_type == RSI_PAIRWISE_KEY)
-			key_id = 0;
 		if (cipher == WLAN_CIPHER_SUITE_TKIP)
 			key_descriptor |= BIT(5);
 	}
-	key_descriptor |= (key_type | BIT(13) | (key_id << 14));
+	key_descriptor |= (key_t1 | BIT(13) | (key_id << 14));
 
 	set_key->desc_word[0] = cpu_to_le16((sizeof(struct rsi_set_key) -
 					    FRAME_DESC_SZ) |
 					    (RSI_WIFI_MGMT_Q << 12));
 	set_key->desc_word[1] = cpu_to_le16(SET_KEY_REQ);
 	set_key->desc_word[4] = cpu_to_le16(key_descriptor);
+	set_key->desc_word[7] = cpu_to_le16(sta_id | (vap_id << 8));
 
-	if ((cipher == WLAN_CIPHER_SUITE_WEP40) ||
-	    (cipher == WLAN_CIPHER_SUITE_WEP104)) {
-		memcpy(&set_key->key[key_id][1],
-		       data,
-		       key_len * 2);
+	if (data) {
+		if ((cipher == WLAN_CIPHER_SUITE_WEP40) ||
+		    (cipher == WLAN_CIPHER_SUITE_WEP104)) {
+			memcpy(&set_key->key[key_id][1], data, key_len * 2);
+		} else {
+			memcpy(&set_key->key[0][0], data, key_len);
+		}
+		memcpy(set_key->tx_mic_key, &data[16], 8);
+		memcpy(set_key->rx_mic_key, &data[24], 8);
 	} else {
-		memcpy(&set_key->key[0][0], data, key_len);
+		memset(&set_key[FRAME_DESC_SZ], 0,
+		       sizeof(struct rsi_set_key) - FRAME_DESC_SZ);				
 	}
 
-	memcpy(set_key->tx_mic_key, &data[16], 8);
-	memcpy(set_key->rx_mic_key, &data[24], 8);
-
 	skb_put(skb, sizeof(struct rsi_set_key));
 
 	return rsi_send_internal_mgmt_frame(common, skb);
 }
 
+/**
+ * rsi_send_common_dev_params() - This function send the common device
+ *				configuration parameters to device.
+ * @common: Pointer to the driver private structure.
+ *
+ * Return: 0 on success, -1 on failure.
+ */
+int rsi_send_common_dev_params(struct rsi_common *common)
+{
+	struct sk_buff *skb = NULL;
+	u32 frame_len = 0;
+	struct rsi_config_vals *dev_cfgs = NULL;
+
+	frame_len = sizeof(struct rsi_config_vals);
+
+	rsi_dbg(MGMT_TX_ZONE, "Sending common device config params\n");
+	skb = dev_alloc_skb(frame_len);
+	if (!skb) {
+		rsi_dbg(ERR_ZONE, "%s: Unable to allocate skb\n", __func__);
+		return -ENOMEM;
+	}
+
+	memset(skb->data, 0, frame_len);
+
+	dev_cfgs = (struct rsi_config_vals *)&skb->data[0];
+	memset(dev_cfgs, 0, (sizeof(struct rsi_config_vals)));
+
+	dev_cfgs->desc_word[0] = cpu_to_le16((frame_len - FRAME_DESC_SZ) |
+					     (RSI_COEX_Q << 12));
+	dev_cfgs->desc_word[1] = cpu_to_le16(COMMON_DEV_CONFIG);
+
+	dev_cfgs->lp_ps_handshake = common->lp_ps_handshake_mode;
+	dev_cfgs->ulp_ps_handshake = common->ulp_ps_handshake_mode;
+
+	dev_cfgs->unused_ulp_gpio = *(u8 *)&unused_ulp_gpio_bitmap;
+	dev_cfgs->unused_soc_gpio_bitmap =
+		cpu_to_le32(*(u32 *)&unused_soc_gpio_bitmap);
+
+	dev_cfgs->opermode = common->oper_mode;
+	dev_cfgs->wlan_rf_pwr_mode = common->wlan_rf_power_mode;
+	dev_cfgs->driver_mode = common->driver_mode;
+	dev_cfgs->region_code = NL80211_DFS_FCC;
+	dev_cfgs->antenna_sel_val = common->obm_ant_sel_val;
+
+	skb_put(skb, frame_len);
+
+	rsi_hex_dump(ERR_ZONE, "common dev config params ",
+		     skb->data, skb->len);
+	return rsi_send_internal_mgmt_frame(common, skb);
+}
+
 /*
  * rsi_load_bootup_params() - This function send bootup params to the firmware.
  * @common: Pointer to the driver private structure.
@@ -761,42 +1388,88 @@ int rsi_hal_load_key(struct rsi_common *common,
 static int rsi_load_bootup_params(struct rsi_common *common)
 {
 	struct sk_buff *skb;
-	struct rsi_boot_params *boot_params;
+	struct rsi_boot_params *boot_params = NULL;
+	struct rsi_boot_params_9116 *boot_params_9116 = NULL;
+	struct rsi_hw *adapter = common->priv;
 
 	rsi_dbg(MGMT_TX_ZONE, "%s: Sending boot params frame\n", __func__);
-	skb = dev_alloc_skb(sizeof(struct rsi_boot_params));
+
+	if (adapter->device_model == RSI_DEV_9116)
+		skb = dev_alloc_skb(sizeof(struct rsi_boot_params_9116));
+	else
+		skb = dev_alloc_skb(sizeof(struct rsi_boot_params));
+
 	if (!skb) {
 		rsi_dbg(ERR_ZONE, "%s: Failed in allocation of skb\n",
 			__func__);
 		return -ENOMEM;
 	}
-
-	memset(skb->data, 0, sizeof(struct rsi_boot_params));
-	boot_params = (struct rsi_boot_params *)skb->data;
-
-	rsi_dbg(MGMT_TX_ZONE, "%s:\n", __func__);
+	if (adapter->device_model == RSI_DEV_9116) {
+		memset(skb->data, 0, sizeof(struct rsi_boot_params_9116));
+		boot_params_9116 = (struct rsi_boot_params_9116 *)skb->data;
+	} else {
+		memset(skb->data, 0, sizeof(struct rsi_boot_params));
+		boot_params = (struct rsi_boot_params *)skb->data;
+	}
 
 	if (common->channel_width == BW_40MHZ) {
-		memcpy(&boot_params->bootup_params,
-		       &boot_params_40,
-		       sizeof(struct bootup_params));
-		rsi_dbg(MGMT_TX_ZONE, "%s: Packet 40MHZ <=== %d\n", __func__,
-			UMAC_CLK_40BW);
-		boot_params->desc_word[7] = cpu_to_le16(UMAC_CLK_40BW);
-	} else {
-		memcpy(&boot_params->bootup_params,
-		       &boot_params_20,
-		       sizeof(struct bootup_params));
-		if (boot_params_20.valid != cpu_to_le32(VALID_20)) {
-			boot_params->desc_word[7] = cpu_to_le16(UMAC_CLK_20BW);
+		if (adapter->device_model == RSI_DEV_9116) {
+			memcpy(&boot_params_9116->bootup_params,
+			       &boot_params_9116_40,
+			       sizeof(struct bootup_params_9116));
 			rsi_dbg(MGMT_TX_ZONE,
-				"%s: Packet 20MHZ <=== %d\n", __func__,
-				UMAC_CLK_20BW);
+				"%s: Packet 40MHZ <=== %d\n", __func__,
+				UMAC_CLK_40BW);
+			boot_params_9116->desc_word[7] =
+				cpu_to_le16(UMAC_CLK_40BW);
 		} else {
-			boot_params->desc_word[7] = cpu_to_le16(UMAC_CLK_40MHZ);
+			memcpy(&boot_params->bootup_params,
+			       &boot_params_40,
+			       sizeof(struct bootup_params));
 			rsi_dbg(MGMT_TX_ZONE,
-				"%s: Packet 20MHZ <=== %d\n", __func__,
-				UMAC_CLK_40MHZ);
+				"%s: Packet 40MHZ <=== %d\n", __func__,
+				UMAC_CLK_40BW);
+			boot_params->desc_word[7] = cpu_to_le16(UMAC_CLK_40BW);
+		}
+	} else {
+		if (adapter->device_model == RSI_DEV_9116)
+			memcpy(&boot_params_9116->bootup_params,
+			       &boot_params_9116_20,
+			       sizeof(struct bootup_params_9116));
+		else
+			memcpy(&boot_params->bootup_params,
+			       &boot_params_20,
+			       sizeof(struct bootup_params));
+
+		if (adapter->device_model == RSI_DEV_9116) {
+			if (boot_params_9116_20.valid !=
+					cpu_to_le32(VALID_20)) {
+				boot_params_9116->desc_word[7] =
+					cpu_to_le16(UMAC_CLK_20BW);
+				rsi_dbg(MGMT_TX_ZONE,
+					"%s: Packet 20MHZ <=== %d\n", __func__,
+					UMAC_CLK_20BW);
+			} else {
+				boot_params_9116->desc_word[7] =
+					cpu_to_le16(UMAC_CLK_40MHZ);
+				rsi_dbg(MGMT_TX_ZONE,
+					"%s: Packet 20MHZ <=== %d\n", __func__,
+					UMAC_CLK_40MHZ);
+			}
+		} else {
+			if (boot_params_20.valid != cpu_to_le32(VALID_20)) {
+				boot_params->desc_word[7] =
+					cpu_to_le16(UMAC_CLK_20BW);
+				rsi_dbg(MGMT_TX_ZONE,
+					"%s: Packet 20MHZ <=== %d\n", __func__,
+					UMAC_CLK_20BW);
+			} else {
+				boot_params->desc_word[7] =
+					cpu_to_le16(UMAC_CLK_40MHZ);
+				rsi_dbg(MGMT_TX_ZONE,
+					"%s: Packet 20MHZ <=== %d\n", __func__,
+					UMAC_CLK_40MHZ);
+			}
 		}
 	}
 
@@ -804,12 +1477,27 @@ static int rsi_load_bootup_params(struct rsi_common *common)
 	 * Bit{0:11} indicates length of the Packet
 	 * Bit{12:15} indicates host queue number
 	 */
-	boot_params->desc_word[0] = cpu_to_le16(sizeof(struct bootup_params) |
+	if (adapter->device_model == RSI_DEV_9116) {
+		boot_params_9116->desc_word[0] =
+			cpu_to_le16(sizeof(struct bootup_params_9116) |
 				    (RSI_WIFI_MGMT_Q << 12));
-	boot_params->desc_word[1] = cpu_to_le16(BOOTUP_PARAMS_REQUEST);
+		boot_params_9116->desc_word[1] =
+			cpu_to_le16(BOOTUP_PARAMS_REQUEST);
 
-	skb_put(skb, sizeof(struct rsi_boot_params));
+		skb_put(skb, sizeof(struct rsi_boot_params_9116));
 
+		rsi_dbg(MGMT_TX_ZONE, "%s: Boot params- %p\n",
+			__func__, boot_params_9116);
+	} else {
+		boot_params->desc_word[0] =
+			cpu_to_le16(sizeof(struct bootup_params) |
+				    (RSI_WIFI_MGMT_Q << 12));
+		boot_params->desc_word[1] =
+			cpu_to_le16(BOOTUP_PARAMS_REQUEST);
+		skb_put(skb, sizeof(struct rsi_boot_params));
+		rsi_dbg(MGMT_TX_ZONE, "%s: Boot params- %p\n",
+			__func__, boot_params);
+	}
 	return rsi_send_internal_mgmt_frame(common, skb);
 }
 
@@ -839,7 +1527,13 @@ static int rsi_send_reset_mac(struct rsi_common *common)
 
 	mgmt_frame->desc_word[0] = cpu_to_le16(RSI_WIFI_MGMT_Q << 12);
 	mgmt_frame->desc_word[1] = cpu_to_le16(RESET_MAC_REQ);
-	mgmt_frame->desc_word[4] = cpu_to_le16(RETRY_COUNT << 8);
+	mgmt_frame->desc_word[4] |= cpu_to_le16(RETRY_COUNT << 8);
+
+	/*TA level aggregation of pkts to host */
+	mgmt_frame->desc_word[3] |=  common->ta_aggr << 8;
+
+	if (common->antenna_diversity)
+		mgmt_frame->desc_word[6] = common->antenna_diversity;
 
 	skb_put(skb, FRAME_DESC_SZ);
 
@@ -852,13 +1546,13 @@ static int rsi_send_reset_mac(struct rsi_common *common)
  *
  * Return: 0 on success, corresponding error code on failure.
  */
-int rsi_band_check(struct rsi_common *common)
+int rsi_band_check(struct rsi_common *common,
+		   struct ieee80211_channel *curchan)
 {
 	struct rsi_hw *adapter = common->priv;
 	struct ieee80211_hw *hw = adapter->hw;
 	u8 prev_bw = common->channel_width;
 	u8 prev_ep = common->endpoint;
-	struct ieee80211_channel *curchan = hw->conf.chandef.chan;
 	int status = 0;
 
 	if (common->band != curchan->band) {
@@ -884,12 +1578,6 @@ int rsi_band_check(struct rsi_common *common)
 			common->endpoint = EP_5GHZ_20MHZ;
 	}
 
-	if (common->endpoint != prev_ep) {
-		status = rsi_program_bb_rf(common);
-		if (status)
-			return status;
-	}
-
 	if (common->channel_width != prev_bw) {
 		status = rsi_load_bootup_params(common);
 		if (status)
@@ -900,9 +1588,60 @@ int rsi_band_check(struct rsi_common *common)
 			return status;
 	}
 
+	if (common->endpoint != prev_ep) {
+		status = rsi_program_bb_rf(common);
+		if (status)
+			return status;
+	}
+
 	return status;
 }
 
+#ifdef CONFIG_CARACALLA_BOARD
+void rsi_apply_carcalla_power_values(struct rsi_hw *adapter,
+				     struct ieee80211_vif *vif,
+				     struct ieee80211_channel *channel)
+{
+	u16 max_power = 20;
+
+	if (!conf_is_ht(&adapter->hw->conf)) {
+		if (vif->bss_conf.basic_rates == 0xf) {
+			if (channel->hw_value == 12)
+				max_power = 15;
+			else if (channel->hw_value == 13)
+				max_power = 7;
+			else
+				return;
+		} else {
+			if (channel->hw_value == 12)
+				max_power = 8; 
+			else if (channel->hw_value == 13)
+				max_power = 7; 
+			else
+				return;
+		}
+	} else if (conf_is_ht20(&adapter->hw->conf)) {
+		if (channel->hw_value == 12)
+			max_power = 7; 
+		else if (channel->hw_value == 13)
+			max_power = 5;
+		else
+			return;
+	} else {
+		if (channel->hw_value == 6)
+			max_power = 9; 
+		else if (channel->hw_value == 9)
+			max_power = 5; 
+		else if (channel->hw_value == 10)
+			max_power = 4;
+		else
+			return;
+	}
+	channel->max_power = max_power;
+	channel->max_antenna_gain = 0;
+}
+#endif
+
 /**
  * rsi_set_channel() - This function programs the channel.
  * @common: Pointer to the driver private structure.
@@ -910,8 +1649,13 @@ int rsi_band_check(struct rsi_common *common)
  *
  * Return: 0 on success, corresponding error code on failure.
  */
-int rsi_set_channel(struct rsi_common *common, u16 channel)
+int rsi_set_channel(struct rsi_common *common,
+		    struct ieee80211_channel *channel)
 {
+	struct rsi_hw *adapter = common->priv;
+#ifdef CONFIG_CARACALLA_BOARD
+	struct ieee80211_vif *vif = adapter->vifs[adapter->sc_nvifs - 1];
+#endif
 	struct sk_buff *skb = NULL;
 	struct rsi_mac_frame *mgmt_frame;
 
@@ -925,24 +1669,65 @@ int rsi_set_channel(struct rsi_common *common, u16 channel)
 		return -ENOMEM;
 	}
 
+	if (!channel) {
+		dev_kfree_skb(skb);
+		return 0;
+	}
 	memset(skb->data, 0, FRAME_DESC_SZ);
 	mgmt_frame = (struct rsi_mac_frame *)skb->data;
 
 	mgmt_frame->desc_word[0] = cpu_to_le16(RSI_WIFI_MGMT_Q << 12);
 	mgmt_frame->desc_word[1] = cpu_to_le16(SCAN_REQUEST);
-	mgmt_frame->desc_word[4] = cpu_to_le16(channel);
+	mgmt_frame->desc_word[4] = cpu_to_le16(channel->hw_value);
+
+#if 0
+	channel->max_antenna_gain = common->antenna_gain;
+	mgmt_frame->desc_word[4] |=
+		cpu_to_le16(((char)(channel->max_antenna_gain)) << 8);
+	mgmt_frame->desc_word[5] =
+		cpu_to_le16((char)(channel->max_antenna_gain));
+#endif
+	mgmt_frame->desc_word[4] |=
+		cpu_to_le16(common->antenna_gain[0] << 8);
+	mgmt_frame->desc_word[5] =
+		cpu_to_le16(common->antenna_gain[1]);
 
 	mgmt_frame->desc_word[7] = cpu_to_le16(PUT_BBP_RESET |
 					       BBP_REG_WRITE |
 					       (RSI_RF_TYPE << 4));
 
-	mgmt_frame->desc_word[5] = cpu_to_le16(0x01);
-	mgmt_frame->desc_word[6] = cpu_to_le16(0x12);
+	if ((channel->flags & IEEE80211_CHAN_NO_IR) ||
+	    (channel->flags & IEEE80211_CHAN_RADAR)) {
+		mgmt_frame->desc_word[4] |= BIT(15);
+	} else {
+		if (common->tx_power < channel->max_power)
+			mgmt_frame->desc_word[6] =
+				cpu_to_le16(common->tx_power);
+		else
+			mgmt_frame->desc_word[6] =
+				cpu_to_le16(channel->max_power);
+	}
+#ifdef CONFIG_CARACALLA_BOARD
+	rsi_apply_carcalla_power_values(adapter, vif, channel);
+	mgmt_frame->desc_word[6] = cpu_to_le16(channel->max_power);
+
+	if ((channel->hw_value == 12) || (channel->hw_value == 13))
+		mgmt_frame->desc_word[7] = cpu_to_le16(TARGET_BOARD_CARACALLA);
+	if (conf_is_ht40(&adapter->hw->conf)) {
+		if ((channel->hw_value == 6) ||
+		    (channel->hw_value == 9) ||
+		    (channel->hw_value == 10))
+		mgmt_frame->desc_word[7] = cpu_to_le16(TARGET_BOARD_CARACALLA);
+	}
+#endif
+	rsi_dbg(INFO_ZONE, "reg_domain = %d, TX power = %d\n",
+		adapter->dfs_region, mgmt_frame->desc_word[6]);
+	mgmt_frame->desc_word[7] |= cpu_to_le16(adapter->dfs_region);
 
 	if (common->channel_width == BW_40MHZ)
 		mgmt_frame->desc_word[5] |= cpu_to_le16(0x1 << 8);
 
-	common->channel = channel;
+	common->channel = channel->hw_value;
 
 	skb_put(skb, FRAME_DESC_SZ);
 
@@ -950,29 +1735,179 @@ int rsi_set_channel(struct rsi_common *common, u16 channel)
 }
 
 /**
- * rsi_compare() - This function is used to compare two integers
- * @a: pointer to the first integer
- * @b: pointer to the second integer
+ * rsi_send_radio_params_update() - This function sends the radio
+ *				parameters update to device
+ * @common: Pointer to the driver private structure.
+ * @channel: Channel value to be set.
  *
- * Return: 0 if both are equal, -1 if the first is smaller, else 1
+ * Return: 0 on success, corresponding error code on failure.
  */
-static int rsi_compare(const void *a, const void *b)
+int rsi_send_radio_params_update(struct rsi_common *common)
 {
-	u16 _a = *(const u16 *)(a);
-	u16 _b = *(const u16 *)(b);
+	struct rsi_mac_frame *mgmt_frame;
+	struct sk_buff *skb = NULL;
 
-	if (_a > _b)
-		return -1;
+	rsi_dbg(MGMT_TX_ZONE,
+		"%s: Sending Radio Params update frame\n", __func__);
 
-	if (_a < _b)
-		return 1;
+	skb = dev_alloc_skb(FRAME_DESC_SZ);
+	if (!skb) {
+		rsi_dbg(ERR_ZONE, "%s: Failed in allocation of skb\n",
+			__func__);
+		return -ENOMEM;
+	}
 
-	return 0;
-}
+	memset(skb->data, 0, FRAME_DESC_SZ);
+	mgmt_frame = (struct rsi_mac_frame *)skb->data;
 
-/**
- * rsi_map_rates() - This function is used to map selected rates to hw rates.
- * @rate: The standard rate to be mapped.
+	mgmt_frame->desc_word[0] = cpu_to_le16(RSI_WIFI_MGMT_Q << 12);
+	mgmt_frame->desc_word[1] = cpu_to_le16(RADIO_PARAMS_UPDATE);
+	mgmt_frame->desc_word[3] = cpu_to_le16(BIT(0));
+
+	mgmt_frame->desc_word[3] |= cpu_to_le16(common->tx_power << 8);
+
+	skb_put(skb, FRAME_DESC_SZ);
+
+	return rsi_send_internal_mgmt_frame(common, skb);
+}
+
+/**
+ * rsi_send_vap_dynamic_update() - This function programs the threshold.
+ * @common: Pointer to the driver private structure.
+ *
+ * Return: 0 on success, corresponding error code on failure.
+ */
+int rsi_send_vap_dynamic_update(struct rsi_common *common)
+{
+	struct sk_buff *skb = NULL;
+	struct rsi_dynamic_s *dynamic_frame = NULL;
+
+	rsi_dbg(MGMT_TX_ZONE,
+		"%s: Sending vap update indication frame\n", __func__);
+
+	skb = dev_alloc_skb(sizeof(struct rsi_dynamic_s));
+	if (!skb) {
+		rsi_dbg(ERR_ZONE, "%s: Failed in allocation of skb\n",
+			__func__);
+		return -ENOMEM;
+	}
+
+	memset(skb->data, 0, sizeof(struct rsi_dynamic_s));
+	dynamic_frame = (struct rsi_dynamic_s *)skb->data;
+
+	dynamic_frame->desc_word[0] = cpu_to_le16(
+					(sizeof(dynamic_frame->frame_body)) |
+					(RSI_WIFI_MGMT_Q << 12));
+	dynamic_frame->desc_word[1] = cpu_to_le16(VAP_DYNAMIC_UPDATE);
+	dynamic_frame->desc_word[4] = cpu_to_le16(common->rts_threshold);
+#if 0
+	dynamic_frame->desc_word[5] = cpu_to_le16(common->frag_threshold);
+	dynamic_frame->desc_word[5] = cpu_to_le16(2352);
+#endif
+
+#ifdef CONFIG_RSI_WOW
+//	if (common->suspend_flag) {
+	if (1) {
+		dynamic_frame->desc_word[6] =
+			cpu_to_le16(24); /* bmiss_threshold */
+		dynamic_frame->frame_body.keep_alive_period =
+			cpu_to_le16(5);
+	} else
+		dynamic_frame->frame_body.keep_alive_period = cpu_to_le16(90);
+#else
+	dynamic_frame->frame_body.keep_alive_period = cpu_to_le16(90);
+#endif
+
+#if 0
+	dynamic_frame->frame_body.mgmt_rate = cpu_to_le32(RSI_RATE_6);
+
+	dynamic_frame->desc_word[2] |= cpu_to_le32(BIT(1));/* Self cts enable */
+
+	dynamic_frame->desc_word[3] |= cpu_to_le16(BIT(0));/* fixed rate */
+	dynamic_frame->frame_body.data_rate = cpu_to_le16(0);
+#endif
+
+	dynamic_frame->desc_word[7] |= cpu_to_le16((0 << 8)); /* vap id */
+
+	skb_put(skb, sizeof(struct rsi_dynamic_s));
+
+	return rsi_send_internal_mgmt_frame(common, skb);
+}
+
+/**
+ * rsi_flash_read() - This function sends the frash read frame to device
+ * @adapter: Pointer to the hardware structure.
+ *
+ * Return: status: 0 on success, -1 on failure.
+ */
+int rsi_flash_read(struct rsi_hw *adapter)
+{
+	struct rsi_common *common = adapter->priv;
+	struct rsi_mac_frame *cmd_frame = NULL;
+	struct sk_buff *skb;
+
+	rsi_dbg(MGMT_TX_ZONE, "%s: Sending flash read frame\n", __func__);
+
+	skb = dev_alloc_skb(FRAME_DESC_SZ);
+	if (!skb)
+		return -ENOMEM;
+
+	memset(skb->data, 0, FRAME_DESC_SZ);
+	cmd_frame = (struct rsi_mac_frame *)skb->data;
+
+	/* FrameType */
+	cmd_frame->desc_word[1] = cpu_to_le16(EEPROM_READ);
+
+	/* Format of length and offset differs for
+	 * autoflashing and swbl flashing
+	 */
+	cmd_frame->desc_word[0] = cpu_to_le16(RSI_WIFI_MGMT_Q << 12);
+
+	/* Number of bytes to read */
+	rsi_dbg(INFO_ZONE, " eeprom length  0x%x, %d\n",
+		adapter->eeprom.length, adapter->eeprom.length);
+	cmd_frame->desc_word[3] = cpu_to_le16(adapter->eeprom.length << 4);
+
+	cmd_frame->desc_word[2] |= cpu_to_le16(3 << 8);
+	if (adapter->eeprom_init) {
+		rsi_dbg(INFO_ZONE, "spi init sent");
+		cmd_frame->desc_word[2] |= cpu_to_le16(BIT(13));
+	}
+
+	/* Address to read */
+	cmd_frame->desc_word[4] = cpu_to_le16(adapter->eeprom.offset);
+	cmd_frame->desc_word[5] = cpu_to_le16(adapter->eeprom.offset >> 16);
+	cmd_frame->desc_word[6] = cpu_to_le16(0); //delay = 0
+
+	skb_put(skb, FRAME_DESC_SZ);
+
+	return rsi_send_internal_mgmt_frame(common, skb);
+}
+
+/**
+ * rsi_compare() - This function is used to compare two integers
+ * @a: pointer to the first integer
+ * @b: pointer to the second integer
+ *
+ * Return: 0 if both are equal, -1 if the first is smaller, else 1
+ */
+static int rsi_compare(const void *a, const void *b)
+{
+	u16 _a = *(const u16 *)(a);
+	u16 _b = *(const u16 *)(b);
+
+	if (_a > _b)
+		return -1;
+
+	if (_a < _b)
+		return 1;
+
+	return 0;
+}
+
+/**
+ * rsi_map_rates() - This function is used to map selected rates to hw rates.
+ * @rate: The standard rate to be mapped.
  * @offset: Offset that will be returned.
  *
  * Return: 0 if it is a mcs rate, else 1
@@ -980,6 +1915,7 @@ static int rsi_compare(const void *a, const void *b)
 static bool rsi_map_rates(u16 rate, int *offset)
 {
 	int kk;
+
 	for (kk = 0; kk < ARRAY_SIZE(rsi_mcsrates); kk++) {
 		if (rate == mcs[kk]) {
 			*offset = kk;
@@ -1003,8 +1939,11 @@ static bool rsi_map_rates(u16 rate, int *offset)
  *
  * Return: 0 on success, corresponding error code on failure.
  */
-static int rsi_send_auto_rate_request(struct rsi_common *common)
+static int rsi_send_auto_rate_request(struct rsi_common *common,
+				      struct ieee80211_sta *sta,
+				      u16 sta_id)
 {
+	struct ieee80211_vif *vif = common->priv->vifs[0];
 	struct sk_buff *skb;
 	struct rsi_auto_rate *auto_rate;
 	int ii = 0, jj = 0, kk = 0;
@@ -1012,17 +1951,22 @@ static int rsi_send_auto_rate_request(struct rsi_common *common)
 	u8 band = hw->conf.chandef.chan->band;
 	u8 num_supported_rates = 0;
 	u8 rate_table_offset, rate_offset = 0;
-	u32 rate_bitmap = common->bitrate_mask[band];
-
+	u32 rate_bitmap = 0;
 	u16 *selected_rates, min_rate;
+	bool is_ht = false, is_sgi = false;
+
+	rsi_dbg(MGMT_TX_ZONE,
+		"%s: Sending auto rate request frame\n", __func__);
 
-	skb = dev_alloc_skb(sizeof(struct rsi_auto_rate));
+	skb = dev_alloc_skb(MAX_MGMT_PKT_SIZE);
 	if (!skb) {
 		rsi_dbg(ERR_ZONE, "%s: Failed in allocation of skb\n",
 			__func__);
 		return -ENOMEM;
 	}
 
+	memset(skb->data, 0, MAX_MGMT_PKT_SIZE);
+
 	selected_rates = kzalloc(2 * RSI_TBL_SZ, GFP_KERNEL);
 	if (!selected_rates) {
 		rsi_dbg(ERR_ZONE, "%s: Failed in allocation of mem\n",
@@ -1030,8 +1974,7 @@ static int rsi_send_auto_rate_request(struct rsi_common *common)
 		dev_kfree_skb(skb);
 		return -ENOMEM;
 	}
-
-	memset(skb->data, 0, sizeof(struct rsi_auto_rate));
+	memset(selected_rates, 0, 2 * RSI_TBL_SZ);
 
 	auto_rate = (struct rsi_auto_rate *)skb->data;
 
@@ -1044,13 +1987,34 @@ static int rsi_send_auto_rate_request(struct rsi_common *common)
 	auto_rate->desc_word[1] = cpu_to_le16(AUTO_RATE_IND);
 
 	if (common->channel_width == BW_40MHZ)
-		auto_rate->desc_word[7] |= cpu_to_le16(1);
+		auto_rate->desc_word[7] = cpu_to_le16(1);
+	auto_rate->desc_word[7] |= cpu_to_le16(sta_id << 8);
+
+	if (vif->type == NL80211_IFTYPE_STATION) {
+		rate_bitmap = common->bitrate_mask[band];
+		is_ht = common->vif_info[0].is_ht;
+		is_sgi = common->vif_info[0].sgi;
+	} else {
+		rate_bitmap = sta->supp_rates[band];
+		is_ht = sta->ht_cap.ht_supported;
+		if ((sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_20) ||
+		    (sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_40))
+			is_sgi = true;
+	}
+	rsi_dbg(INFO_ZONE, "rate_bitmap = %x\n", rate_bitmap);
+	rsi_dbg(INFO_ZONE, "is_ht = %d\n", is_ht);
 
 	if (band == NL80211_BAND_2GHZ) {
-		min_rate = RSI_RATE_1;
+		if ((rate_bitmap == 0) && (is_ht))
+			min_rate = RSI_RATE_MCS0;
+		else
+			min_rate = RSI_RATE_1;
 		rate_table_offset = 0;
 	} else {
-		min_rate = RSI_RATE_6;
+		if ((rate_bitmap == 0) && (is_ht))
+			min_rate = RSI_RATE_MCS0;
+		else
+			min_rate = RSI_RATE_6;
 		rate_table_offset = 4;
 	}
 
@@ -1064,7 +2028,7 @@ static int rsi_send_auto_rate_request(struct rsi_common *common)
 	}
 	num_supported_rates = jj;
 
-	if (common->vif_info[0].is_ht) {
+	if (is_ht) {
 		for (ii = 0; ii < ARRAY_SIZE(mcs); ii++)
 			selected_rates[jj++] = mcs[ii];
 		num_supported_rates += ARRAY_SIZE(mcs);
@@ -1085,13 +2049,16 @@ static int rsi_send_auto_rate_request(struct rsi_common *common)
 	}
 
 	/* loading HT rates in the bottom half of the auto rate table */
-	if (common->vif_info[0].is_ht) {
+	if (is_ht) {
 		for (ii = rate_offset, kk = ARRAY_SIZE(rsi_mcsrates) - 1;
 		     ii < rate_offset + 2 * ARRAY_SIZE(rsi_mcsrates); ii++) {
-			if (common->vif_info[0].sgi ||
-			    conf_is_ht40(&common->priv->hw->conf))
+			if (is_sgi || conf_is_ht40(&common->priv->hw->conf)) {
 				auto_rate->supported_rates[ii++] =
-					cpu_to_le16(rsi_mcsrates[kk] | BIT(9));
+					cpu_to_le16(rsi_mcsrates[kk]/* | BIT(9)*/);
+			} else {
+				auto_rate->supported_rates[ii++] =
+					cpu_to_le16(rsi_mcsrates[kk]);
+			}
 			auto_rate->supported_rates[ii] =
 				cpu_to_le16(rsi_mcsrates[kk--]);
 		}
@@ -1107,21 +2074,209 @@ static int rsi_send_auto_rate_request(struct rsi_common *common)
 
 	auto_rate->num_supported_rates = cpu_to_le16(num_supported_rates * 2);
 	auto_rate->moderate_rate_inx = cpu_to_le16(num_supported_rates / 2);
-	auto_rate->desc_word[7] |= cpu_to_le16(0 << 8);
 	num_supported_rates *= 2;
 
 	auto_rate->desc_word[0] = cpu_to_le16((sizeof(*auto_rate) -
-					       FRAME_DESC_SZ) |
-					       (RSI_WIFI_MGMT_Q << 12));
+					      FRAME_DESC_SZ) |
+					      (RSI_WIFI_MGMT_Q << 12));
 
-	skb_put(skb,
-		sizeof(struct rsi_auto_rate));
+	skb_put(skb, sizeof(struct rsi_auto_rate));
 	kfree(selected_rates);
 
 	return rsi_send_internal_mgmt_frame(common, skb);
 }
 
 /**
+ * rsi_validate_bgscan_channels() - This function is used to validate
+ *				the user configured bgscan channels for
+ *				current regulatory domain
+ * @chn_num: It holds the user or default channel for validation.
+ *
+ * Return: 0 on success, corresponding error code on failure.
+ */
+void rsi_validate_bgscan_channels(struct rsi_hw *adapter,
+				  struct bgscan_config_params *params)
+{
+	struct ieee80211_supported_band *sband;
+	struct ieee80211_channel *ch;
+	struct wiphy *wiphy = adapter->hw->wiphy; 
+	u16 bgscan_channels[MAX_BGSCAN_CHANNELS] = {1, 2, 3, 4, 5, 6, 7, 8, 9,
+						    10, 11, 12, 13, 14, 36, 40,
+						    44, 48, 52, 56, 60, 64, 100,
+						    104, 108, 112, 116, 120, 124,
+						    128, 132, 136, 140, 149, 153,
+						    157, 161, 165};
+
+	int ch_num, i;
+	int num_valid_chs = 0, cnt;
+
+	/* If user passes 0 for num of bgscan channels, take all channels */
+	if (params->num_user_channels == 0) {
+		if (adapter->priv->num_supp_bands > 1)
+			params->num_user_channels = MAX_BGSCAN_CHANNELS;
+		else
+			params->num_user_channels = 14;
+
+		for (cnt = 0; cnt < params->num_user_channels; cnt++)
+			params->user_channels[cnt] = bgscan_channels[cnt];
+	}
+
+	rsi_dbg(INFO_ZONE, "Final bgscan channels:\n");
+	for (cnt = 0; cnt < params->num_user_channels; cnt++) {
+		ch_num = params->user_channels[cnt];
+
+		if ((ch_num < 1) ||
+		    ((ch_num > 14) && (ch_num < 36)) ||
+		    ((ch_num > 64) && (ch_num < 100)) ||
+		    ((ch_num > 140) && (ch_num < 149)) ||
+		    (ch_num > 165))
+			continue;
+		if ((ch_num >= 36) && (ch_num < 149) && (ch_num % 4))
+			continue;
+
+		if (ch_num > 14)
+			sband = wiphy->bands[NL80211_BAND_5GHZ];
+		else
+			sband = wiphy->bands[NL80211_BAND_2GHZ];
+
+		for (i = 0; i < sband->n_channels; i++) {
+			ch = &sband->channels[i];
+
+			if (ch->hw_value == ch_num)
+				break;
+		}
+		if (i >= sband->n_channels)
+			continue;
+
+		/* Check channel availablity for the current reg domain */
+		if (ch->flags & IEEE80211_CHAN_DISABLED)
+			continue;
+
+		params->channels2scan[num_valid_chs] = ch_num;
+		rsi_dbg(INFO_ZONE, "%d ", ch_num);
+		if ((ch->flags & IEEE80211_CHAN_NO_IR) ||
+		    (ch->flags & IEEE80211_CHAN_RADAR)) {
+			if((ch->flags & IEEE80211_CHAN_RADAR))
+				rsi_dbg(INFO_ZONE, "[DFS]");
+			params->channels2scan[num_valid_chs] |=
+				(cpu_to_le16(BIT(15))); /* DFS indication */
+		}
+		num_valid_chs++;
+	}
+
+	params->num_bg_channels = num_valid_chs;
+}
+
+/**
+ * rsi_send_bgscan_params() - This function sends the background
+ *			      scan parameters to firmware.
+ * @common: Pointer to the driver private structure.
+ * @enable: bgscan enable/disable
+ *
+ * Return: 0 on success, corresponding error code on failure.
+ */
+int rsi_send_bgscan_params(struct rsi_common *common, int enable)
+{
+	struct rsi_bgscan_params *bgscan;
+	struct bgscan_config_params *info = &common->bgscan_info;
+	struct sk_buff *skb;
+	u16 frame_len = sizeof(*bgscan);
+
+	rsi_dbg(MGMT_TX_ZONE, "%s: Sending bgscan params frame\n", __func__);
+
+	rsi_validate_bgscan_channels(common->priv, info);
+	if (!info->num_bg_channels) {
+		rsi_dbg(ERR_ZONE, "##### No valid bgscan channels #####\n");
+		return -1;
+	}
+	
+	skb = dev_alloc_skb(frame_len);
+	if (!skb)
+		return -ENOMEM;
+	memset(skb->data, 0, frame_len);
+
+	bgscan = (struct rsi_bgscan_params *)skb->data;
+
+	bgscan->desc_word[0] = cpu_to_le16((frame_len - FRAME_DESC_SZ) |
+					   (RSI_WIFI_MGMT_Q << 12));
+	bgscan->desc_word[1] = cpu_to_le16(BG_SCAN_PARAMS);
+
+	bgscan->bgscan_threshold = cpu_to_le16(info->bgscan_threshold);
+	bgscan->roam_threshold = cpu_to_le16(info->roam_threshold);
+	if (enable) {
+		bgscan->bgscan_periodicity =
+			cpu_to_le16(info->bgscan_periodicity);
+	}
+	bgscan->active_scan_duration =
+			cpu_to_le16(info->active_scan_duration);
+	bgscan->passive_scan_duration =
+			cpu_to_le16(info->passive_scan_duration);
+	bgscan->two_probe = info->two_probe;
+
+	memcpy(bgscan->channels2scan,
+	       info->channels2scan,
+	       info->num_bg_channels * 2);
+	bgscan->num_bg_channels = info->num_bg_channels;
+
+	skb_put(skb, frame_len);
+
+	rsi_hex_dump(MGMT_TX_ZONE, "bgscan params req", skb->data, skb->len);
+
+	return rsi_send_internal_mgmt_frame(common, skb);
+}
+
+/**
+ * rsi_send_bgscan_probe_req() - This function sends the background
+ *                               scan probe request to firmware.
+ * @common: Pointer to the driver private structure.
+ *
+ * Return: 0 on success, corresponding error code on failure.
+ */
+int rsi_send_bgscan_probe_req(struct rsi_common *common)
+{
+	struct rsi_bgscan_probe *bgscan;
+	struct sk_buff *skb;
+	u16 frame_len = sizeof(*bgscan);
+	u16 len = 1500;
+	u16 pbreq_len = 0;
+
+	rsi_dbg(MGMT_TX_ZONE,
+		"%s: Sending bgscan probe req frame\n", __func__);
+
+	skb = dev_alloc_skb(frame_len + len);
+	if (!skb)
+		return -ENOMEM;
+	memset(skb->data, 0, frame_len + len);
+
+	bgscan = (struct rsi_bgscan_probe *)skb->data;
+
+	bgscan->desc_word[1] = cpu_to_le16(BG_SCAN_PROBE_REQ);
+	bgscan->flags = cpu_to_le16(HOST_BG_SCAN_TRIG);
+	if (common->band == NL80211_BAND_5GHZ) {
+		bgscan->mgmt_rate = cpu_to_le16(RSI_RATE_6);
+		bgscan->channel_num = cpu_to_le16(40);
+	} else {
+		bgscan->mgmt_rate = cpu_to_le16(RSI_RATE_1);
+		bgscan->channel_num = cpu_to_le16(11);
+	}
+
+	bgscan->channel_scan_time = cpu_to_le16(20);
+	if (common->bgscan_probe_req_len > 0) {
+		pbreq_len = common->bgscan_probe_req_len;
+		bgscan->probe_req_length = pbreq_len;
+		memcpy(&skb->data[frame_len], common->bgscan_probe_req,
+		       common->bgscan_probe_req_len);
+	}
+
+	bgscan->desc_word[0] = cpu_to_le16((frame_len - FRAME_DESC_SZ + pbreq_len) |
+					   (RSI_WIFI_MGMT_Q << 12));
+
+	skb_put(skb, frame_len + pbreq_len);
+
+	return rsi_send_internal_mgmt_frame(common, skb);
+}
+
+/**
  * rsi_inform_bss_status() - This function informs about bss status with the
  *			     help of sta notify params by sending an internal
  *			     management frame to firmware.
@@ -1134,27 +2289,53 @@ static int rsi_send_auto_rate_request(struct rsi_common *common)
  * Return: None.
  */
 void rsi_inform_bss_status(struct rsi_common *common,
+			   enum opmode opmode,
 			   u8 status,
-			   const unsigned char *bssid,
+			   const u8 *bssid,
 			   u8 qos_enable,
-			   u16 aid)
+			   u16 aid,
+			   struct ieee80211_sta *sta,
+			   u16 sta_id, u16 assoc_cap)
 {
 	if (status) {
-		rsi_hal_send_sta_notify_frame(common,
-					      RSI_IFTYPE_STATION,
-					      STA_CONNECTED,
-					      bssid,
-					      qos_enable,
-					      aid);
-		if (common->min_rate == 0xffff)
-			rsi_send_auto_rate_request(common);
+		if (opmode == STA_OPMODE)
+			common->hw_data_qs_blocked = true;
+		rsi_send_sta_notify_frame(common,
+					  opmode,
+					  STA_CONNECTED,
+					  bssid,
+					  qos_enable,
+					  aid,
+					  sta_id);
+		if (common->min_rate == 0xffff) {
+			rsi_dbg(INFO_ZONE, "Send auto rate request\n");
+			rsi_send_auto_rate_request(common, sta, sta_id);
+		}
+		if (opmode == STA_OPMODE) {
+			if (!(assoc_cap & BIT(4))) {	
+				rsi_dbg(INFO_ZONE, "unblock data in Open case\n");
+				if (!rsi_send_block_unblock_frame(common, false))
+					common->hw_data_qs_blocked = false;
+			}
+		}
 	} else {
-		rsi_hal_send_sta_notify_frame(common,
-					      RSI_IFTYPE_STATION,
-					      STA_DISCONNECTED,
-					      bssid,
-					      qos_enable,
-					      aid);
+		if (opmode == STA_OPMODE)
+			common->hw_data_qs_blocked = true;
+#ifdef CONFIG_RSI_WOW
+		if (!(common->wow_flags & RSI_WOW_ENABLED)) {
+#endif
+		rsi_send_sta_notify_frame(common,
+					  opmode,
+					  STA_DISCONNECTED,
+					  bssid,
+					  qos_enable,
+					  aid,
+					  sta_id);
+#ifdef CONFIG_RSI_WOW
+		}
+#endif
+		if (opmode == STA_OPMODE)
+			rsi_send_block_unblock_frame(common, true);
 	}
 }
 
@@ -1167,10 +2348,12 @@ void rsi_inform_bss_status(struct rsi_common *common,
  */
 static int rsi_eeprom_read(struct rsi_common *common)
 {
-	struct rsi_mac_frame *mgmt_frame;
+	struct rsi_mac_frame *mgmt_frame = NULL;
+	struct rsi_hw *adapter = common->priv;
 	struct sk_buff *skb;
 
-	rsi_dbg(MGMT_TX_ZONE, "%s: Sending EEPROM read req frame\n", __func__);
+	rsi_dbg(MGMT_TX_ZONE,
+		"%s: Sending EEPROM read req frame\n", __func__);
 
 	skb = dev_alloc_skb(FRAME_DESC_SZ);
 	if (!skb) {
@@ -1183,15 +2366,17 @@ static int rsi_eeprom_read(struct rsi_common *common)
 	mgmt_frame = (struct rsi_mac_frame *)skb->data;
 
 	/* FrameType */
-	mgmt_frame->desc_word[1] = cpu_to_le16(EEPROM_READ_TYPE);
+	mgmt_frame->desc_word[1] = cpu_to_le16(EEPROM_READ);
 	mgmt_frame->desc_word[0] = cpu_to_le16(RSI_WIFI_MGMT_Q << 12);
+
 	/* Number of bytes to read */
-	mgmt_frame->desc_word[3] = cpu_to_le16(ETH_ALEN +
-					       WLAN_MAC_MAGIC_WORD_LEN +
-					       WLAN_HOST_MODE_LEN +
-					       WLAN_FW_VERSION_LEN);
-	/* Address to read */
-	mgmt_frame->desc_word[4] = cpu_to_le16(WLAN_MAC_EEPROM_ADDR);
+	mgmt_frame->desc_word[3] = cpu_to_le16(adapter->eeprom.length << 4);
+	mgmt_frame->desc_word[2] |= cpu_to_le16(3 << 8);
+
+	/* Address to read*/
+	mgmt_frame->desc_word[4] = cpu_to_le16(adapter->eeprom.offset);
+	mgmt_frame->desc_word[5] = cpu_to_le16(adapter->eeprom.offset >> 16);
+	mgmt_frame->desc_word[6] = cpu_to_le16(0); //delay = 0
 
 	skb_put(skb, FRAME_DESC_SZ);
 
@@ -1225,44 +2410,806 @@ int rsi_send_block_unblock_frame(struct rsi_common *common, bool block_event)
 
 	mgmt_frame->desc_word[0] = cpu_to_le16(RSI_WIFI_MGMT_Q << 12);
 	mgmt_frame->desc_word[1] = cpu_to_le16(BLOCK_HW_QUEUE);
+	mgmt_frame->desc_word[3] = cpu_to_le16(0x1);
 
-	if (block_event) {
+	if (block_event == true) {
 		rsi_dbg(INFO_ZONE, "blocking the data qs\n");
 		mgmt_frame->desc_word[4] = cpu_to_le16(0xf);
+		mgmt_frame->desc_word[4] |= cpu_to_le16(0xf << 4);
 	} else {
 		rsi_dbg(INFO_ZONE, "unblocking the data qs\n");
 		mgmt_frame->desc_word[5] = cpu_to_le16(0xf);
+		mgmt_frame->desc_word[5] |= cpu_to_le16(0xf << 4);
 	}
 
 	skb_put(skb, FRAME_DESC_SZ);
 
 	return rsi_send_internal_mgmt_frame(common, skb);
+}
+
+/**
+ * This function sends a frame to filter the RX packets
+ *
+ * @param common Pointer to the driver private structure.
+ * @param rx_filter_word - Flags of filter packets
+ * @return 0 on success, -1 on failure.
+ */
+int rsi_send_rx_filter_frame(struct rsi_common *common, u16 rx_filter_word)
+{
+	struct rsi_mac_frame *mgmt_frame;
+	struct sk_buff *skb;
+
+	rsi_dbg(MGMT_TX_ZONE, "%s: Sending RX filter frame\n", __func__);
+
+	skb = dev_alloc_skb(FRAME_DESC_SZ);
+	if (!skb) {
+		rsi_dbg(ERR_ZONE, "%s: Failed in allocation of skb\n",
+			__func__);
+		return -ENOMEM;
+	}
+
+	memset(skb->data, 0, FRAME_DESC_SZ);
+	mgmt_frame = (struct rsi_mac_frame *)skb->data;
+
+	mgmt_frame->desc_word[0] = cpu_to_le16(RSI_WIFI_MGMT_Q << 12);
+	mgmt_frame->desc_word[1] = cpu_to_le16(SET_RX_FILTER);
+	mgmt_frame->desc_word[4] = cpu_to_le16(rx_filter_word);
+
+	skb_put(skb, FRAME_DESC_SZ);
 
+	return rsi_send_internal_mgmt_frame(common, skb);
 }
+EXPORT_SYMBOL_GPL(rsi_send_rx_filter_frame); 
 
+/**
+ * rsi_send_ps_request() - Sends power save request.
+ *
+ * @adapter: pointer to rsi_hw structure.
+ * @enable: enable or disable power save.
+ *
+ * returns: 0 on success, negative error code on failure
+ */
+int rsi_send_ps_request(struct rsi_hw *adapter, bool enable)
+{
+	struct rsi_common *common = adapter->priv;
+	struct ieee80211_bss_conf *bss = &adapter->vifs[0]->bss_conf;
+	struct rsi_request_ps *ps = NULL;
+	struct rsi_ps_info *ps_info = NULL;
+	struct sk_buff *skb = NULL;
+	int frame_len = sizeof(*ps);
+
+	skb = dev_alloc_skb(frame_len);
+	if (!skb)
+		return -ENOMEM;
+	memset(skb->data, 0, frame_len);
+
+	ps = (struct rsi_request_ps *)&skb->data[0];
+	ps_info = &adapter->ps_info;
+
+	ps->desc_word[0] = cpu_to_le16((frame_len - FRAME_DESC_SZ) |
+				       (RSI_WIFI_MGMT_Q << 12));
+	ps->desc_word[1] = cpu_to_le16(WAKEUP_SLEEP_REQUEST);
+	if (enable) {
+		ps->ps_sleep.enable = 1;
+		ps->desc_word[6] = SLEEP_REQUEST;
+	} else {
+		ps->ps_sleep.enable = 0;
+		ps->desc_word[0] |= BIT(15);
+		ps->desc_word[6] = WAKEUP_REQUEST;
+	}
+
+	if (common->uapsd_bitmap) {
+//		ps->ps_mimic_support = 1;
+		ps->ps_uapsd_acs = common->uapsd_bitmap;
+		ps->ps_uapsd_acs = (adapter->hw->uapsd_max_sp_len <<
+				    IEEE80211_WMM_IE_STA_QOSINFO_SP_SHIFT) |
+				    IEEE80211_WMM_IE_STA_QOSINFO_AC_MASK;
+		ps->ps_uapsd_wakeup_period = RSI_UAPSD_WAKEUP_PERIOD;
+	}
+
+	ps->ps_sleep.sleep_type = ps_info->sleep_type;
+	ps->ps_sleep.num_bcns_per_lis_int =
+		cpu_to_le16(ps_info->num_bcns_per_lis_int);
+	ps->ps_sleep.sleep_duration =
+		cpu_to_le32(ps_info->deep_sleep_wakeup_period);
+
+	if (bss->assoc)
+		ps->ps_sleep.connected_sleep = CONNECTED_SLEEP;
+	else
+		ps->ps_sleep.connected_sleep = DEEP_SLEEP;
+
+	ps->ps_listen_interval = cpu_to_le32(ps_info->listen_interval);
+	ps->ps_dtim_interval_duration = RSI_DEFAULT_DTIM_INTERVAL;
+
+	if (ps->ps_listen_interval > ps->ps_dtim_interval_duration)
+		ps->ps_listen_interval = 0;
+
+	skb_put(skb, frame_len);
+
+	return rsi_send_internal_mgmt_frame(common, skb);
+}
 
 /**
- * rsi_handle_ta_confirm_type() - This function handles the confirm frames.
+ * rsi_set_antenna() - This fuction handles antenna selection functionality.
+ *
+ * @common: Pointer to the driver private structure.
+ * @antenna: bitmap for tx antenna selection
+ *
+ * Return: 0 on Success, < 0 on failure
+ */
+int rsi_set_antenna(struct rsi_common *common,
+		    u8 antenna)
+{
+	struct rsi_mac_frame *mgmt_frame;
+	struct sk_buff *skb;
+
+	skb = dev_alloc_skb(FRAME_DESC_SZ);
+	if (!skb) {
+		rsi_dbg(ERR_ZONE, "%s: Failed in allocation of skb\n",
+			__func__);
+		return -ENOMEM;
+	}
+
+	memset(skb->data, 0, FRAME_DESC_SZ);
+	mgmt_frame = (struct rsi_mac_frame *)skb->data;
+
+	mgmt_frame->desc_word[1] = cpu_to_le16(ANT_SEL_FRAME);
+	mgmt_frame->desc_word[2] = cpu_to_le16(1 << 8); /* Antenna selection
+							   type */
+	mgmt_frame->desc_word[3] = cpu_to_le16(antenna & 0x00ff);
+	mgmt_frame->desc_word[0] = cpu_to_le16(RSI_WIFI_MGMT_Q << 12);
+
+	skb_put(skb, FRAME_DESC_SZ);
+
+	return rsi_send_internal_mgmt_frame(common, skb);
+}
+
+#ifdef CONFIG_RSI_11K
+int rsi_get_channel_load_meas(struct rsi_common *common,
+			      struct rsi_meas_params chl_meas)
+{
+	struct rsi_mac_frame *cmd_frame;
+	struct sk_buff *skb;
+	u8 channel_width;
+	u8 dfs = 0;
+
+	rsi_dbg(MGMT_TX_ZONE, " %s: Sending channel load request frame\n",
+		__func__);
+
+	skb = dev_alloc_skb(FRAME_DESC_SZ);
+	if (!skb)
+		return -ENOMEM;
+	memset(skb->data, 0, FRAME_DESC_SZ);
+
+	cmd_frame = (struct rsi_mac_frame *)skb->data;
+
+	channel_width = ieee80211_chan_to_bw(common->priv,
+					     chl_meas.regulatory_class,
+					     chl_meas.channel_num);
+
+	dfs = is_dfs_channel(common->priv, chl_meas.channel_num);
+
+	if (dfs == 1)
+		rsi_dbg(ERR_ZONE, "Requested channel is DFS\n");
+	else
+		rsi_dbg(ERR_ZONE, "Requested channel is NON DFS\n");
+
+	rsi_dbg(INFO_ZONE, "Regulatory value %d\n", chl_meas.regulatory_class);
+	rsi_dbg(INFO_ZONE, "channel_Num value %d\n", chl_meas.channel_num);
+	rsi_dbg(INFO_ZONE, "Meas_duration value %d\n", chl_meas.meas_duration);
+	rsi_dbg(INFO_ZONE, "rand_interval value %d\n", chl_meas.rand_interval);
+	rsi_dbg(INFO_ZONE, "channel_width value %d\n", chl_meas.channel_width);
+	rsi_dbg(INFO_ZONE, "meas_req_mode value %d\n", chl_meas.meas_req_mode);
+	rsi_dbg(INFO_ZONE, "meas_type value %d\n", chl_meas.meas_type);
+
+	switch (channel_width) {
+	case RSI_BW_5:
+		channel_width = 0;
+		break;
+	case RSI_BW_10:
+		channel_width = 1;
+		break;
+	case RSI_BW_20:
+		channel_width = 2;
+		break;
+	case RSI_BW_25:
+		channel_width = 2;
+		break;
+	case RSI_BW_40:
+		channel_width = 3;
+		break;
+	default:
+		channel_width = 4;
+		break;
+	}
+	rsi_dbg(INFO_ZONE, "Channel_width = %d\n", channel_width);
+
+	cmd_frame->desc_word[0] = cpu_to_le16(RSI_WIFI_MGMT_Q << 12);
+	cmd_frame->desc_word[1] = cpu_to_le16(RADIO_MEASUREMENT_REQ);
+	cmd_frame->desc_word[2] = cpu_to_le16(chl_meas.meas_type << 8);
+	cmd_frame->desc_word[3] = cpu_to_le16(chl_meas.meas_req_mode);
+	cmd_frame->desc_word[3] |=
+		cpu_to_le16(((u16)chl_meas.channel_num) << 8);
+	cmd_frame->desc_word[4] = cpu_to_le16(chl_meas.meas_duration);
+	cmd_frame->desc_word[5] = cpu_to_le16(chl_meas.rand_interval);
+	cmd_frame->desc_word[6] = cpu_to_le16(dfs << 8);
+	cmd_frame->desc_word[6] |= cpu_to_le16(channel_width);
+
+	skb_put(skb, FRAME_DESC_SZ);
+
+	return rsi_send_internal_mgmt_frame(common, skb);
+}
+
+int rsi_get_frame_meas(struct rsi_common *common,
+		       struct rsi_frame_meas_params params)
+{
+	struct rsi_frame_meas_req *cmd_frame;
+	struct sk_buff *skb;
+	u8 channel_width, length;
+	int ret;
+
+	rsi_dbg(MGMT_TX_ZONE, "%s: Sending frame request frame\n", __func__);
+
+	skb = dev_alloc_skb(sizeof(*cmd_frame));
+	if (!skb)
+		return -ENOMEM;
+
+	memset(skb->data, 0, sizeof(*cmd_frame));
+	cmd_frame = (struct rsi_frame_meas_req *)skb->data;
+
+	channel_width = ieee80211_chan_to_bw(common->priv,
+					     params.mp.regulatory_class,
+					     params.mp.channel_num);
+	if (channel_width == RSI_BW_5)
+		channel_width = 0;
+	else if (channel_width == RSI_BW_10)
+		channel_width = 1;
+	else if (channel_width == RSI_BW_20)
+		channel_width = 2;
+	else if (channel_width == RSI_BW_25)
+		channel_width = 2;
+	else if (channel_width == RSI_BW_40)
+		channel_width = 3;
+	else
+		channel_width = 4;
+	rsi_dbg(INFO_ZONE, "channel_width = %d\n", channel_width);
+
+	ret = is_dfs_channel(common->priv, params.mp.channel_num);
+	if (ret == 1)
+		rsi_dbg(ERR_ZONE, "Requested channel is DFS\n");
+	else
+		rsi_dbg(ERR_ZONE, "Requested channel is NON DFS\n");
+
+	cmd_frame->desc_word[0] = cpu_to_le16(RSI_WIFI_MGMT_Q << 12);
+	cmd_frame->desc_word[1] |= cpu_to_le16(RADIO_MEASUREMENT_REQ);
+	cmd_frame->desc_word[2] = cpu_to_le16(params.mp.meas_type << 8);
+	cmd_frame->desc_word[3] = cpu_to_le16(params.mp.meas_req_mode);
+	cmd_frame->desc_word[3] |= cpu_to_le16(((u16)params.mp.channel_num) << 8);
+	cmd_frame->desc_word[4] = cpu_to_le16(params.mp.meas_duration);
+	cmd_frame->desc_word[5] = cpu_to_le16(params.mp.rand_interval);
+	cmd_frame->desc_word[6] = cpu_to_le16(ret << 8);
+	cmd_frame->desc_word[6] |= cpu_to_le16(channel_width);
+
+	memcpy(cmd_frame->bssid, params.mac_addr, IEEE80211_ADDR_LEN);
+	cmd_frame->frm_req_type = params.frame_req_type;
+
+	length = FRAME_DESC_SZ + IEEE80211_ADDR_LEN + 1;
+	cmd_frame->desc_word[0] |= cpu_to_le16(length - FRAME_DESC_SZ);
+	cmd_frame->desc_word[2] |= cpu_to_le16(0);
+
+	skb_put(skb, length);
+
+	return rsi_send_internal_mgmt_frame(common, skb);
+}
+
+int rsi_get_beacon_meas(struct rsi_common *common,
+			struct rsi_beacon_meas_params params)
+{
+	struct rsi_bcn_meas_req *beacon_req = NULL;
+	struct sk_buff *skb = NULL;
+	u8 channel_width = 0, dfs;
+	u8 index, length = 0;
+
+	rsi_dbg(ERR_ZONE, "%s: Sending request to get beacon measurements\n",
+		__func__);
+
+	skb = dev_alloc_skb(MAX_MGMT_PKT_SIZE);
+	if (!skb)
+		return -ENOMEM;
+	beacon_req = (struct rsi_bcn_meas_req *)skb->data;
+	channel_width = ieee80211_chan_to_bw(common->priv,
+					     params.mp.regulatory_class,
+					     params.mp.channel_num);
+	if (channel_width == RSI_BW_5)
+		channel_width = 0;
+	else if (channel_width == RSI_BW_10)
+		channel_width = 1;
+	else if (channel_width == RSI_BW_20)
+		channel_width = 2;
+	else if (channel_width == RSI_BW_25)
+		channel_width = 2;
+	else if (channel_width == RSI_BW_40)
+		channel_width = 3;
+	else
+		channel_width = 4;
+	rsi_dbg(INFO_ZONE, "channel_width = %d\n", channel_width);
+	dfs = is_dfs_channel(common->priv, params.mp.channel_num);
+	if (dfs == 1)
+		rsi_dbg(INFO_ZONE, "Requested channel is DFS\n");
+	else
+		rsi_dbg(INFO_ZONE, "Requested channel is NON DFS\n");
+
+	beacon_req->desc_word[0] = cpu_to_le16(RSI_WIFI_MGMT_Q << 12);
+	beacon_req->desc_word[1] = cpu_to_le16(FLAGS << 8);
+	beacon_req->desc_word[1] |= cpu_to_le16(RADIO_MEASUREMENT_REQ);
+	beacon_req->desc_word[2] = cpu_to_le16(params.mp.meas_type << 8);
+	beacon_req->desc_word[3] = cpu_to_le16(params.mp.meas_req_mode);
+	beacon_req->desc_word[3] |=
+		cpu_to_le16(((u16)params.mp.channel_num) << 8);
+	beacon_req->desc_word[4] = cpu_to_le16(params.mp.meas_duration);
+	beacon_req->desc_word[5] = cpu_to_le16(params.mp.rand_interval);
+	beacon_req->desc_word[6] = cpu_to_le16(dfs << 8); /* DFS chan */
+	beacon_req->desc_word[6] |= cpu_to_le16(channel_width);
+
+	memcpy(beacon_req->bssid, params.mac_addr, IEEE80211_ADDR_LEN);
+	memcpy(beacon_req->ssid, &params.ssid_ie[2], SSID_LEN);
+	beacon_req->rep_detail = params.rpt_detail;
+	beacon_req->meas_mode = params.meas_mode;
+	index = 0;
+	rsi_dbg(ERR_ZONE, "BEACON REQ REPORTING DETAILS %d\n",
+		beacon_req->rep_detail);
+	rsi_dbg(ERR_ZONE, "BEACON REQ SSID INFORMATION %s\n",
+		beacon_req->ssid);
+	rsi_dbg(ERR_ZONE, "beacon_req measurement mode %d\n",
+		beacon_req->meas_mode);
+	if (params.meas_mode == 1) {
+		rsi_dbg(ERR_ZONE, "active beacon request with bgscan probe\n");
+		memcpy(beacon_req->bgscan_probe,
+		       common->bgscan_probe_req,
+		       MIN_802_11_HDR_LEN);
+		index += MIN_802_11_HDR_LEN;
+
+		memcpy(&beacon_req->bgscan_probe[index],
+		       (u8 *)&params.ssid_ie,
+		       (2 + params.ssid_ie[1]));
+		index += (2 + params.ssid_ie[1]);
+
+		memcpy(&beacon_req->bgscan_probe[index],
+		       common->bgscan_probe_req + MIN_802_11_HDR_LEN + 2,
+		       (common->bgscan_probe_req_len - MIN_802_11_HDR_LEN - 2));
+		index += (common->bgscan_probe_req_len -
+				MIN_802_11_HDR_LEN - 2);
+	}
+
+	beacon_req->desc_word[0] |= cpu_to_le16(sizeof(*beacon_req) + index);
+	length = FRAME_DESC_SZ + sizeof(*beacon_req) + index;
+	rsi_hex_dump(INFO_ZONE, "BEACON FRAME HOST TO LMAC", skb->data, length);
+	skb_put(skb, FRAME_DESC_SZ + sizeof(*beacon_req) + index);
+
+	return rsi_send_internal_mgmt_frame(common, skb);
+}
+#endif
+
+#ifdef CONFIG_RSI_WOW 
+int rsi_send_wowlan_request(struct rsi_common *common, u16 flags,
+		            u16 sleep_status)
+{
+        struct rsi_wowlan_req *cmd_frame;
+        struct sk_buff *skb;
+        u8 length;
+        u8 sourceid[6] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+        rsi_dbg(ERR_ZONE, "%s: Sending wowlan request frame\n", __func__);
+
+        skb = dev_alloc_skb(sizeof(*cmd_frame));
+        if (!skb) {
+                rsi_dbg(ERR_ZONE, "%s: Failed in allocation of skb\n",
+                                __func__);
+                return -ENOMEM;
+        }
+        memset(skb->data, 0, sizeof(*cmd_frame));
+        cmd_frame = (struct rsi_wowlan_req *)skb->data;
+
+        cmd_frame->desc_word[0] = cpu_to_le16(RSI_WIFI_MGMT_Q << 12);
+        cmd_frame->desc_word[1] |= cpu_to_le16(WOWLAN_CONFIG_PARAMS);
+ 
+        memcpy(cmd_frame->sourceid, &sourceid, IEEE80211_ADDR_LEN);
+	
+        cmd_frame->host_sleep_status = sleep_status;
+	if ((common->secinfo.security_enable) &&
+	    (common->secinfo.gtk_cipher))
+		flags |= RSI_WOW_GTK_REKEY;
+	if (sleep_status)
+		cmd_frame->wow_flags = flags; /* TODO: check for magic packet */
+        rsi_dbg(INFO_ZONE, "Host_Sleep_Status : %d Flags : %d\n",
+		cmd_frame->host_sleep_status, cmd_frame->wow_flags );
+	
+        length = FRAME_DESC_SZ + IEEE80211_ADDR_LEN + 2 + 2;
+
+        cmd_frame->desc_word[0] |= cpu_to_le16(length - FRAME_DESC_SZ);
+        cmd_frame->desc_word[2] |= cpu_to_le16(0);
+  
+  	skb_put(skb, length);
+
+        return rsi_send_internal_mgmt_frame(common, skb);
+}
+#endif
+
+int rsi_send_beacon(struct rsi_common *common)
+{
+	struct sk_buff *skb = NULL;
+	u8 dword_align_bytes = 0;
+	
+	skb = dev_alloc_skb(MAX_MGMT_PKT_SIZE);
+	if (!skb)
+		return -ENOMEM;
+
+	memset(skb->data, 0, MAX_MGMT_PKT_SIZE);
+	
+	dword_align_bytes = ((unsigned long)skb->data & 0x3f);
+	if (dword_align_bytes) {
+		skb_pull(skb, (64 - dword_align_bytes));
+	}
+	if (rsi_prepare_beacon(common, skb)) {
+		rsi_dbg(ERR_ZONE, "Failed to prepare beacon\n");
+		return -EINVAL;
+	}
+	skb_queue_tail(&common->tx_queue[MGMT_BEACON_Q], skb);
+	rsi_set_event(&common->tx_thread.event);
+	rsi_dbg(DATA_TX_ZONE,
+		"%s: Added to beacon queue\n", __func__);
+
+	return 0;
+}
+
+#ifdef CONFIG_HW_SCAN_OFFLOAD
+#if LINUX_VERSION_CODE < KERNEL_VERSION (4, 15, 0)
+static void channel_change_event(unsigned long priv)
+{
+	struct rsi_hw *adapter = (struct rsi_hw *)priv;
+	struct rsi_common *common = adapter->priv;
+#else
+static void channel_change_event(struct timer_list *t)
+{
+	struct rsi_common *common = from_timer(common, t, scan_timer);
+#endif
+
+	rsi_set_event(&common->chan_change_event);
+	del_timer(&common->scan_timer);
+}
+
+static int init_channel_timer(struct rsi_hw *adapter, u32 timeout)
+{
+	struct rsi_common *common = adapter->priv;
+
+	rsi_reset_event(&common->chan_change_event);
+#if LINUX_VERSION_CODE < KERNEL_VERSION (4, 15, 0)
+	init_timer(&common->scan_timer);
+	common->scan_timer.data = (unsigned long)adapter;
+	common->scan_timer.function = (void *)&channel_change_event;
+#else
+	timer_setup(&common->scan_timer, channel_change_event, 0);
+#endif
+	common->scan_timer.expires = msecs_to_jiffies(timeout) + jiffies;
+
+	add_timer(&common->scan_timer);
+
+	return 0;
+}
+
+/**
+ * This function prepares Probe request frame and send it to LMAC.
+ * @param  Pointer to Adapter structure.
+ * @param  Type of scan(Active/Passive).
+ * @param  Broadcast probe.
+ * @param  Pointer to the destination address.
+ * @param  Indicates LMAC/UMAC Q number.
+ * @return 0 if success else -1.
+ */
+int rsi_send_probe_request(struct rsi_common *common,
+			   struct cfg80211_scan_request *scan_req,
+			   u8 n_ssid,
+			   u8 channel,
+			   u8 scan_type)
+{
+	struct cfg80211_ssid *ssid_info;
+	struct ieee80211_tx_info *info;
+	struct skb_info *tx_params;
+	struct sk_buff *skb = NULL;
+	struct ieee80211_hdr *hdr = NULL;
+	u8 *pos;
+	u32 len = 0;
+	u8 ie_ssid_len;
+	u8 q_num;
+
+	if (common->priv->sc_nvifs <= 0)
+		return 0;
+	if (!scan_req)
+		return 0;
+	ssid_info = &scan_req->ssids[n_ssid];
+	ie_ssid_len = (ssid_info && ssid_info->ssid_len) ? 
+		       ssid_info->ssid_len + 2 : 0;
+
+	len = (MIN_802_11_HDR_LEN + scan_req->ie_len + ie_ssid_len);
+	if (scan_type == 0) {
+		skb = dev_alloc_skb(len + 64); /* 64 for dword alignment */
+		if (!skb) {
+			rsi_dbg(ERR_ZONE, "Failed to alloc probe req\n");
+			return -ENOMEM;
+		}
+		skb_put(skb, len + 64);
+		memset(skb->data, 0, skb->len);
+		skb_reserve(skb, 64);
+		pos = skb->data;
+	
+		/*
+		 * probe req frame format
+		 * ssid
+		 * supported rates
+		 * RSN (optional)
+		 * extended supported rates
+		 * WPA (optional)
+		 * user-specified ie's
+		 */
+		hdr = (struct ieee80211_hdr *)skb->data;
+	} else {
+		pos = common->bgscan_probe_req;
+		hdr = (struct ieee80211_hdr *)common->bgscan_probe_req; 
+	}
+	hdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT | 
+					 IEEE80211_STYPE_PROBE_REQ);
+	hdr->duration_id = 0x0;
+	memset(hdr->addr1, 0xff, ETH_ALEN);
+	memset(hdr->addr3, 0xFF, 6);
+	memcpy(hdr->addr2, common->mac_addr, ETH_ALEN);
+	hdr->seq_ctrl = 0x00;
+	pos += MIN_802_11_HDR_LEN; 
+
+	*pos++ = WLAN_EID_SSID;
+	*pos++ = ie_ssid_len ? ie_ssid_len - 2 : 0; 
+
+	if (ssid_info && ie_ssid_len) { 
+               memcpy(pos, ssid_info->ssid, ie_ssid_len);
+		pos += ie_ssid_len;
+	}
+
+        if (scan_req->ie_len) 
+                memcpy(pos, scan_req->ie, scan_req->ie_len);
+       
+	if (scan_type == 1) {
+		if (len > RSI_MAX_BGS_PROBEREQ_LEN) {
+			u16 t_len = MIN_802_11_HDR_LEN;
+
+			/* Cut IEs from last */
+			pos = &skb->data[MIN_802_11_HDR_LEN];
+			while (true) {
+				if ((t_len + pos[1] + 2) >
+				    RSI_MAX_BGS_PROBEREQ_LEN) {
+					skb_trim(skb, t_len);
+					len = t_len;
+					break;
+				}
+				t_len += pos[1] + 2;
+				pos += (pos[1] + 2);
+			}
+		}
+		common->bgscan_probe_req_len = len;	
+		return 0;
+	}
+
+	if ((common->iface_down == true) || (!common->scan_in_prog))
+		goto out;
+
+	info = IEEE80211_SKB_CB(skb);
+	tx_params = (struct skb_info *)info->driver_data;
+	tx_params->internal_hdr_size = skb_headroom(skb);
+	info->control.vif = common->priv->vifs[0];	
+	q_num = MGMT_SOFT_Q;
+	skb->priority = q_num;
+
+	rsi_prepare_mgmt_desc(common,skb);
+	skb_queue_tail(&common->tx_queue[MGMT_SOFT_Q], skb);
+	rsi_set_event(&common->tx_thread.event);
+	
+	return 0;
+
+out:
+	dev_kfree_skb(skb);
+	return 0;
+}
+
+void rsi_scan_start(struct work_struct *work)
+{
+	struct ieee80211_channel *cur_chan = NULL;
+	struct cfg80211_scan_request *scan_req = NULL;
+	struct rsi_common *common =
+		container_of(work, struct rsi_common ,scan_work);
+	u8 ii, jj;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0))
+	struct cfg80211_scan_info info;
+#endif
+	
+	scan_req = common->scan_request;
+	if (!scan_req)
+		return;
+
+	common->scan_in_prog = true;
+	
+	for (ii =0; ii < scan_req->n_channels ; ii++) {
+		if (common->iface_down)
+			break;
+	
+		if (!common->scan_in_prog)
+			break;
+		
+		rsi_dbg(INFO_ZONE,
+			"channle no: %d", scan_req->channels[ii]->hw_value);
+		cur_chan = scan_req->channels[ii];
+
+		rsi_band_check(common, cur_chan);
+		if (cur_chan->flags & IEEE80211_CHAN_DISABLED)
+			continue;
+
+		/* maxdwell time macro */
+		init_channel_timer(common->priv, 300);
+				 
+		if (rsi_set_channel(common, cur_chan)) {
+			rsi_dbg(ERR_ZONE, "Failed to set the channel\n");
+			break;
+		}
+		rsi_reset_event(&common->chan_set_event);
+		rsi_wait_event(&common->chan_set_event, msecs_to_jiffies(50));
+		
+		if (!common->scan_in_prog)
+			break;
+		rsi_reset_event(&common->chan_set_event);
+
+		if ((cur_chan->flags & IEEE80211_CHAN_NO_IR) ||
+		    (cur_chan->flags & IEEE80211_CHAN_RADAR)) {
+			/* DFS Channel */
+			/* Program passive scan duration */
+		} else {
+			/* Send probe request */
+			for (jj = 0; jj < scan_req->n_ssids; jj++) {
+				rsi_send_probe_request(common, 
+						       scan_req,
+						       jj,
+						       cur_chan->hw_value,
+						       0);
+				if (common->iface_down == true) {
+					common->scan_in_prog = false;
+					return;
+				}
+				rsi_reset_event(&common->probe_cfm_event);
+				rsi_wait_event(&common->probe_cfm_event,
+					       msecs_to_jiffies(50));
+				rsi_reset_event(&common->probe_cfm_event);
+			}
+		}
+		if (!common->scan_in_prog)
+			break;
+		if (common->iface_down)
+			break;
+		rsi_wait_event(&common->chan_change_event, EVENT_WAIT_FOREVER);
+		rsi_reset_event(&common->chan_change_event);
+	}
+
+	del_timer(&common->scan_timer);
+	common->scan_in_prog = false;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0))
+	info.aborted = false;
+	ieee80211_scan_completed(common->priv->hw, &info);
+#else	
+	ieee80211_scan_completed(common->priv->hw, false);
+#endif
+
+	if (common->hw_scan_cancel) {	
+		skb_queue_purge(&common->tx_queue[MGMT_SOFT_Q]);
+		rsi_set_event(&common->cancel_hw_scan_event);
+	}	
+	return;
+}
+#endif
+
+static int rsi_send_w9116_features(struct rsi_common *common)
+{
+	struct rsi_wlan_9116_features *w9116_features;
+	u16 frame_len = sizeof(struct rsi_wlan_9116_features);
+	struct sk_buff *skb;
+
+	rsi_dbg(MGMT_TX_ZONE,
+		"%s: Sending wlan 9116 features\n", __func__);
+
+	skb = dev_alloc_skb(frame_len);
+	if (!skb)
+		return -ENOMEM;
+	memset(skb->data, 0, frame_len);
+
+	w9116_features = (struct rsi_wlan_9116_features *)skb->data;
+
+	w9116_features->pll_mode = common->w9116_features.pll_mode;
+	w9116_features->rf_type = common->w9116_features.rf_type;
+	w9116_features->wireless_mode = common->w9116_features.wireless_mode;
+	w9116_features->enable_ppe = common->w9116_features.enable_ppe;
+	w9116_features->afe_type = common->w9116_features.afe_type;
+	if (common->w9116_features.dpd)
+		w9116_features->feature_enable |= cpu_to_le32(RSI_DPD);
+	if (common->w9116_features.sifs_tx_enable)
+		w9116_features->feature_enable |=
+			cpu_to_le32(RSI_SIFS_TX_ENABLE);
+	if (common->w9116_features.ps_options & RSI_DUTY_CYCLING)
+		w9116_features->feature_enable |= cpu_to_le32(RSI_DUTY_CYCLING);
+	if (common->w9116_features.ps_options & RSI_END_OF_FRAME)
+		w9116_features->feature_enable |= cpu_to_le32(RSI_END_OF_FRAME);
+	w9116_features->feature_enable |=
+		cpu_to_le32((common->w9116_features.ps_options & ~0x3) << 2);
+
+	w9116_features->desc_word[0] = cpu_to_le16((frame_len - FRAME_DESC_SZ) |
+						   (RSI_WIFI_MGMT_Q << 12));
+	w9116_features->desc_word[1] = cpu_to_le16(FEATURES_ENABLE);
+	skb_put(skb, frame_len);
+
+	return rsi_send_internal_mgmt_frame(common, skb);
+}
+/**
+ * rsi_handle_ta_confirm() - This function handles the confirm frames.
  * @common: Pointer to the driver private structure.
  * @msg: Pointer to received packet.
  *
  * Return: 0 on success, -1 on failure.
  */
-static int rsi_handle_ta_confirm_type(struct rsi_common *common,
-				      u8 *msg)
+static int rsi_handle_ta_confirm(struct rsi_common *common, u8 *msg)
 {
+	struct rsi_hw *adapter = common->priv;
 	u8 sub_type = (msg[15] & 0xff);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0))
+	struct cfg80211_scan_info info;
+#endif
+
+	rsi_dbg(MGMT_RX_ZONE, "%s: subtype=%d\n", __func__, sub_type);
 
 	switch (sub_type) {
-	case BOOTUP_PARAMS_REQUEST:
-		rsi_dbg(FSM_ZONE, "%s: Boot up params confirm received\n",
-			__func__);
-		if (common->fsm_state == FSM_BOOT_PARAMS_SENT) {
-			if (rsi_eeprom_read(common)) {
+	case COMMON_DEV_CONFIG:
+		rsi_dbg(FSM_ZONE,
+			"Common Dev Config params confirm received\n");
+		if (common->fsm_state == FSM_COMMON_DEV_PARAMS_SENT) {
+			if (rsi_load_bootup_params(common)) {
 				common->fsm_state = FSM_CARD_NOT_READY;
 				goto out;
 			} else {
-				common->fsm_state = FSM_EEPROM_READ_MAC_ADDR;
+				common->fsm_state = FSM_BOOT_PARAMS_SENT;
+			}
+		} else {
+			rsi_dbg(INFO_ZONE,
+				"%s: Received common dev config params cfm in %d state\n",
+				 __func__, common->fsm_state);
+			return 0;
+		}
+		break;
+
+	case BOOTUP_PARAMS_REQUEST:
+		rsi_dbg(FSM_ZONE, "Bootup params confirmation.\n");
+		if (common->fsm_state == FSM_BOOT_PARAMS_SENT) {
+			if (adapter->device_model == RSI_DEV_9116) {
+				common->band = NL80211_BAND_5GHZ;
+				common->num_supp_bands = 2;
+
+				if (rsi_send_reset_mac(common))
+					goto out;
+				else
+					common->fsm_state = FSM_RESET_MAC_SENT;
+			} else {
+				adapter->eeprom.length = (IEEE80211_ADDR_LEN +
+						WLAN_MAC_MAGIC_WORD_LEN +
+						WLAN_HOST_MODE_LEN);
+				adapter->eeprom.offset = WLAN_MAC_EEPROM_ADDR;
+				if (rsi_eeprom_read(common)) {
+					common->fsm_state = FSM_CARD_NOT_READY;
+					goto out;
+				} else
+					common->fsm_state =
+						FSM_EEPROM_READ_MAC_ADDR;
 			}
 		} else {
 			rsi_dbg(INFO_ZONE,
@@ -1272,18 +3219,66 @@ static int rsi_handle_ta_confirm_type(struct rsi_common *common,
 		}
 		break;
 
-	case EEPROM_READ_TYPE:
+	case EEPROM_READ:
+		rsi_dbg(FSM_ZONE, "EEPROM READ confirm received\n");
 		if (common->fsm_state == FSM_EEPROM_READ_MAC_ADDR) {
+			u32 msg_len = ((u16 *)msg)[0] & 0xfff;
+
+			if (msg_len <= 0) {
+				rsi_dbg(FSM_ZONE,
+					"%s: [EEPROM_READ] Invalid len %d\n",
+					__func__, msg_len);
+				goto out;
+			}
 			if (msg[16] == MAGIC_WORD) {
-				u8 offset = (FRAME_DESC_SZ + WLAN_HOST_MODE_LEN
-					     + WLAN_MAC_MAGIC_WORD_LEN);
+				u8 offset = (FRAME_DESC_SZ +
+					     WLAN_HOST_MODE_LEN +
+					     WLAN_MAC_MAGIC_WORD_LEN);
+
 				memcpy(common->mac_addr,
 				       &msg[offset],
-				       ETH_ALEN);
-				memcpy(&common->fw_ver,
-				       &msg[offset + ETH_ALEN],
-				       sizeof(struct version_info));
+				       IEEE80211_ADDR_LEN);
+				rsi_hex_dump(INIT_ZONE,
+					     "MAC Addr",
+					     common->mac_addr, ETH_ALEN);
+				adapter->eeprom.length =
+					((WLAN_MAC_MAGIC_WORD_LEN + 3) & (~3));
+				adapter->eeprom.offset =
+					WLAN_EEPROM_RFTYPE_ADDR;
+				if (rsi_eeprom_read(common)) {
+					rsi_dbg(ERR_ZONE,
+						"%s: Failed reading RF band\n",
+						__func__);
+					common->fsm_state = FSM_CARD_NOT_READY;
+				} else {
+					common->fsm_state =
+						FSM_EEPROM_READ_RF_TYPE;
+				}
+			} else {
+				common->fsm_state = FSM_CARD_NOT_READY;
+				break;
+			}
+		} else if (common->fsm_state == FSM_EEPROM_READ_RF_TYPE) {
+			u32 msg_len = ((u16 *)msg)[0] & 0xfff;
 
+			if (msg_len <= 0) {
+				rsi_dbg(FSM_ZONE,
+					"%s:[EEPROM_READ_CFM] Invalid len %d\n",
+					__func__, msg_len);
+				goto out;
+			}
+			if (msg[16] == MAGIC_WORD) {
+				if ((msg[17] & 0x3) == 0x3) {
+					rsi_dbg(INIT_ZONE,
+						"Dual band supported\n");
+					common->band = NL80211_BAND_5GHZ;
+					common->num_supp_bands = 2;
+				} else if ((msg[17] & 0x3) == 0x1) {
+					rsi_dbg(INIT_ZONE,
+						"Only 2.4Ghz band supported\n");
+					common->band = NL80211_BAND_2GHZ;
+					common->num_supp_bands = 1;
+				}
 			} else {
 				common->fsm_state = FSM_CARD_NOT_READY;
 				break;
@@ -1294,7 +3289,7 @@ static int rsi_handle_ta_confirm_type(struct rsi_common *common,
 				common->fsm_state = FSM_RESET_MAC_SENT;
 		} else {
 			rsi_dbg(ERR_ZONE,
-				"%s: Received eeprom mac addr in %d state\n",
+				"%s: Received eeprom read in %d state\n",
 				__func__, common->fsm_state);
 			return 0;
 		}
@@ -1302,8 +3297,7 @@ static int rsi_handle_ta_confirm_type(struct rsi_common *common,
 
 	case RESET_MAC_REQ:
 		if (common->fsm_state == FSM_RESET_MAC_SENT) {
-			rsi_dbg(FSM_ZONE, "%s: Reset MAC cfm received\n",
-				__func__);
+			rsi_dbg(FSM_ZONE, "Reset MAC confirm\n");
 
 			if (rsi_load_radio_caps(common))
 				goto out;
@@ -1320,12 +3314,17 @@ static int rsi_handle_ta_confirm_type(struct rsi_common *common,
 	case RADIO_CAPABILITIES:
 		if (common->fsm_state == FSM_RADIO_CAPS_SENT) {
 			common->rf_reset = 1;
+			if ((adapter->device_model == RSI_DEV_9116) &&
+			    rsi_send_w9116_features(common)) {
+				rsi_dbg(ERR_ZONE,
+					"Failed to send 9116 features\n");
+				goto out;
+			}
 			if (rsi_program_bb_rf(common)) {
 				goto out;
 			} else {
 				common->fsm_state = FSM_BB_RF_PROG_SENT;
-				rsi_dbg(FSM_ZONE, "%s: Radio cap cfm received\n",
-					__func__);
+				rsi_dbg(FSM_ZONE, "Radio caps confirm\n");
 			}
 		} else {
 			rsi_dbg(INFO_ZONE,
@@ -1338,36 +3337,135 @@ static int rsi_handle_ta_confirm_type(struct rsi_common *common,
 	case BB_PROG_VALUES_REQUEST:
 	case RF_PROG_VALUES_REQUEST:
 	case BBP_PROG_IN_TA:
-		rsi_dbg(FSM_ZONE, "%s: BB/RF cfm received\n", __func__);
+		rsi_dbg(FSM_ZONE, "BB/RF confirmation.\n");
 		if (common->fsm_state == FSM_BB_RF_PROG_SENT) {
 			common->bb_rf_prog_count--;
 			if (!common->bb_rf_prog_count) {
 				common->fsm_state = FSM_MAC_INIT_DONE;
-				return rsi_mac80211_attach(common);
+				if (common->reinit_hw) {
+					common->hw_data_qs_blocked = false;
+					ieee80211_wake_queues(adapter->hw);
+					complete(&common->wlan_init_completion);
+					common->reinit_hw = false;
+				} else {
+					return rsi_mac80211_attach(common);
+				}
 			}
 		} else {
 			rsi_dbg(INFO_ZONE,
-				"%s: Received bbb_rf cfm in %d state\n",
+				"%s: Received bb_rf cfm in %d state\n",
 				 __func__, common->fsm_state);
 			return 0;
 		}
 		break;
 
+	case AMPDU_IND:
+		rsi_dbg(INFO_ZONE, "AMPDU indication.\n");
+		break;
+
+	case SCAN_REQUEST:
+		rsi_dbg(INFO_ZONE, "Scan confirm.\n");
+#ifdef CONFIG_HW_SCAN_OFFLOAD
+		rsi_set_event(&common->chan_set_event);
+#endif
+		break;
+
+	case SET_RX_FILTER:
+		rsi_dbg(INFO_ZONE, "RX Filter confirmation.\n");
+		break;
+
+	case WAKEUP_SLEEP_REQUEST:
+		rsi_dbg(INFO_ZONE, "Wakeup/Sleep confirmation.\n");
+		rsi_set_event(&common->mgmt_cfm_event);
+		return rsi_handle_ps_confirm(adapter, msg);
+
+	case BG_SCAN_PROBE_REQ:
+		rsi_dbg(INFO_ZONE, "BG scan complete event\n");
+		if (common->bgscan_en) {
+			if (!rsi_send_bgscan_params(common, 0))
+				common->bgscan_en = 0;
+		}
+#ifdef CONFIG_HW_SCAN_OFFLOAD
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0))
+		info.aborted = false;
+		ieee80211_scan_completed(adapter->hw, &info);
+#else	
+		ieee80211_scan_completed(adapter->hw, false);
+#endif
+		if (common->hw_scan_cancel)
+			rsi_set_event(&common->cancel_hw_scan_event);
+#endif
+		break;
+
 	default:
-		rsi_dbg(INFO_ZONE, "%s: Invalid TA confirm pkt received\n",
-			__func__);
+		rsi_dbg(INFO_ZONE,
+			"%s: Invalid TA confirm type : %x\n",
+			__func__, sub_type);
 		break;
 	}
 	return 0;
+
 out:
-	rsi_dbg(ERR_ZONE, "%s: Unable to send pkt/Invalid frame received\n",
+	rsi_dbg(ERR_ZONE,
+		"%s: Unable to send pkt/Invalid frame received\n",
 		__func__);
 	return -EINVAL;
 }
 
 /**
+ *rsi_handle_card_ready() - This function handles the card ready
+ *                       indication from firmware.
+ *@common: Pointer to the driver private structure.
+ *
+ *Return: 0 on success, -1 on failure.
+ */
+int rsi_handle_card_ready(struct rsi_common *common, u8 *msg)
+{
+	u8 rsi_standard_mac[3] = {0x00, 0x23, 0xa7};
+
+	switch (common->fsm_state) {
+	case FSM_CARD_NOT_READY:
+		rsi_dbg(INIT_ZONE, "Card ready indication from Common HAL\n");
+		rsi_set_default_parameters(common);
+		if (rsi_send_common_dev_params(common) < 0)
+			return -EINVAL;
+		common->fsm_state = FSM_COMMON_DEV_PARAMS_SENT;
+		break;
+	case FSM_COMMON_DEV_PARAMS_SENT:
+		rsi_dbg(INIT_ZONE, "Card ready indication from WLAN HAL\n");
+
+		if (common->priv->device_model == RSI_DEV_9116) {
+			memcpy(common->mac_addr, rsi_standard_mac,
+			       RSI_MAC_SUB_LEN);
+			get_random_bytes(&common->mac_addr[3],
+					 RSI_MAC_SUB_LEN);
+			rsi_hex_dump(INIT_ZONE, "MAC Addr",
+				     common->mac_addr, ETH_ALEN);
+		}
+		/* Get usb buffer status register address */
+		common->priv->usb_buffer_status_reg = *(u32 *)&msg[8];
+		rsi_dbg(INFO_ZONE, "USB buffer status register = %x\n",
+			common->priv->usb_buffer_status_reg);
+
+		if (rsi_load_bootup_params(common)) {
+			common->fsm_state = FSM_CARD_NOT_READY;
+			return -EINVAL;
+		}
+		common->fsm_state = FSM_BOOT_PARAMS_SENT;
+		break;
+	default:
+		rsi_dbg(ERR_ZONE,
+			"%s: card ready indication in invalid state %d.\n",
+			__func__, common->fsm_state);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/**
  * rsi_mgmt_pkt_recv() - This function processes the management packets
- *			 recieved from the hardware.
+ *			 received from the hardware.
  * @common: Pointer to the driver private structure.
  * @msg: Pointer to the received packet.
  *
@@ -1375,37 +3473,130 @@ static int rsi_handle_ta_confirm_type(struct rsi_common *common,
  */
 int rsi_mgmt_pkt_recv(struct rsi_common *common, u8 *msg)
 {
+	struct rsi_hw *adapter = common->priv;
 	s32 msg_len = (le16_to_cpu(*(__le16 *)&msg[0]) & 0x0fff);
-	u16 msg_type = (msg[2]);
-	int ret;
+	u16 msg_type = msg[2];
+	struct ieee80211_vif *vif = adapter->vifs[adapter->sc_nvifs - 1];
 
-	rsi_dbg(FSM_ZONE, "%s: Msg Len: %d, Msg Type: %4x\n",
-		__func__, msg_len, msg_type);
+	switch (msg_type) {
+	case TA_CONFIRM_TYPE:
+		return rsi_handle_ta_confirm(common, msg);
 
-	if (msg_type == TA_CONFIRM_TYPE) {
-		return rsi_handle_ta_confirm_type(common, msg);
-	} else if (msg_type == CARD_READY_IND) {
-		rsi_dbg(FSM_ZONE, "%s: Card ready indication received\n",
-			__func__);
-		if (common->fsm_state == FSM_CARD_NOT_READY) {
-			rsi_set_default_parameters(common);
+	case CARD_READY_IND:
+		rsi_dbg(INIT_ZONE, "CARD READY INDICATION FROM WLAN.\n");
+		return rsi_handle_card_ready(common, msg);
 
-			ret = rsi_load_bootup_params(common);
-			if (ret)
-				return ret;
-			else
-				common->fsm_state = FSM_BOOT_PARAMS_SENT;
-		} else {
-			return -EINVAL;
-		}
-	} else if (msg_type == TX_STATUS_IND) {
+	case TX_STATUS_IND:
 		if (msg[15] == PROBEREQ_CONFIRM) {
 			common->mgmt_q_block = false;
-			rsi_dbg(FSM_ZONE, "%s: Probe confirm received\n",
-				__func__);
+			rsi_dbg(INFO_ZONE, "Mgmt queue unblocked\n");
+#ifdef CONFIG_HW_SCAN_OFFLOAD
+			rsi_set_event(&common->probe_cfm_event);
+#endif
 		}
-	} else {
-		return rsi_mgmt_pkt_to_core(common, msg, msg_len, msg_type);
+		if ((msg[15] & 0xff) == EAPOL4_CONFIRM) {
+			u8 status = msg[12];
+
+			if (status) {	
+				if(vif->type == NL80211_IFTYPE_STATION) {
+					rsi_dbg(ERR_ZONE, "EAPOL 4 confirm\n");
+					common->start_bgscan = 1;
+					common->eapol4_confirm = 1;
+					if (!rsi_send_block_unblock_frame(common,
+									  false))
+						common->hw_data_qs_blocked = false;
+				}
+			}
+		}
+		break;
+
+	case PS_NOTIFY_IND:
+		rsi_dbg(FSM_ZONE, "Powersave notify indication.\n");
+		break;
+
+	case SLEEP_NOTIFY_IND:
+		rsi_dbg(FSM_ZONE, "Sleep notify indication.\n");
+		break;
+
+	case DECRYPT_ERROR_IND:
+		rsi_dbg(INFO_ZONE, "Error in decrypt.\n");
+		break;
+
+	case DEBUG_IND:
+		rsi_dbg(INFO_ZONE, "Debugging indication.\n");
+		break;
+
+	case RX_MISC_IND:
+		rsi_dbg(INFO_ZONE, "RX misc indication.\n");
+		break;
+
+	case HW_BMISS_EVENT:
+		rsi_dbg(INFO_ZONE, "Hardware beacon miss event\n");
+		rsi_indicate_bcnmiss(common);
+		rsi_resume_conn_channel(common->priv,
+					adapter->vifs[adapter->sc_nvifs - 1]);
+		break;
+
+	case BEACON_EVENT_IND:
+		rsi_dbg(INFO_ZONE, "Beacon event\n");
+		if (!common->init_done)
+			return -1;
+		if (common->iface_down)
+			return -1;
+		if (!common->beacon_enabled)
+			return -1;
+		rsi_send_beacon(common);
+		break;
+
+	case WOWLAN_WAKEUP_REASON:
+		rsi_hex_dump(INFO_ZONE, "WoWLAN Wakeup Trigger Pkt",
+			     msg, msg_len);
+		rsi_dbg(ERR_ZONE, "\n\nWakeup Type: %x\n", msg[15]);
+		switch(msg[15]) {
+		case UNICAST_MAGIC_PKT:
+			rsi_dbg(ERR_ZONE,
+				"*** Wakeup for Unicast magic packet ***\n");
+			break;
+		case BROADCAST_MAGICPKT:
+			rsi_dbg(ERR_ZONE,
+				"*** Wakeup for Broadcast magic packet ***\n");
+			break;
+		case EAPOL_PKT:
+			rsi_dbg(ERR_ZONE,
+				"*** Wakeup for GTK renewal ***\n");
+			break;
+		case DISCONNECT_PKT:
+			rsi_dbg(ERR_ZONE,
+				"*** Wakeup for Disconnect ***\n");
+			break;
+		case HW_BMISS_PKT:
+			rsi_dbg(ERR_ZONE,
+				"*** Wakeup for HW Beacon miss ***\n");
+			break;
+		default:
+			rsi_dbg(ERR_ZONE,
+				"##### Un-intentional Wakeup #####\n");
+			break;
+		}
+#ifdef CONFIG_RSI_11K
+		case RADIO_MEAS_RPT:
+		rsi_hex_dump(ERR_ZONE, "11K RRM RX CMD FRAME",
+			     msg, msg_len);
+		common->priv->rrm_enq_state = 0;
+		common->priv->rrm_state = RRM_RESP_RCVD;
+		rsi_rrm_recv_cmd_frame(common, msg, msg_len);
+		rsi_rrm_sched_req(common);
+		break;
+#endif
+	case RX_DOT11_MGMT:
+		return rsi_mgmt_pkt_to_core(common, msg, msg_len);
+
+	default:
+		rsi_dbg(INFO_ZONE, "Cmd Frame Type: %d\n", msg_type);
+		break;
 	}
+
 	return 0;
 }
+
+
diff --git a/drivers/net/wireless/rsi/rsi_91x_ps.c b/drivers/net/wireless/rsi/rsi_91x_ps.c
new file mode 100644
index 0000000..15d3ee4
--- /dev/null
+++ b/drivers/net/wireless/rsi/rsi_91x_ps.c
@@ -0,0 +1,216 @@
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
+ *
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
+ *
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/etherdevice.h>
+#include <linux/if.h>
+#include <linux/version.h>
+#include "rsi_debugfs.h"
+#include "rsi_mgmt.h"
+#include "rsi_common.h"
+#include "rsi_ps.h"
+
+/**
+ * str_psstate() - return the ps state in string format.
+ *
+ * @state - PS state.
+ *
+ * return: PS state in string format.
+ */
+char *str_psstate(enum ps_state state)
+{
+	switch (state) {
+	case PS_NONE:
+		return "PS_NONE";
+	case PS_DISABLE_REQ_SENT:
+		return "PS_DISABLE_REQ_SENT";
+	case PS_ENABLE_REQ_SENT:
+		return "PS_ENABLE_REQ_SENT";
+	case PS_ENABLED:
+		return "PS_ENABLED";
+	default:
+		return "INVALID_STATE";
+	}
+	return "INVALID_STATE";
+}
+
+/**
+ * rsi_modify_ps_state() - Modify PS state to a new state.
+ *
+ * @adapter: pointer to rsi_hw structure.
+ * @nstate: new PS state.
+ *
+ * return: new state.
+ */
+static inline void rsi_modify_ps_state(struct rsi_hw *adapter,
+				       enum ps_state nstate)
+{
+	rsi_dbg(INFO_ZONE, "PS state changed %s => %s\n",
+		str_psstate(adapter->ps_state),
+		str_psstate(nstate));
+
+	adapter->ps_state = nstate;
+}
+
+/**
+ * rsi_default_ps_params() - Initalization of default powersave parameters.
+ *
+ * @adapter: pointer to rsi_hw structure.
+ *
+ * return: void.
+ */
+void rsi_default_ps_params(struct rsi_hw *adapter)
+{
+	struct rsi_ps_info *ps_info = &adapter->ps_info;
+
+	ps_info->enabled = true;
+	ps_info->sleep_type = 1; /* LP */
+	ps_info->tx_threshold = 0;
+	ps_info->rx_threshold = 0;
+	ps_info->tx_hysterisis = 0;
+	ps_info->rx_hysterisis = 0;
+	ps_info->monitor_interval = 0;
+	ps_info->listen_interval = 2 * 100;
+	ps_info->num_bcns_per_lis_int = 0;
+	ps_info->dtim_interval_duration = 0;
+	ps_info->num_dtims_per_sleep = 0;
+	ps_info->deep_sleep_wakeup_period = 200;
+}
+EXPORT_SYMBOL_GPL(rsi_default_ps_params);
+
+/**
+ * rsi_enable_ps() - enable power save
+ *
+ * @adapter: Pointer to rsi_hw structure.
+ *
+ * return: void.
+ */
+void rsi_enable_ps(struct rsi_hw *adapter)
+{
+	if (adapter->ps_state != PS_NONE) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Cannot accept enable PS in %s state\n",
+			__func__, str_psstate(adapter->ps_state));
+		return;
+	}
+
+	if (rsi_send_ps_request(adapter, true)) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Failed to send PS request to device\n",
+			__func__);
+		return;
+	}
+
+	rsi_modify_ps_state(adapter, PS_ENABLE_REQ_SENT);
+}
+
+/**
+ * rsi_disable_ps() - disable power save
+ *
+ * @adapter: Pointer to rsi_hw structure.
+ *
+ * return: void.
+ */
+void rsi_disable_ps(struct rsi_hw *adapter)
+{
+	if (adapter->ps_state != PS_ENABLED) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Cannot accept disable PS in %s state\n",
+			__func__, str_psstate(adapter->ps_state));
+		return;
+	}
+
+	if (rsi_send_ps_request(adapter, false)) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Failed to send PS request to device\n",
+			__func__);
+		return;
+	}
+
+	rsi_modify_ps_state(adapter, PS_DISABLE_REQ_SENT);
+}
+
+/**
+ * rsi_conf_uapsd() - configures UAPSD powersave.
+ *
+ * @adapter - Pointer to rsi_hw structure.
+ *
+ * return: void.
+ */
+void rsi_conf_uapsd(struct rsi_hw *adapter)
+{
+	if (adapter->ps_state != PS_ENABLED)
+		return;
+
+	if (rsi_send_ps_request(adapter, false)) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Failed to send PS request to device\n",
+			__func__);
+		return;
+	}
+
+	if (rsi_send_ps_request(adapter, true)) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Failed to send PS request to device\n",
+			__func__);
+	}
+}
+
+/**
+ * rsi_handle_ps_confirm() - Processes powersave confirmation.
+ *
+ * @adapter - Pointer to rsi_hw structure.
+ * @msg - Recevied buffer.
+ *
+ * return: 0 on success.
+ */
+int rsi_handle_ps_confirm(struct rsi_hw *adapter, u8 *msg)
+{
+	u16 cfm_type = 0;
+
+	cfm_type = *(u16 *)&msg[PS_CONFIRM_INDEX];
+
+	switch (cfm_type) {
+	case SLEEP_REQUEST:
+		if (adapter->ps_state == PS_ENABLE_REQ_SENT)
+			rsi_modify_ps_state(adapter, PS_ENABLED);
+		break;
+	case WAKEUP_REQUEST:
+		if (adapter->ps_state == PS_DISABLE_REQ_SENT)
+			rsi_modify_ps_state(adapter, PS_NONE);
+		break;
+	default:
+		rsi_dbg(ERR_ZONE,
+			"Invalid PS confirm type %x in state %s\n",
+			cfm_type, str_psstate(adapter->ps_state));
+		return -1;
+	}
+
+	return 0;
+}
diff --git a/drivers/net/wireless/rsi/rsi_91x_rrm.c b/drivers/net/wireless/rsi/rsi_91x_rrm.c
new file mode 100644
index 0000000..14cf024
--- /dev/null
+++ b/drivers/net/wireless/rsi/rsi_91x_rrm.c
@@ -0,0 +1,763 @@
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
+ *
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
+ *
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/etherdevice.h>
+#include "rsi_mgmt.h"
+#include "rsi_common.h"
+#include "rsi_rrm.h"
+
+#if defined(CONFIG_RSI_11K) && defined(RSI_DEBUG_RRM)
+int rsi_rrm_send_channel_load_req(struct rsi_common *common)
+{
+#ifdef RSI_DEBUG_RRM
+	struct ieee80211_vif *vif =
+		common->priv->vifs[common->priv->sc_nvifs - 1];
+	struct ieee80211_bss_conf *bss = &vif->bss_conf;
+#endif
+	u8 frame_len, chload_req_len;
+	struct sk_buff *skb = NULL;
+	struct dot11_radio_meas_req *chload_req;
+	struct ieee80211_tx_info *info;
+
+	/* preparing on air channel load request */
+	frame_len = sizeof(struct dot11_radio_meas_req);
+	skb = dev_alloc_skb(frame_len + DRV_HDR_SIZE);
+	if (!skb)
+		return -ENOMEM;
+	skb_reserve(skb, DRV_HDR_SIZE);
+
+	chload_req = (struct dot11_radio_meas_req *)skb->data;
+	chload_req->action_body.category = WLAN_ACTION_RADIO_MEASUREMENT;
+	chload_req->action_body.action = IEEE80211_ACTION_RADIO_MEAS_REQ;
+	chload_req->action_body.num_repetitions = 0;
+#ifdef RSI_DEBUG_RRM
+	chload_req->mac_hdr.frame_control = IEEE80211_STYPE_ACTION;
+	chload_req->mac_hdr.duration_id = 0;
+	chload_req->mac_hdr.seq_ctrl = 0;
+	ether_addr_copy(chload_req->mac_hdr.addr1,
+			common->rrm_chload_params.macid);
+	ether_addr_copy(chload_req->mac_hdr.addr2, vif->addr);
+	ether_addr_copy(chload_req->mac_hdr.addr3, bss->bssid);
+	chload_req->action_body.dialog_token = 2;/* FIXME: Fill proper value */
+	chload_req->rmelem.mode = common->rrm_chload_params.meas_req_mode;
+	chload_req->rmelem.element_id = MEAS_REQ;
+	chload_req_len = sizeof(*chload_req) - sizeof(struct ieee80211_basic_hdr);
+	chload_req_len -= sizeof(struct wl_action_req);
+	chload_req_len -= sizeof(struct rm_element);
+	chload_req->rmelem.length = sizeof(struct rm_element) - 2 +
+				    chload_req_len;
+	chload_req->rmelem.token = 0;
+	chload_req->rmelem.type = 3;
+	chload_req->regulatory_class =
+		common->rrm_chload_params.regulatory_class;
+	chload_req->channel_num = common->rrm_chload_params.channel_num;
+	chload_req->rand_int = common->rrm_chload_params.rand_interval;
+	chload_req->meas_duration = common->rrm_chload_params.meas_duration;
+#endif
+
+	if ((chload_req->rmelem.mode >> 1 & 1) ||
+	    (chload_req->rmelem.mode >> 2 & 1)) {
+		rsi_dbg(INFO_ZONE, "station incapable/refusing frame report\n");
+		goto err;
+	}
+
+	skb_put(skb, frame_len);
+	info = IEEE80211_SKB_CB(skb);
+	info->control.vif = vif;
+	rsi_dbg(MGMT_TX_ZONE, "Sending channel load measurement request\n");
+	rsi_core_xmit(common, skb);
+
+	return 0;
+
+err:
+	dev_kfree_skb(skb);
+	return -EINVAL;
+}
+
+int rsi_rrm_send_frame_req(struct rsi_common *common)
+{
+	struct ieee80211_vif *vif =
+		common->priv->vifs[common->priv->sc_nvifs - 1];
+	struct ieee80211_bss_conf *bss = &vif->bss_conf;
+	u8 frame_len;
+	struct sk_buff *skb = NULL;
+	struct dot11_frame_meas_req *frame_req;
+	struct ieee80211_tx_info *info;
+	u8 frame_req_len;
+
+	frame_len = sizeof(struct dot11_frame_meas_req);
+	skb = dev_alloc_skb(frame_len + DRV_HDR_SIZE);
+	if (!skb)
+		return -ENOMEM;
+	skb_reserve(skb, DRV_HDR_SIZE);
+
+	frame_req = (struct dot11_frame_meas_req *)skb->data;
+	frame_req->mac_hdr.frame_control = IEEE80211_STYPE_ACTION;
+	frame_req->mac_hdr.duration_id = 0;
+	frame_req->mac_hdr.seq_ctrl = 0;
+	ether_addr_copy(frame_req->mac_hdr.addr1,
+			common->rrm_frame_params.destid);
+	ether_addr_copy(frame_req->mac_hdr.addr2, vif->addr);
+	ether_addr_copy(frame_req->mac_hdr.addr3, bss->bssid);
+
+	frame_req->action_body.category = WLAN_ACTION_RADIO_MEASUREMENT;
+	frame_req->action_body.action = IEEE80211_ACTION_RADIO_MEAS_REQ;
+	frame_req->action_body.dialog_token = 2; /* FIXME: Fill proper value */
+	frame_req->action_body.num_repetitions = 0;
+
+	frame_req->rmelem.mode = common->rrm_frame_params.meas_req_mode;
+	frame_req->rmelem.element_id = MEAS_REQ;
+	frame_req_len = sizeof(*frame_req) - sizeof(struct ieee80211_basic_hdr);
+	frame_req_len -= sizeof(struct wl_action_req);
+	frame_req_len -= sizeof(struct rm_element);
+	frame_req->rmelem.length = sizeof(struct rm_element) - 2 +
+				   frame_req_len;
+	frame_req->rmelem.token = 0;
+	frame_req->rmelem.type = 6;
+
+	frame_req->regulatory_class = common->rrm_frame_params.regulatory_class;
+	frame_req->channel_num = common->rrm_frame_params.channel_num;
+	frame_req->rand_int = common->rrm_frame_params.rand_interval;
+	frame_req->meas_duration = common->rrm_frame_params.meas_duration;
+	frame_req->frame_req_type = common->rrm_frame_params.frame_req_type;
+	ether_addr_copy(frame_req->macid, common->rrm_frame_params.macid);
+
+	skb_put(skb, frame_len);
+	info = IEEE80211_SKB_CB(skb);
+	info->control.vif = vif;
+	rsi_dbg(MGMT_TX_ZONE, "Sending frame measurement request\n");
+	rsi_core_xmit(common, skb);
+
+	return 0;
+}
+
+int rsi_rrm_send_beacon_req(struct rsi_common *common)
+{
+	struct ieee80211_vif *vif =
+		common->priv->vifs[common->priv->sc_nvifs - 1];
+	struct ieee80211_bss_conf *bss = &vif->bss_conf;
+	u8 frame_len;
+	struct sk_buff *skb = NULL;
+	struct dot11_beacon_meas_req *beacon_req;
+	struct dot11_elem *opt_sub;
+	struct ieee80211_tx_info *info;
+	u16 opt_elems_len;
+	u8 beacon_req_len;
+
+	frame_len = sizeof(struct dot11_beacon_meas_req) + MAX_OPT_SUB_ELM_SIZE;
+	skb = dev_alloc_skb(frame_len + DRV_HDR_SIZE);
+	if (!skb)
+		return -ENOMEM;
+	skb_reserve(skb, DRV_HDR_SIZE);
+	memset(skb->data, 0, frame_len);
+
+	beacon_req = (struct dot11_beacon_meas_req *)skb->data;
+
+	beacon_req->mac_hdr.frame_control = IEEE80211_STYPE_ACTION;
+	beacon_req->mac_hdr.duration_id = 0;
+	beacon_req->mac_hdr.seq_ctrl = 0;
+	ether_addr_copy(beacon_req->mac_hdr.addr1,
+			common->rrm_beacon_params.destid);
+	ether_addr_copy(beacon_req->mac_hdr.addr2, vif->addr);
+	ether_addr_copy(beacon_req->mac_hdr.addr3, bss->bssid);
+
+	beacon_req->action_body.category = WLAN_ACTION_RADIO_MEASUREMENT;
+	beacon_req->action_body.action = IEEE80211_ACTION_RADIO_MEAS_REQ;
+	beacon_req->action_body.dialog_token = 2; /* FIXME fill proper value */
+	beacon_req->action_body.num_repetitions = 0;
+	beacon_req->rmelem.mode = common->rrm_beacon_params.meas_req_mode;
+	beacon_req->rmelem.element_id = MEAS_REQ;
+	beacon_req_len =
+		sizeof(*beacon_req) - sizeof(struct ieee80211_basic_hdr);
+	beacon_req_len -= sizeof(struct wl_action_req);
+	beacon_req_len -= sizeof(struct rm_element);
+	beacon_req->rmelem.length = sizeof(struct rm_element) - 2 +
+				    beacon_req_len;
+	beacon_req->rmelem.token = 0;
+	beacon_req->rmelem.type = 5;
+
+	beacon_req->regulatory_class =
+		common->rrm_beacon_params.regulatory_class;
+	beacon_req->channel_num = common->rrm_beacon_params.channel_num;
+	beacon_req->rand_int = common->rrm_beacon_params.rand_interval;
+	beacon_req->meas_duration = common->rrm_beacon_params.meas_duration;
+	beacon_req->meas_mode = common->rrm_beacon_params.meas_mode;
+	ether_addr_copy(beacon_req->bssid, common->rrm_beacon_params.bssid);
+
+	opt_sub = (struct dot11_elem *)beacon_req->opt_elems;
+	opt_sub->elem_id = 2;
+	opt_sub->elem_len = 1;
+	opt_sub->elem_data[0] = 0;
+	opt_elems_len = 3;
+
+	opt_sub = (struct dot11_elem *)(beacon_req->opt_elems + opt_elems_len);
+	opt_sub->elem_id = 0;
+	opt_sub->elem_len = strlen(common->rrm_beacon_params.str);
+	memcpy(opt_sub->elem_data, common->rrm_beacon_params.str,
+	       opt_sub->elem_len);
+
+	opt_elems_len += (2 + opt_sub->elem_len);
+	beacon_req->rmelem.length += opt_elems_len;
+
+	skb_put(skb, sizeof(*beacon_req) + opt_elems_len);
+	info = IEEE80211_SKB_CB(skb);
+	info->control.vif = vif;
+	rsi_dbg(MGMT_TX_ZONE, "Sending beacon measurement request\n");
+	rsi_core_xmit(common, skb);
+
+	return 0;
+}
+#endif
+
+int rsi_rrm_parse_channel_load_req(struct rsi_common *common,
+				   struct sk_buff *skb, 
+				   struct rsi_meas_params *params)
+{
+	u8 *frm = &skb->data[MIN_802_11_HDR_LEN];
+
+	if (skb->len < RRM_MIN_CHLOAD_FRM_LEN)
+		return -EINVAL;
+
+	params->dialog_token = frm[2];
+	params->meas_req_mode = frm[8];
+	params->meas_type = frm[9];
+	params->regulatory_class = frm[10];
+	params->channel_num =  frm[11];
+	params->rand_interval = *(u16 *)&frm[12];
+	params->meas_duration = *(u16 *)&frm[14];
+
+	return 0;
+}
+
+int rsi_rrm_parse_frame_req(struct rsi_common *common,
+			    struct sk_buff *skb,
+			    struct rsi_frame_meas_params *params)
+{
+	u8 *frm = &skb->data[MIN_802_11_HDR_LEN];
+
+	if (skb->len < RRM_MIN_FRM_REQ_LEN)
+		return -EINVAL;
+
+	params->mp.dialog_token = frm[2];
+	params->mp.meas_req_mode = frm[8];
+	params->mp.meas_type = frm[9];
+	params->mp.regulatory_class = frm[10];
+	params->mp.channel_num =  frm[11];
+	params->mp.rand_interval = *(u16 *)&frm[12];
+	params->mp.meas_duration = *(u16 *)&frm[14];
+	params->frame_req_type = frm[16];
+	ether_addr_copy(params->mac_addr, &skb->data[17]);
+	
+	return 0;
+}
+
+int rsi_rrm_parse_beacon_req(struct rsi_common *common,
+			     struct sk_buff *skb,
+			     struct rsi_beacon_meas_params *params)
+{
+	u8 *frm = &skb->data[MIN_802_11_HDR_LEN];
+	u8 index = 0, flags = 0;
+	u8 opt_elem_id, opt_elem_len;
+
+	if (skb->len < RRM_MIN_BEACON_FRM_LEN)
+		return -EINVAL;
+
+	params->mp.dialog_token = frm[2];
+	params->mp.meas_req_mode = frm[8];
+	params->mp.meas_type = frm[9];
+	params->mp.regulatory_class = frm[10];
+	params->mp.channel_num =  frm[11];
+	params->mp.rand_interval = *(u16 *)&frm[12];
+	params->mp.meas_duration = *(u16 *)&frm[14];
+	params->meas_mode = frm[16];
+	ether_addr_copy(params->mac_addr, &frm[17]);
+
+	/* Parse through optional ids */
+	index = 23;// + MIN_802_11_HDR_LEN;
+	while (index < skb->len) {
+		opt_elem_id = frm[index];
+		opt_elem_len = frm[index + 1];
+		rsi_dbg(ERR_ZONE, "parse optional elemid %d elem_len %d\n",
+			opt_elem_id, opt_elem_len);
+		switch (opt_elem_id) {
+		case SSID_ELEM_ID:
+			flags = flags | (1 << 0);
+			rsi_dbg(ERR_ZONE, "SSID INFO\n");
+			memset(&params->ssid_ie[2], 0, SSID_LEN);
+			memcpy(&params->ssid_ie[2],
+			       &frm[index + 2],
+			       opt_elem_len);
+			rsi_dbg(ERR_ZONE, "SSID INFO %s %d\n",
+				&params->ssid_ie[2],
+				params->ssid_ie[1]);
+			break;
+
+		case BEACON_REPORT_INFO:
+			flags = flags | (1 << 1);
+			rsi_dbg(ERR_ZONE, "BEACON REPORT INFO\n");
+			memcpy(params->bcn_rpt_info,
+			       &frm[index],
+			       frm[index + 1] + 2);
+			break;
+
+		case REPORTING_DETAIL:
+			flags = flags | (1 << 2);
+			params->rpt_detail = frm[index + 2];
+			rsi_dbg(ERR_ZONE, "REPORTING DETAILS VALUE %d\n",
+				params->rpt_detail);
+			break;
+
+		case AP_CHANNEL_RPT:
+			flags = flags | (1 << 3);
+			rsi_dbg(ERR_ZONE, "Not supported in Firmware\n");
+			return -EOPNOTSUPP;
+
+		case VENDOR_SPECIFIC:
+			flags = flags | (1 << 4);
+			rsi_dbg(ERR_ZONE, "Not supported in Firmware\n");
+			return -EOPNOTSUPP;
+
+		default:
+			rsi_dbg(ERR_ZONE, "Reserved element id\n");
+			return -EOPNOTSUPP;
+		}
+		index += (2 + opt_elem_len);
+	}
+
+	return 0;
+}
+
+int rsi_rrm_sched_req(struct rsi_common *common)
+{
+	struct sk_buff *skb = NULL;
+	u8 meas_req_type;
+	struct rsi_meas_params chl_params;
+	struct rsi_frame_meas_params frm_params;
+	struct rsi_beacon_meas_params bcn_params;
+
+	rsi_dbg(MGMT_RX_ZONE, "%s: Dequeing the radio action packets\n",
+		__func__);
+
+	if (skb_queue_len(&common->rrm_queue) <= 0)
+		return 0;
+
+	if (!common->priv->rrm_enq_state)
+		skb = skb_dequeue(&common->rrm_queue);
+
+	if (!skb)
+		return 0;
+
+	common->rrm_pending_frame = skb;
+	rsi_hex_dump(ERR_ZONE, "RRM schedule frame\n", skb->data, skb->len);
+
+	meas_req_type = skb->data[9 + MIN_802_11_HDR_LEN];
+
+	if (skb->data[1 + MIN_802_11_HDR_LEN] ==
+	    IEEE80211_ACTION_RADIO_MEAS_REQ) {
+		common->priv->rrm_state = RRM_REQ_SENT;
+		common->priv->rrm_enq_state = 1;
+		switch (meas_req_type) {
+		case RRM_TYPE_CHANNEL_LOAD:
+			rsi_dbg(INFO_ZONE, "Received channel load request\n");
+			rsi_rrm_parse_channel_load_req(common, skb, &chl_params);
+			rsi_get_channel_load_meas(common, chl_params);
+			memcpy((u8 *)&common->chload_meas, (u8 *)&chl_params,
+				sizeof(struct rsi_meas_params));
+			break;
+		case RRM_TYPE_FRAME:
+			rsi_dbg(INFO_ZONE, "Received Frame request\n");
+			rsi_rrm_parse_frame_req(common, skb, &frm_params);
+			rsi_get_frame_meas(common, frm_params);
+			memcpy((u8 *)&common->frame_meas, (u8 *)&frm_params,
+				sizeof(struct rsi_frame_meas_params));
+			break;
+		case RRM_TYPE_BEACON:
+			rsi_dbg(INFO_ZONE, "Received Beacon request\n");
+			rsi_rrm_parse_beacon_req(common, skb, &bcn_params);
+			rsi_get_beacon_meas(common, bcn_params);
+			memcpy((u8 *)&common->beacon_meas, (u8 *)&bcn_params,
+				sizeof(struct rsi_beacon_meas_params));
+			break;
+		}
+	} else {
+		rsi_dbg(INFO_ZONE, "Measurement not supported\n");
+		return -EPERM;
+	}
+
+	return 0;
+}
+
+int rsi_rrm_parse_radio_action_frame(struct rsi_common *common,
+				     u8 *rx_rrm,
+				     s32 msg_len)
+{
+	struct rsi_hw *adapter = common->priv;
+	struct sk_buff *skb = NULL;
+
+	rsi_dbg(MGMT_RX_ZONE, "%s: Parsing Radio action frame\n", __func__);
+	if (common->num_pend_rrm_reqs > MAX_RRM_REQ) {
+		rsi_dbg(ERR_ZONE, "Maxm requests received; dropping the req\n");
+		kfree(rx_rrm);
+		return 0;
+	}
+	skb = dev_alloc_skb(MAX_MGMT_PKT_SIZE);
+	if (!skb)
+		return -ENOMEM;
+	memcpy(skb->data, rx_rrm, msg_len);
+	skb_put(skb, msg_len);
+	skb_queue_tail(&common->rrm_queue, skb);
+	rsi_dbg(MGMT_RX_ZONE, "%s:Queued frame to skb queue\n", __func__);
+
+	if (adapter->rrm_state == RRM_REQ_SENT)
+		return 0;
+
+	rsi_rrm_sched_req(common);
+
+	return 0;
+}
+
+int rsi_rrm_parse_spectrum_action_frame(struct rsi_common *common,
+					struct ieee80211_hdr *tmp_hdr,
+					u8 *frm)
+{
+	return 0;
+}
+
+int rsi_prepare_channel_load_rpt(struct rsi_common *common, u8 *msg, int len)
+{
+	struct rsi_hw *adapter = common->priv;
+	struct ieee80211_vif *vif = adapter->vifs[0];
+#ifndef RSI_DEBUG_RRM
+	u8 *rrm = NULL, tmp[6];
+#else
+	struct ieee80211_bss_conf *bss = &vif->bss_conf;
+#endif
+	u8 frame_len, chload_rpt_len;
+	struct sk_buff *skb = NULL;
+	struct channel_load_rpt *chload_rpt;
+	struct ieee80211_tx_info *info;
+
+	/* preparing on air channel load report */
+	frame_len = sizeof(struct channel_load_rpt);
+	skb = dev_alloc_skb(frame_len + DRV_HDR_SIZE);
+
+	if (!skb)
+		return -ENOMEM;
+	skb_reserve(skb, DRV_HDR_SIZE);
+
+	chload_rpt = (struct channel_load_rpt *)skb->data;
+	chload_rpt->action_body.category = WLAN_ACTION_RADIO_MEASUREMENT;
+	chload_rpt->action_body.action = IEEE80211_ACTION_RADIO_MEAS_RPT;
+#ifdef RSI_DEBUG_RRM
+	chload_rpt->mac_hdr.frame_control = IEEE80211_STYPE_ACTION;
+	chload_rpt->mac_hdr.duration_id = 0;
+	chload_rpt->mac_hdr.seq_ctrl = 0;
+	ether_addr_copy(chload_rpt->mac_hdr.addr1,
+			&common->rrm_pending_frame->data[10]);
+	ether_addr_copy(chload_rpt->mac_hdr.addr2, common->mac_addr);
+	ether_addr_copy(chload_rpt->mac_hdr.addr3, bss->bssid);
+	chload_rpt->action_body.dialog_token = 2;/* fill dialog_token*/
+	chload_rpt->regulatory_class = common->chload_meas.regulatory_class;
+	chload_rpt->channel_num = common->chload_meas.channel_num;
+#else
+	rrm = (u8 *)common->rrm_pending_frame->data;
+	memcpy(&chload_rpt->mac_hdr,
+	       (struct ieee80211_min_hdr *)common->rrm_pending_frame->data,
+	       MIN_802_11_HDR_LEN);
+	ether_addr_copy(tmp, chload_rpt->mac_hdr.addr1);
+	ether_addr_copy(chload_rpt->mac_hdr.addr1, chload_rpt->mac_hdr.addr2);
+	ether_addr_copy(chload_rpt->mac_hdr.addr2, tmp);
+	ether_addr_copy(chload_rpt->mac_hdr.addr3, chload_rpt->mac_hdr.addr1);
+
+	chload_rpt->action_body.dialog_token =
+		common->rrm_pending_frame->data[MIN_802_11_HDR_LEN + 2];
+	chload_rpt->regulatory_class =
+		common->rrm_pending_frame->data[MIN_802_11_HDR_LEN + 10];
+	chload_rpt->channel_num =
+		common->rrm_pending_frame->data[MIN_802_11_HDR_LEN + 11];
+#endif
+	chload_rpt->rmelem.element_id = MEAS_RPT;
+	chload_rpt_len =
+		sizeof(*chload_rpt) - sizeof(struct ieee80211_basic_hdr);
+	chload_rpt_len -= sizeof(struct wl_action);
+	chload_rpt_len -= sizeof(struct rm_element);
+	chload_rpt->rmelem.length = sizeof(struct rm_element) - 2 +
+				    chload_rpt_len;
+	chload_rpt->rmelem.token = 0;
+	chload_rpt->rmelem.type = 3;
+	chload_rpt->actual_meas_start_time = *(u64 *)&msg[16];
+	chload_rpt->meas_duration = *(u16 *)&msg[10];
+	chload_rpt->channel_load = msg[8];
+	chload_rpt->rmelem.mode = msg[6];
+
+	if ((chload_rpt->rmelem.mode >> 1 & 1) ||
+	    (chload_rpt->rmelem.mode >> 2 & 1)) {
+		rsi_dbg(INFO_ZONE,
+			"station incapable/refusing channel load report\n");
+		chload_rpt->actual_meas_start_time = 0;
+	}
+	rsi_dbg(ERR_ZONE, "sending onair channel load report\n");
+	skb_put(skb, sizeof(*chload_rpt));
+	info = IEEE80211_SKB_CB(skb);
+	info->control.vif = vif;
+	rsi_core_xmit(common, skb);
+	dev_kfree_skb(common->rrm_pending_frame);
+
+	return 0;
+}
+
+int rsi_prepare_frame_rpt(struct rsi_common *common, u8 *msg, int len)
+{
+#ifdef RSI_DEBUG_RRM
+	struct ieee80211_bss_conf *bss = NULL;
+	struct ieee80211_vif *vif = NULL;
+	struct rsi_hw *adapter = common->priv;
+#else
+	u8 *rrm = NULL, tmp[6];
+#endif
+	struct sk_buff *skb = NULL;
+	struct frame_report *frame_rpt;
+	u8 frame_len, frame_rpt_len;
+	u16 frame_entries;
+	struct ieee80211_tx_info *info;
+
+	/* preparing on air frame report */
+	frame_len = sizeof(struct frame_report);
+	skb = dev_alloc_skb(frame_len + DRV_HDR_SIZE);
+	if (!skb)
+		return -ENOMEM;
+	skb_reserve(skb, DRV_HDR_SIZE);
+
+	frame_rpt = (struct frame_report *)skb->data;
+	frame_rpt->action_body.category = WLAN_ACTION_RADIO_MEASUREMENT;
+	frame_rpt->action_body.action = IEEE80211_ACTION_RADIO_MEAS_RPT;
+#ifdef RSI_DEBUG_RRM
+	vif = rsi_get_vif(adapter, common->mac_addr);
+	bss = &vif->bss_conf;
+	frame_rpt->mac_hdr.frame_control = IEEE80211_STYPE_ACTION;
+	frame_rpt->mac_hdr.duration_id = 0;
+	frame_rpt->mac_hdr.seq_ctrl = 0;
+	ether_addr_copy(frame_rpt->mac_hdr.addr1,
+			&common->rrm_pending_frame->data[10]);
+	ether_addr_copy(frame_rpt->mac_hdr.addr2, common->mac_addr);
+	ether_addr_copy(frame_rpt->mac_hdr.addr3, bss->bssid);
+	frame_rpt->action_body.dialog_token = 2;/*fill dialog_token*/
+	frame_rpt->rmelem.mode = msg[6];
+	frame_rpt->regulatory_class = common->frame_meas.mp.regulatory_class;
+	frame_rpt->channel_num = common->frame_meas.mp.channel_num;
+#else
+	rrm = (u8 *)common->rrm_pending_frame;
+	memcpy(&frame_rpt->mac_hdr,
+	       (struct ieee80211_hdr *)common->rrm_pending_frame->data,
+	       MIN_802_11_HDR_LEN);
+	ether_addr_copy(tmp, frame_rpt->mac_hdr.addr1);
+	ether_addr_copy(frame_rpt->mac_hdr.addr1, frame_rpt->mac_hdr.addr2);
+	ether_addr_copy(frame_rpt->mac_hdr.addr2, tmp);
+	ether_addr_copy(frame_rpt->mac_hdr.addr3, frame_rpt->mac_hdr.addr1);
+	frame_rpt->action_body.dialog_token =
+		common->rrm_pending_frame->data[MIN_802_11_HDR_LEN + 2];
+	frame_rpt->regulatory_class =
+		common->rrm_pending_frame->data[MIN_802_11_HDR_LEN + 10];
+	frame_rpt->channel_num =
+		common->rrm_pending_frame->data[MIN_802_11_HDR_LEN + 11];
+
+#endif
+	frame_rpt->rmelem.element_id = MEAS_RPT;
+	frame_rpt->rmelem.token = 0;
+	frame_rpt->rmelem.type = 6;
+	frame_entries = *(u16 *)&msg[8];
+	frame_rpt->actual_meas_start_time = *(u64 *)&msg[36];
+	frame_rpt->meas_duration = *(u16 *)&msg[10];
+	frame_rpt->elem_id = 1;
+	frame_rpt_len = sizeof(*frame_rpt) - sizeof(struct ieee80211_basic_hdr);
+	frame_rpt_len -= sizeof(struct wl_action);
+	frame_rpt_len -= sizeof(struct rm_element);
+
+	frame_rpt->rmelem.length = sizeof(struct rm_element) - 2 +
+				    frame_rpt_len;
+	frame_rpt->length = (19 * frame_entries);
+
+	memcpy(&frame_rpt->tx_addr[0], &msg[24], 2);
+	memcpy(&frame_rpt->tx_addr[2], &msg[26], 2);
+	memcpy(&frame_rpt->tx_addr[4], &msg[28], 2);
+	memcpy(&frame_rpt->bssid[0], &msg[30], 2);
+	memcpy(&frame_rpt->bssid[2], &msg[32], 2);
+	memcpy(&frame_rpt->bssid[4], &msg[34], 2);
+	frame_rpt->phy_type = msg[16];
+	frame_rpt->avg_rcpi = msg[18];
+	frame_rpt->last_rcpi = msg[19];
+	frame_rpt->ant_id = msg[17];
+	frame_rpt->last_rsni = msg[20];
+	frame_rpt->frame_count = *(u16 *)&msg[22];
+	frame_rpt->rmelem.mode = msg[6];
+
+	rsi_dbg(INFO_ZONE, "frame_rpt->actual_meas_start_time %llu\n",
+		frame_rpt->actual_meas_start_time);
+	rsi_dbg(INFO_ZONE, "frame_rpt->meas_duration %d\n",
+		frame_rpt->meas_duration);
+	rsi_dbg(INFO_ZONE, "frame_rpt->phy_type %d\n",
+		frame_rpt->phy_type);
+	rsi_dbg(INFO_ZONE, "frame_rpt->avg_rcpi %d\n",
+		frame_rpt->avg_rcpi);
+	rsi_dbg(INFO_ZONE, "frame_rpt->last_rcpi %d\n",
+		frame_rpt->last_rcpi);
+	rsi_dbg(INFO_ZONE, "frame_rpt->ant_id %d\n",
+		frame_rpt->ant_id);
+	rsi_dbg(INFO_ZONE, "frame_rpt->last_rsni %d\n",
+		frame_rpt->last_rsni);
+	rsi_dbg(INFO_ZONE, "frame_rpt->frame_count %d\n",
+		frame_rpt->frame_count);
+	rsi_dbg(INFO_ZONE, "frame_rpt->length %d\n",
+		frame_rpt->length);
+	rsi_dbg(INFO_ZONE, "size of frame_report %d FRAME LEN %d\n",
+		(int)sizeof(struct frame_report), frame_len);
+	rsi_dbg(INFO_ZONE, "meas_rpt->length %d\n",
+		frame_rpt->rmelem.length);
+	rsi_hex_dump(ERR_ZONE, "frame report dump", skb->data, frame_len);
+	skb_put(skb, sizeof(*frame_rpt));
+	info = IEEE80211_SKB_CB(skb);
+	info->control.vif = common->priv->vifs[0];
+	rsi_core_xmit(common, skb);
+	dev_kfree_skb(common->rrm_pending_frame);
+
+	return 0;
+}
+
+int rsi_prepare_beacon_rpt(struct rsi_common *common, u8 *msg, int len)
+{
+#ifdef RSI_DEBUG_RRM
+	struct ieee80211_bss_conf *bss = NULL;
+	struct ieee80211_vif *vif = NULL;
+	struct rsi_hw *adapter = common->priv;
+#else
+	u8 tmp[6], *rrm = NULL;
+#endif
+	u8 frame_len, bcon_rpt_len;
+	u8 extended_desc = msg[4], frame_body_len;
+	struct sk_buff *skb = NULL;
+	struct beacon_report *bcon_rpt;
+	struct ieee80211_tx_info *info;
+
+	frame_body_len = len - extended_desc;
+	frame_len =  sizeof(struct beacon_report);
+	skb = dev_alloc_skb(frame_len + DRV_HDR_SIZE);
+	if (!skb)
+		return -ENOMEM;
+	skb_reserve(skb, DRV_HDR_SIZE);
+
+	bcon_rpt = (struct beacon_report *)skb->data;
+
+	bcon_rpt->action_body.category = WLAN_ACTION_RADIO_MEASUREMENT;
+	bcon_rpt->action_body.action = IEEE80211_ACTION_RADIO_MEAS_RPT;
+#ifdef RSI_DEBUG_RRM
+	vif = rsi_get_vif(adapter, common->mac_addr);
+	bss = &vif->bss_conf;
+	bcon_rpt->mac_hdr.frame_control = IEEE80211_STYPE_ACTION;
+	bcon_rpt->mac_hdr.duration_id = 0;
+	bcon_rpt->mac_hdr.seq_ctrl = 0;
+	ether_addr_copy(bcon_rpt->mac_hdr.addr1,
+			&common->rrm_pending_frame->data[10]);
+	ether_addr_copy(bcon_rpt->mac_hdr.addr2, common->mac_addr);
+	ether_addr_copy(bcon_rpt->mac_hdr.addr3, bss->bssid);
+	bcon_rpt->action_body.dialog_token = 2;/*fill dialog_token*/
+	bcon_rpt->regulatory_class = common->beacon_meas.mp.regulatory_class;
+	bcon_rpt->channel_num = common->beacon_meas.mp.channel_num;
+	ether_addr_copy(bcon_rpt->bssid, bss->bssid);
+#else
+
+	rrm = (u8 *)common->rrm_pending_frame->data;
+	memcpy(&bcon_rpt->mac_hdr,
+	       (struct ieee80211_hdr *)common->rrm_pending_frame->data,
+	       MIN_802_11_HDR_LEN);
+	ether_addr_copy(tmp, bcon_rpt->mac_hdr.addr1);
+	ether_addr_copy(bcon_rpt->mac_hdr.addr1, bcon_rpt->mac_hdr.addr2);
+	ether_addr_copy(bcon_rpt->mac_hdr.addr2, tmp);
+	ether_addr_copy(bcon_rpt->mac_hdr.addr3, bcon_rpt->mac_hdr.addr1);
+
+	bcon_rpt->action_body.dialog_token =
+		common->rrm_pending_frame->data[MIN_802_11_HDR_LEN + 2];
+	bcon_rpt->regulatory_class =
+		common->rrm_pending_frame->data[MIN_802_11_HDR_LEN + 10];
+	bcon_rpt->channel_num = rrm[MIN_802_11_HDR_LEN + 11];
+	memcpy(&bcon_rpt->bssid,
+	       &common->rrm_pending_frame->data[MIN_802_11_HDR_LEN + 17], 6);
+#endif
+	bcon_rpt->rmelem.element_id = MEAS_RPT;
+	bcon_rpt->rmelem.token = 0;
+	bcon_rpt->rmelem.type = 5;
+	bcon_rpt->rmelem.mode = msg[6];
+	bcon_rpt_len = sizeof(*bcon_rpt) - sizeof(struct ieee80211_basic_hdr);
+	bcon_rpt_len -= sizeof(struct wl_action);
+	bcon_rpt_len -= sizeof(struct rm_element);
+
+	bcon_rpt->rmelem.length = sizeof(struct rm_element) - 2 +
+				    bcon_rpt_len;
+	bcon_rpt->actual_meas_start_time = *(u64 *)&msg[24];
+	bcon_rpt->meas_duration = *(u16 *)&msg[10];
+	bcon_rpt->reported_frame_info = msg[16];
+	bcon_rpt->rcpi = msg[18];
+	bcon_rpt->rsni = msg[19];
+	bcon_rpt->antenna_id = msg[17];
+	bcon_rpt->parent_tsf = *(u32 *)&msg[20];
+
+	rsi_dbg(INFO_ZONE, "common->rrm_state %d\n",
+		common->priv->rrm_state);
+	rsi_hex_dump(ERR_ZONE, "BEACON REPORT ", skb->data, skb->len);
+	skb_put(skb, sizeof(*bcon_rpt));
+	info = IEEE80211_SKB_CB(skb);
+	info->control.vif = common->priv->vifs[0];
+	rsi_core_xmit(common, skb);
+	dev_kfree_skb(common->rrm_pending_frame);
+
+	return 0;
+}
+
+void rsi_rrm_recv_cmd_frame(struct rsi_common *common, u8 *msg, int len)
+{
+	u8 meas_type = msg[5];
+
+	switch (meas_type) {
+	case RRM_TYPE_CHANNEL_LOAD:
+		rsi_dbg(INFO_ZONE, "Preparing channel load report\n");
+		rsi_prepare_channel_load_rpt(common, msg, len);
+		break;
+	case RRM_TYPE_BEACON:
+		rsi_dbg(INFO_ZONE, "Preparing Beacon report\n");
+		rsi_prepare_beacon_rpt(common, msg, len);
+		break;
+	case RRM_TYPE_FRAME:
+		rsi_dbg(INFO_ZONE, "Preparing Frame report\n");
+		rsi_prepare_frame_rpt(common, msg, len);
+		break;
+	default:
+		rsi_dbg(INFO_ZONE, "Invalid cmd frame received\n");
+	}
+}
+
diff --git a/drivers/net/wireless/rsi/rsi_91x_sdio.c b/drivers/net/wireless/rsi/rsi_91x_sdio.c
index 8428858..ef78d4a 100644
--- a/drivers/net/wireless/rsi/rsi_91x_sdio.c
+++ b/drivers/net/wireless/rsi/rsi_91x_sdio.c
@@ -1,23 +1,39 @@
-/**
- * Copyright (c) 2014 Redpine Signals Inc.
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
  *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
  *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
  *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include <linux/module.h>
 #include "rsi_sdio.h"
 #include "rsi_common.h"
+#include "rsi_hal.h"
+#include "rsi_hci.h"
+
 
 /**
  * rsi_sdio_set_cmd52_arg() - This function prepares cmd 52 read/write arg.
@@ -51,7 +67,8 @@ static u32 rsi_sdio_set_cmd52_arg(bool rw,
  */
 static int rsi_cmd52writebyte(struct mmc_card *card,
 			      u32 address,
-			      u8 byte)
+			      u8 byte,
+			      bool expect_resp) 
 {
 	struct mmc_command io_cmd;
 	u32 arg;
@@ -60,7 +77,9 @@ static int rsi_cmd52writebyte(struct mmc_card *card,
 	arg = rsi_sdio_set_cmd52_arg(1, 0, 0, address, byte);
 	io_cmd.opcode = SD_IO_RW_DIRECT;
 	io_cmd.arg = arg;
-	io_cmd.flags = MMC_RSP_R5 | MMC_CMD_AC;
+	io_cmd.flags = MMC_CMD_AC;
+	if (expect_resp)
+		io_cmd.flags |= MMC_RSP_R5;
 
 	return mmc_wait_for_cmd(card->host, &io_cmd, 0);
 }
@@ -75,7 +94,8 @@ static int rsi_cmd52writebyte(struct mmc_card *card,
  */
 static int rsi_cmd52readbyte(struct mmc_card *card,
 			     u32 address,
-			     u8 *byte)
+			     u8 *byte,
+			     bool expect_resp)
 {
 	struct mmc_command io_cmd;
 	u32 arg;
@@ -85,7 +105,9 @@ static int rsi_cmd52readbyte(struct mmc_card *card,
 	arg = rsi_sdio_set_cmd52_arg(0, 0, 0, address, 0);
 	io_cmd.opcode = SD_IO_RW_DIRECT;
 	io_cmd.arg = arg;
-	io_cmd.flags = MMC_RSP_R5 | MMC_CMD_AC;
+	io_cmd.flags = MMC_CMD_AC;
+	if (expect_resp)
+		io_cmd.flags |= MMC_RSP_R5;
 
 	err = mmc_wait_for_cmd(card->host, &io_cmd, 0);
 	if ((!err) && (byte))
@@ -128,7 +150,7 @@ static int rsi_issue_sdiocommand(struct sdio_func *func,
 }
 
 /**
- * rsi_handle_interrupt() - This function is called upon the occurence
+ * rsi_handle_interrupt() - This function is called upon the occurrence
  *			    of an interrupt.
  * @function: Pointer to the sdio_func structure.
  *
@@ -137,10 +159,149 @@ static int rsi_issue_sdiocommand(struct sdio_func *func,
 static void rsi_handle_interrupt(struct sdio_func *function)
 {
 	struct rsi_hw *adapter = sdio_get_drvdata(function);
+	struct rsi_91x_sdiodev *dev =
+		(struct rsi_91x_sdiodev *)adapter->rsi_dev;
 
-	sdio_release_host(function);
+	if (adapter->priv->fsm_state == FSM_FW_NOT_LOADED)
+		return;
+	dev->sdio_irq_task = current;
 	rsi_interrupt_handler(adapter);
-	sdio_claim_host(function);
+	dev->sdio_irq_task = NULL;
+}
+
+static void rsi_gspi_init(struct rsi_hw *adapter)
+{
+	unsigned long gspi_ctrl_reg0_val;
+	
+	/* Programming gspi frequency = soc_frequency / 2 */
+	/* Warning : ULP seemed to be not working
+	 * well at high frequencies. Modify accordingly */
+	gspi_ctrl_reg0_val = 0x4;
+	/* csb_setup_time [5:4] */
+	gspi_ctrl_reg0_val |= 0x10; 
+	/* csb_hold_time [7:6] */
+	gspi_ctrl_reg0_val |= 0x40; 
+	/* csb_high_time [9:8] */
+	gspi_ctrl_reg0_val |= 0x100; 
+	/* spi_mode [10] */
+	gspi_ctrl_reg0_val |= 0x000; 
+	/* clock_phase [11] */
+	gspi_ctrl_reg0_val |= 0x000; 
+	/* Initializing GSPI for ULP read/writes */
+	rsi_sdio_master_reg_write(adapter,
+				  GSPI_CTRL_REG0,
+				  gspi_ctrl_reg0_val,
+				  2);
+}
+
+static void ulp_read_write(struct rsi_hw *adapter, u16 addr, u16 *data, u16 len_in_bits)
+{
+	rsi_sdio_master_reg_write(adapter,
+				  GSPI_DATA_REG1,
+				  ((addr << 6) | (data[1] & 0x3f)),
+				  2);
+	rsi_sdio_master_reg_write(adapter,
+				  GSPI_DATA_REG0,
+				  *(u16 *)&data[0],
+				  2);
+	rsi_gspi_init(adapter);
+	rsi_sdio_master_reg_write(adapter,
+				  GSPI_CTRL_REG1,
+				  ((len_in_bits - 1) | GSPI_TRIG),
+				  2);
+	msleep(10);
+}
+
+static void rsi_reset_chip(struct rsi_hw *adapter)
+{
+	u16 temp[4] = {0};
+	u8 *data;
+	u8 sdio_interrupt_status = 0;
+
+	data = kzalloc(sizeof(u32), GFP_KERNEL);
+	if (!data)
+		return;
+
+	put_unaligned_le32(TA_SDIO_WAKE_REQUEST, data);
+	rsi_dbg(INFO_ZONE, "Writing disable to wakeup register\n");
+	if (rsi_sdio_write_register(adapter,
+				    0,
+				    SDIO_WAKEUP_REG,
+				    data) < 0) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Failed to Write SDIO WAKEUP REG\n", __func__);
+		goto err;
+	}
+	msleep(3);
+	if (rsi_sdio_read_register(adapter,
+				   RSI_FN1_INT_REGISTER,
+				   &sdio_interrupt_status) < 0) {
+		rsi_dbg(ERR_ZONE, "%s: Failed to Read Intr Status Register\n",
+			__func__);
+		goto err;
+	}
+	rsi_dbg(INFO_ZONE, "%s: Intr Status Register value = %d \n",
+		__func__, sdio_interrupt_status);
+
+	/* Put TA on hold */
+	if (rsi_sdio_master_access_msword(adapter, 0x2200)) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Unable to set ms word to common reg\n",
+			__func__);
+		goto err;
+	}
+
+	put_unaligned_le32(TA_HOLD_THREAD_VALUE, data);
+	if (rsi_sdio_write_register_multiple(adapter,
+					TA_HOLD_THREAD_REG | SD_REQUEST_MASTER,
+					(u8 *)data, 4)) {
+		rsi_dbg(ERR_ZONE, "%s: Unable to hold TA threads\n", __func__);
+		goto err;
+	}
+
+	/* This msleep will ensure TA processor to go to hold and any pending dma
+	 * transfers to rf spi in device to finish */
+	msleep(100);
+	if (adapter->device_model == RSI_DEV_9116) {
+		if ((rsi_sdio_master_reg_write(adapter,
+					       NWP_WWD_INTERRUPT_TIMER,
+						5, 4)) < 0) {
+			rsi_dbg(ERR_ZONE, "Failed to write to intr timer\n");
+		}
+		if ((rsi_sdio_master_reg_write(adapter,
+					       NWP_WWD_SYSTEM_RESET_TIMER,
+						4, 4)) < 0) {
+			rsi_dbg(ERR_ZONE,
+				"Failed to write to system reset timer\n");
+		}
+		if ((rsi_sdio_master_reg_write(adapter,
+					       NWP_WWD_MODE_AND_RSTART,
+						0xAA0001, 4)) < 0) {
+			rsi_dbg(ERR_ZONE,
+				"Failed to write to mode and restart\n");
+		}
+		rsi_dbg(ERR_ZONE, "***** Watch Dog Reset Successful *****\n");
+	} else {
+		*(u32 *)temp = 0;
+		ulp_read_write(adapter, ULP_RESET_REG, temp, 32);
+		*(u32 *)temp = 2;
+		ulp_read_write(adapter, WATCH_DOG_TIMER_1, temp, 32);
+		*(u32 *)temp = 0;
+		ulp_read_write(adapter, WATCH_DOG_TIMER_2, temp, 32);
+		*(u32 *)temp = 50;
+		ulp_read_write(adapter, WATCH_DOG_DELAY_TIMER_1, temp, 32);
+		*(u32 *)temp = 0;
+		ulp_read_write(adapter, WATCH_DOG_DELAY_TIMER_2, temp, 32);
+		*(u32 *)temp = ((0xaa000) | RESTART_WDT | BYPASS_ULP_ON_WDT);
+		ulp_read_write(adapter, WATCH_DOG_TIMER_ENABLE, temp, 32);
+	}
+
+	msleep(1000);
+
+err:
+	kfree(data);
+	return;
+
 }
 
 /**
@@ -151,31 +312,35 @@ static void rsi_handle_interrupt(struct sdio_func *function)
  */
 static void rsi_reset_card(struct sdio_func *pfunction)
 {
-	int ret = 0;
 	int err;
 	struct mmc_card *card = pfunction->card;
 	struct mmc_host *host = card->host;
-	s32 bit = (fls(host->ocr_avail) - 1);
-	u8 cmd52_resp;
+	u8 cmd52_resp = 0;
 	u32 clock, resp, i;
 	u16 rca;
+	u32 cmd_delay = 0;
 
-	/* Reset 9110 chip */
-	ret = rsi_cmd52writebyte(pfunction->card,
+#ifdef CONFIG_CARACALLA_BOARD
+	/* Reset chip */
+	err = rsi_cmd52writebyte(pfunction->card,
 				 SDIO_CCCR_ABORT,
-				 (1 << 3));
+				 (1 << 3), true);
 
 	/* Card will not send any response as it is getting reset immediately
 	 * Hence expect a timeout status from host controller
 	 */
-	if (ret != -ETIMEDOUT)
-		rsi_dbg(ERR_ZONE, "%s: Reset failed : %d\n", __func__, ret);
+	if (err != -ETIMEDOUT)
+		rsi_dbg(ERR_ZONE, "%s: Reset failed : %d\n", __func__, err);
+
+	cmd_delay = 20;
+#else
+	cmd_delay = 2;
+#endif
 
 	/* Wait for few milli seconds to get rid of residue charges if any */
-	msleep(20);
+	msleep(cmd_delay);
 
 	/* Initialize the SDIO card */
-	host->ios.vdd = bit;
 	host->ios.chip_select = MMC_CS_DONTCARE;
 	host->ios.bus_mode = MMC_BUSMODE_OPENDRAIN;
 	host->ios.power_mode = MMC_POWER_UP;
@@ -187,7 +352,7 @@ static void rsi_reset_card(struct sdio_func *pfunction)
 	 * This delay should be sufficient to allow the power supply
 	 * to reach the minimum voltage.
 	 */
-	msleep(20);
+	msleep(cmd_delay);
 
 	host->ios.clock = host->f_min;
 	host->ios.power_mode = MMC_POWER_ON;
@@ -197,12 +362,12 @@ static void rsi_reset_card(struct sdio_func *pfunction)
 	 * This delay must be at least 74 clock sizes, or 1 ms, or the
 	 * time required to reach a stable voltage.
 	 */
-	msleep(20);
+	msleep(cmd_delay);
 
 	/* Issue CMD0. Goto idle state */
 	host->ios.chip_select = MMC_CS_HIGH;
 	host->ops->set_ios(host, &host->ios);
-	msleep(20);
+	msleep(cmd_delay);
 	err = rsi_issue_sdiocommand(pfunction,
 				    MMC_GO_IDLE_STATE,
 				    0,
@@ -210,13 +375,17 @@ static void rsi_reset_card(struct sdio_func *pfunction)
 				    NULL);
 	host->ios.chip_select = MMC_CS_DONTCARE;
 	host->ops->set_ios(host, &host->ios);
-	msleep(20);
+	msleep(cmd_delay);
 	host->use_spi_crc = 0;
 
 	if (err)
 		rsi_dbg(ERR_ZONE, "%s: CMD0 failed : %d\n", __func__, err);
 
+#ifdef CONFIG_CARACALLA_BOARD
 	if (!host->ocr_avail) {
+#else
+	if (1) {
+#endif
 		/* Issue CMD5, arg = 0 */
 		err = rsi_issue_sdiocommand(pfunction,
 					    SD_IO_SEND_OP_COND,
@@ -226,14 +395,22 @@ static void rsi_reset_card(struct sdio_func *pfunction)
 		if (err)
 			rsi_dbg(ERR_ZONE, "%s: CMD5 failed : %d\n",
 				__func__, err);
+#ifdef CONFIG_CARACALLA_BOARD
 		host->ocr_avail = resp;
+#else
+		card->ocr = resp;
+#endif
 	}
 
 	/* Issue CMD5, arg = ocr. Wait till card is ready  */
 	for (i = 0; i < 100; i++) {
 		err = rsi_issue_sdiocommand(pfunction,
 					    SD_IO_SEND_OP_COND,
+#ifdef CONFIG_CARACALLA_BOARD
 					    host->ocr_avail,
+#else
+					    card->ocr,
+#endif
 					    (MMC_RSP_R4 | MMC_CMD_BCR),
 					    &resp);
 		if (err) {
@@ -244,7 +421,7 @@ static void rsi_reset_card(struct sdio_func *pfunction)
 
 		if (resp & MMC_CARD_BUSY)
 			break;
-		msleep(20);
+		msleep(cmd_delay);
 	}
 
 	if ((i == 100) || (err)) {
@@ -281,14 +458,16 @@ static void rsi_reset_card(struct sdio_func *pfunction)
 	/* Enable high speed */
 	if (card->host->caps & MMC_CAP_SD_HIGHSPEED) {
 		rsi_dbg(ERR_ZONE, "%s: Set high speed mode\n", __func__);
-		err = rsi_cmd52readbyte(card, SDIO_CCCR_SPEED, &cmd52_resp);
+		err = rsi_cmd52readbyte(card, SDIO_CCCR_SPEED, &cmd52_resp,
+					true);
 		if (err) {
 			rsi_dbg(ERR_ZONE, "%s: CCCR speed reg read failed: %d\n",
 				__func__, err);
 		} else {
 			err = rsi_cmd52writebyte(card,
 						 SDIO_CCCR_SPEED,
-						 (cmd52_resp | SDIO_SPEED_EHS));
+						 (cmd52_resp | SDIO_SPEED_EHS),
+						 true);
 			if (err) {
 				rsi_dbg(ERR_ZONE,
 					"%s: CCR speed regwrite failed %d\n",
@@ -317,7 +496,7 @@ static void rsi_reset_card(struct sdio_func *pfunction)
 		err = rsi_cmd52writebyte(card,
 					 SDIO_CCCR_IF,
 					 (SDIO_BUS_CD_DISABLE |
-					  SDIO_BUS_WIDTH_4BIT));
+					  SDIO_BUS_WIDTH_4BIT), true);
 		if (err) {
 			rsi_dbg(ERR_ZONE, "%s: Set bus mode failed : %d\n",
 				__func__, err);
@@ -326,6 +505,7 @@ static void rsi_reset_card(struct sdio_func *pfunction)
 		host->ios.bus_width = MMC_BUS_WIDTH_4;
 		host->ops->set_ios(host, &host->ios);
 	}
+	mdelay(cmd_delay);
 }
 
 /**
@@ -361,6 +541,7 @@ static int rsi_setblocklength(struct rsi_hw *adapter, u32 length)
 	struct rsi_91x_sdiodev *dev =
 		(struct rsi_91x_sdiodev *)adapter->rsi_dev;
 	int status;
+
 	rsi_dbg(INIT_ZONE, "%s: Setting the block length\n", __func__);
 
 	status = sdio_set_block_size(dev->pfunction, length);
@@ -386,6 +567,7 @@ static int rsi_setupcard(struct rsi_hw *adapter)
 	rsi_setclock(adapter, 50000);
 
 	dev->tx_blk_size = 256;
+	adapter->tx_blk_size = dev->tx_blk_size;
 	status = rsi_setblocklength(adapter, dev->tx_blk_size);
 	if (status)
 		rsi_dbg(ERR_ZONE,
@@ -411,14 +593,16 @@ int rsi_sdio_read_register(struct rsi_hw *adapter,
 	u8 fun_num = 0;
 	int status;
 
-	sdio_claim_host(dev->pfunction);
+	if (likely(dev->sdio_irq_task != current))
+		sdio_claim_host(dev->pfunction);
 
 	if (fun_num == 0)
 		*data = sdio_f0_readb(dev->pfunction, addr, &status);
 	else
 		*data = sdio_readb(dev->pfunction, addr, &status);
 
-	sdio_release_host(dev->pfunction);
+	if (likely(dev->sdio_irq_task != current))
+		sdio_release_host(dev->pfunction);
 
 	return status;
 }
@@ -442,14 +626,16 @@ int rsi_sdio_write_register(struct rsi_hw *adapter,
 		(struct rsi_91x_sdiodev *)adapter->rsi_dev;
 	int status = 0;
 
-	sdio_claim_host(dev->pfunction);
+	if (likely(dev->sdio_irq_task != current))
+		sdio_claim_host(dev->pfunction);
 
 	if (function == 0)
 		sdio_f0_writeb(dev->pfunction, *data, addr, &status);
 	else
 		sdio_writeb(dev->pfunction, *data, addr, &status);
 
-	sdio_release_host(dev->pfunction);
+	if (likely(dev->sdio_irq_task != current))
+		sdio_release_host(dev->pfunction);
 
 	return status;
 }
@@ -464,17 +650,16 @@ int rsi_sdio_write_register(struct rsi_hw *adapter,
 void rsi_sdio_ack_intr(struct rsi_hw *adapter, u8 int_bit)
 {
 	int status;
+
 	status = rsi_sdio_write_register(adapter,
 					 1,
 					 (SDIO_FUN1_INTR_CLR_REG |
-					  RSI_SD_REQUEST_MASTER),
+					  SD_REQUEST_MASTER),
 					 &int_bit);
 	if (status)
 		rsi_dbg(ERR_ZONE, "%s: unable to send ack\n", __func__);
 }
 
-
-
 /**
  * rsi_sdio_read_register_multiple() - This function read multiple bytes of
  *				       information from the SD card.
@@ -485,20 +670,22 @@ void rsi_sdio_ack_intr(struct rsi_hw *adapter, u8 int_bit)
  *
  * Return: 0 on success, -1 on failure.
  */
-static int rsi_sdio_read_register_multiple(struct rsi_hw *adapter,
-					   u32 addr,
-					   u32 count,
-					   u8 *data)
+int rsi_sdio_read_register_multiple(struct rsi_hw *adapter,
+				    u32 addr,
+				    u8 *data,
+				    u16 count)
 {
 	struct rsi_91x_sdiodev *dev =
 		(struct rsi_91x_sdiodev *)adapter->rsi_dev;
-	u32 status;
+	u32 status = 0;
 
-	sdio_claim_host(dev->pfunction);
+	if (likely(dev->sdio_irq_task != current))
+		sdio_claim_host(dev->pfunction);
 
 	status =  sdio_readsb(dev->pfunction, data, addr, count);
 
-	sdio_release_host(dev->pfunction);
+	if (likely(dev->sdio_irq_task != current))
+		sdio_release_host(dev->pfunction);
 
 	if (status != 0)
 		rsi_dbg(ERR_ZONE, "%s: Synch Cmd53 read failed\n", __func__);
@@ -518,7 +705,7 @@ static int rsi_sdio_read_register_multiple(struct rsi_hw *adapter,
 int rsi_sdio_write_register_multiple(struct rsi_hw *adapter,
 				     u32 addr,
 				     u8 *data,
-				     u32 count)
+				     u16 count)
 {
 	struct rsi_91x_sdiodev *dev =
 		(struct rsi_91x_sdiodev *)adapter->rsi_dev;
@@ -536,11 +723,13 @@ int rsi_sdio_write_register_multiple(struct rsi_hw *adapter,
 		dev->write_fail++;
 	}
 
-	sdio_claim_host(dev->pfunction);
+	if (likely(dev->sdio_irq_task != current))
+		sdio_claim_host(dev->pfunction);
 
 	status = sdio_writesb(dev->pfunction, addr, data, count);
 
-	sdio_release_host(dev->pfunction);
+	if (likely(dev->sdio_irq_task != current))
+		sdio_release_host(dev->pfunction);
 
 	if (status) {
 		rsi_dbg(ERR_ZONE, "%s: Synch Cmd53 write failed %d\n",
@@ -552,6 +741,195 @@ int rsi_sdio_write_register_multiple(struct rsi_hw *adapter,
 	return status;
 }
 
+int rsi_sdio_load_data_master_write(struct rsi_hw *adapter,
+				    u32 base_address,
+				    u32 instructions_sz,
+				    u16 block_size,
+				    u8 *ta_firmware)
+{
+	u32 num_blocks;
+	u16 msb_address;
+	u32 offset, ii;
+	u8 *temp_buf;
+	u16 lsb_address;
+
+	temp_buf = kzalloc(block_size, GFP_KERNEL);
+	if (!temp_buf)
+		return -ENOMEM;
+
+	num_blocks = instructions_sz / block_size;
+	msb_address = base_address >> 16;
+
+	rsi_dbg(INFO_ZONE, "ins_size: %d\n", instructions_sz);
+	rsi_dbg(INFO_ZONE, "num_blocks: %d\n", num_blocks);
+
+	/* Loading DM ms word in the sdio slave */
+	if (rsi_sdio_master_access_msword(adapter, msb_address)) {
+		rsi_dbg(ERR_ZONE, "%s: Unable to set ms word reg\n", __func__);
+		goto err;
+	}
+
+	for (offset = 0, ii = 0; ii < num_blocks; ii++, offset += block_size) {
+		memset(temp_buf, 0, block_size);
+		memcpy(temp_buf, ta_firmware + offset, block_size);
+		lsb_address = (u16)base_address;
+		if (rsi_sdio_write_register_multiple(adapter,
+					lsb_address | SD_REQUEST_MASTER,
+					temp_buf, block_size)) {
+			rsi_dbg(ERR_ZONE, "%s: failed to write\n", __func__);
+			goto err;
+		}
+		rsi_dbg(INFO_ZONE, "%s: loading block: %d\n", __func__, ii);
+		base_address += block_size;
+
+		if ((base_address >> 16) != msb_address) {
+			msb_address += 1;
+
+			/* Loading DM ms word in the sdio slave */
+			if (rsi_sdio_master_access_msword(adapter,
+							  msb_address)) {
+				rsi_dbg(ERR_ZONE,
+					"%s: Unable to set ms word reg\n",
+					__func__);
+				goto err;
+			}
+		}
+	}
+
+	if (instructions_sz % block_size) {
+		memset(temp_buf, 0, block_size);
+		memcpy(temp_buf,
+		       ta_firmware + offset,
+		       instructions_sz % block_size);
+		lsb_address = (u16)base_address;
+		if (rsi_sdio_write_register_multiple(adapter,
+						lsb_address | SD_REQUEST_MASTER,
+						temp_buf,
+						instructions_sz % block_size)) {
+			goto err;
+		}
+		rsi_dbg(INFO_ZONE,
+			"Written Last Block in Address 0x%x Successfully\n",
+			offset | SD_REQUEST_MASTER);
+	}
+	kfree(temp_buf);
+	return 0;
+
+err:
+	kfree(temp_buf);
+	return -EIO;
+
+}
+
+int rsi_sdio_master_reg_read(struct rsi_hw *adapter, u32 addr,
+			     u32 *read_buf, u16 size)
+{
+	u32 *data = NULL;
+	u16 ms_addr = 0;
+	u32 addr_on_bus;
+
+	data = kzalloc(RSI_MASTER_REG_BUF_SIZE, GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	ms_addr = (addr >> 16);
+	if (rsi_sdio_master_access_msword(adapter, ms_addr)) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Unable to set ms word to common reg\n",
+			__func__);
+		kfree(data);
+		return -EIO;
+	}
+	addr = addr & 0xFFFF;
+
+	addr_on_bus = (addr & 0xFF000000);
+	if ((addr_on_bus == (FLASH_SIZE_ADDR & 0xFF000000)) ||
+	    (addr_on_bus == 0x0)) {
+		addr_on_bus = (addr & ~(0x3));
+	} else
+		addr_on_bus = addr;
+
+	/* Bring TA out of reset */
+	if (rsi_sdio_read_register_multiple(adapter,
+					    (addr_on_bus | SD_REQUEST_MASTER),
+					    (u8 *)data, 4)) {
+		rsi_dbg(ERR_ZONE, "%s: AHB register read failed\n", __func__);
+		kfree(data);
+		return -EIO;
+	}
+	if (size == 2) {
+		if ((addr & 0x3) == 0)
+			*read_buf = *data;
+		else
+			*read_buf  = (*data >> 16);
+		*read_buf = (*read_buf & 0xFFFF);
+	} else if (size == 1) {
+		if ((addr & 0x3) == 0)
+			*read_buf = *data;
+		else if ((addr & 0x3) == 1)
+			*read_buf = (*data >> 8);
+		else if ((addr & 0x3) == 2)
+			*read_buf = (*data >> 16);
+		else
+			*read_buf = (*data >> 24);
+		*read_buf = (*read_buf & 0xFF);
+	} else { /*size is 4 */
+		*read_buf = *data;
+	}
+
+	kfree(data);
+	return 0;
+}
+
+int rsi_sdio_master_reg_write(struct rsi_hw *adapter,
+			      unsigned long addr,
+			      unsigned long data,
+			      u16 size)
+{
+	unsigned long *data_aligned;
+
+	data_aligned = kzalloc(RSI_MASTER_REG_BUF_SIZE, GFP_KERNEL);
+	if (!data_aligned)
+		return -ENOMEM;
+
+	if (size == 2) {
+		*data_aligned = ((data << 16) | (data & 0xFFFF));
+	} else if (size == 1) {
+		u32 temp_data;
+
+		temp_data = (data & 0xFF);
+		*data_aligned = ((temp_data << 24) |
+				  (temp_data << 16) |
+				  (temp_data << 8) |
+				  (temp_data));
+	} else {
+		*data_aligned = data;
+	}
+	size = 4;
+
+	if (rsi_sdio_master_access_msword(adapter, (addr >> 16))) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Unable to set ms word to common reg\n",
+			__func__);
+		kfree(data_aligned);
+		return -EIO;
+	}
+	addr = addr & 0xFFFF;
+
+	/* Bring TA out of reset */
+	if (rsi_sdio_write_register_multiple(adapter,
+					     (addr | SD_REQUEST_MASTER),
+					     (u8 *)data_aligned, size)) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Unable to do AHB reg write\n", __func__);
+		kfree(data_aligned);
+		return -EIO;
+	}
+
+	kfree(data_aligned);
+	return 0;
+}
+
 /**
  * rsi_sdio_host_intf_write_pkt() - This function writes the packet to device.
  * @adapter: Pointer to the adapter structure.
@@ -560,9 +938,9 @@ int rsi_sdio_write_register_multiple(struct rsi_hw *adapter,
  *
  * Return: 0 on success, -1 on failure.
  */
-static int rsi_sdio_host_intf_write_pkt(struct rsi_hw *adapter,
-					u8 *pkt,
-					u32 len)
+int rsi_sdio_host_intf_write_pkt(struct rsi_hw *adapter,
+				 u8 *pkt,
+				 u32 len)
 {
 	struct rsi_91x_sdiodev *dev =
 		(struct rsi_91x_sdiodev *)adapter->rsi_dev;
@@ -570,8 +948,14 @@ static int rsi_sdio_host_intf_write_pkt(struct rsi_hw *adapter,
 	u32 num_blocks, address, length;
 	u32 queueno;
 	int status;
+#ifdef CONFIG_RSI_NO_SDIO_MULTIBLOCK
+	u8 *tbuf = pkt;
+	u32 remain_length;
+#endif
 
 	queueno = ((pkt[1] >> 4) & 0xf);
+	if ((queueno == RSI_BT_DATA_Q) || (queueno == RSI_BT_MGMT_Q))
+		queueno = RSI_BT_Q;
 
 	num_blocks = len / block_size;
 
@@ -581,14 +965,32 @@ static int rsi_sdio_host_intf_write_pkt(struct rsi_hw *adapter,
 	address = (num_blocks * block_size | (queueno << 12));
 	length  = num_blocks * block_size;
 
+#ifndef CONFIG_RSI_NO_SDIO_MULTIBLOCK
 	status = rsi_sdio_write_register_multiple(adapter,
 						  address,
-						  (u8 *)pkt,
+						  pkt,
 						  length);
-	if (status)
+#else
+	remain_length = length;
+	do {
+		if (remain_length == length)
+			status = rsi_sdio_write_register_multiple(adapter, address, tbuf, 256);
+		else
+			status = rsi_sdio_write_register_multiple(adapter, 0, tbuf, 256);
+		if (status)
+			break;
+		if (remain_length > 256)
+			remain_length -= 256;
+		else
+			break;
+		tbuf += 256;
+	} while (1); 
+#endif
+	if (status < 0)
 		rsi_dbg(ERR_ZONE, "%s: Unable to write onto the card: %d\n",
 			__func__, status);
 	rsi_dbg(DATA_TX_ZONE, "%s: Successfully written onto card\n", __func__);
+
 	return status;
 }
 
@@ -614,8 +1016,8 @@ int rsi_sdio_host_intf_read_pkt(struct rsi_hw *adapter,
 
 	status = rsi_sdio_read_register_multiple(adapter,
 						 length,
-						 length, /*num of bytes*/
-						 (u8 *)pkt);
+						 (u8 *)pkt,
+						 length);
 
 	if (status)
 		rsi_dbg(ERR_ZONE, "%s: Failed to read frame: %d\n", __func__,
@@ -623,6 +1025,106 @@ int rsi_sdio_host_intf_read_pkt(struct rsi_hw *adapter,
 	return status;
 }
 
+static int rsi_sdio_ta_reset_ops(struct rsi_hw *adapter)
+{
+	u8 *data;
+
+	data = kzalloc(sizeof(u32), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	if (rsi_sdio_master_access_msword(adapter, 0x2200) < 0) {
+		rsi_dbg(ERR_ZONE,
+			"Unable to set ms word to common reg\n");
+		goto err;
+	}
+
+	rsi_dbg(INIT_ZONE, "%s: Bringing TA Out of Reset\n", __func__);
+	put_unaligned_le32(TA_HOLD_THREAD_VALUE, data);
+
+	/* Bringing TA out of reset */
+	if (rsi_sdio_write_register_multiple(adapter,
+					     TA_HOLD_THREAD_REG |
+					     SD_REQUEST_MASTER,
+					     data, 4) < 0) {
+		rsi_dbg(ERR_ZONE, "Unable to hold TA threads\n");
+		goto err;
+	}
+	data = TA_SOFT_RST_CLR;
+	/* Bringing TA out of reset */
+	if (rsi_sdio_write_register_multiple(adapter,
+					     TA_SOFT_RESET_REG |
+					     SD_REQUEST_MASTER,
+					     data, 4) < 0) {
+		rsi_dbg(ERR_ZONE, "Unable to get TA out of reset state\n");
+		goto err;
+	}
+
+	/* Assuming TA will go to hold by this time
+	 * If you find that TA is not in hold by this time
+	 * in any chip or any project, then wait till TA goes to
+	 * hold by polling poll_status register.
+	 **/
+	data = TA_PC_ZERO;
+	/* Bringing TA out of reset */
+	if (rsi_sdio_write_register_multiple(adapter,
+					     TA_TH0_PC_REG |
+					     SD_REQUEST_MASTER,
+					     data, 4) < 0) {
+		rsi_dbg(ERR_ZONE, "Unable to Reset TA PC value\n");
+		goto err;
+	}
+	put_unaligned_le32(TA_RELEASE_THREAD_VALUE, data);
+	/* Bringing TA out of reset */
+	if (rsi_sdio_write_register_multiple(adapter,
+					     TA_RELEASE_THREAD_REG |
+					     SD_REQUEST_MASTER,
+					     data, 4) < 0) {
+		rsi_dbg(ERR_ZONE, "Unable to release TA threads\n");
+		goto err;
+	}
+	if (rsi_sdio_master_access_msword(adapter, 0x4105) < 0) {
+		rsi_dbg(ERR_ZONE, "Unable to set ms word to common reg\n");
+		goto err;
+	}
+
+	rsi_dbg(INIT_ZONE, "Setting ms word to common reg 0x41050000\n");
+	kfree(data);
+	return 0;
+
+err:
+	kfree(data);
+	return -EINVAL;
+
+}
+
+int rsi_sdio_reinit_device(struct rsi_hw *adapter)
+{
+	struct rsi_91x_sdiodev *sdev = adapter->rsi_dev;
+	struct sdio_func *pfunction = sdev->pfunction;
+	int ii;
+
+	/* Flush soft queues */
+	for (ii = 0; ii < NUM_SOFT_QUEUES; ii++)
+		skb_queue_purge(&adapter->priv->tx_queue[ii]);
+
+	/* Initialize device again */
+	sdio_claim_host(pfunction);
+
+	sdio_release_irq(pfunction);
+	rsi_reset_card(pfunction);
+
+	sdio_enable_func(pfunction);
+	rsi_setupcard(adapter);
+	rsi_init_sdio_slave_regs(adapter);
+	sdio_claim_irq(pfunction, rsi_handle_interrupt);
+	rsi_hal_device_init(adapter);
+
+	sdio_release_host(pfunction);
+
+	return 0;
+}
+
 /**
  * rsi_init_sdio_interface() - This function does init specific to SDIO.
  *
@@ -643,6 +1145,7 @@ static int rsi_init_sdio_interface(struct rsi_hw *adapter,
 		return status;
 
 	adapter->rsi_dev = rsi_91x_dev;
+	rsi_91x_dev->sdio_irq_task = NULL;
 
 	sdio_claim_host(pfunction);
 
@@ -667,7 +1170,7 @@ static int rsi_init_sdio_interface(struct rsi_hw *adapter,
 		goto fail;
 	}
 
-	rsi_dbg(INIT_ZONE, "%s: Setup card succesfully\n", __func__);
+	rsi_dbg(INIT_ZONE, "%s: Setup card successfully\n", __func__);
 
 	status = rsi_init_sdio_slave_regs(adapter);
 	if (status) {
@@ -676,11 +1179,10 @@ static int rsi_init_sdio_interface(struct rsi_hw *adapter,
 	}
 	sdio_release_host(pfunction);
 
-	adapter->host_intf_write_pkt = rsi_sdio_host_intf_write_pkt;
-	adapter->host_intf_read_pkt = rsi_sdio_host_intf_read_pkt;
 	adapter->determine_event_timeout = rsi_sdio_determine_event_timeout;
-	adapter->check_hw_queue_status = rsi_sdio_read_buffer_status_register;
-
+	adapter->process_isr_hci = rsi_interrupt_handler;
+	adapter->check_intr_status_reg = rsi_read_intr_status_reg;
+	
 #ifdef CONFIG_RSI_DEBUGFS
 	adapter->num_debugfs_entries = MAX_DEBUGFS_ENTRIES;
 #endif
@@ -691,6 +1193,20 @@ static int rsi_init_sdio_interface(struct rsi_hw *adapter,
 	return status;
 }
 
+static struct rsi_host_intf_ops sdio_host_intf_ops = {
+	.write_pkt		= rsi_sdio_host_intf_write_pkt,
+	.read_pkt		= rsi_sdio_host_intf_read_pkt,
+	.master_access_msword	= rsi_sdio_master_access_msword,
+	.master_reg_read	= rsi_sdio_master_reg_read,
+	.master_reg_write	= rsi_sdio_master_reg_write,
+	.read_reg_multiple	= rsi_sdio_read_register_multiple,
+	.write_reg_multiple	= rsi_sdio_write_register_multiple,
+	.load_data_master_write	= rsi_sdio_load_data_master_write,
+	.check_hw_queue_status	= rsi_sdio_check_buffer_status,
+	.ta_reset_ops           = rsi_sdio_ta_reset_ops,
+	.reinit_device          = rsi_sdio_reinit_device,
+};
+
 /**
  * rsi_probe() - This function is called by kernel when the driver provided
  *		 Vendor and device IDs are matched. All the initialization
@@ -704,6 +1220,9 @@ static int rsi_probe(struct sdio_func *pfunction,
 		     const struct sdio_device_id *id)
 {
 	struct rsi_hw *adapter;
+	struct rsi_91x_sdiodev *sdev;
+	struct rsi_common *common;
+	int status;
 
 	rsi_dbg(INIT_ZONE, "%s: Init function called\n", __func__);
 
@@ -714,32 +1233,90 @@ static int rsi_probe(struct sdio_func *pfunction,
 		return 1;
 	}
 
+	common = adapter->priv;
+	adapter->rsi_host_intf = RSI_HOST_INTF_SDIO;
+	adapter->host_intf_ops = &sdio_host_intf_ops;
+	if (rsi_opermode_instances(adapter)) {
+		rsi_dbg(ERR_ZONE, "%s: Invalid operating modes\n",
+			__func__);
+		goto fail_free_adapter;
+	}
+
 	if (rsi_init_sdio_interface(adapter, pfunction)) {
 		rsi_dbg(ERR_ZONE, "%s: Failed to init sdio interface\n",
 			__func__);
-		goto fail;
+		goto fail_free_adapter;
 	}
 
-	if (rsi_sdio_device_init(adapter->priv)) {
-		rsi_dbg(ERR_ZONE, "%s: Failed in device init\n", __func__);
-		sdio_claim_host(pfunction);
-		sdio_disable_func(pfunction);
-		sdio_release_host(pfunction);
-		goto fail;
+	rsi_dbg(INFO_ZONE, "Vendor Id:%x, Device Id:%x\n",
+		pfunction->vendor, pfunction->device);
+	if ((pfunction->device == 0X9330)) {
+		rsi_dbg(ERR_ZONE, "%s: ***** 9113 Module *****\n", __func__);
+		adapter->device_model = RSI_DEV_9113;
+	} else  if ((pfunction->device == 0X9116)) {
+		rsi_dbg(ERR_ZONE, "%s: ***** 9116 Module *****\n", __func__);
+		adapter->device_model = RSI_DEV_9116;
+	} else {
+		rsi_dbg(ERR_ZONE,
+			"##### Invalid RSI device id 0x%x\n",
+			pfunction->device);
+		goto fail_free_adapter;
+	}
+
+	/* Initialize receive path */
+	sdev = adapter->rsi_dev;
+	rsi_init_event(&sdev->rx_thread.event);
+	status = rsi_create_kthread(adapter->priv, &sdev->rx_thread,
+				    rsi_sdio_rx_thread, "SDIO-RX-Thread");
+	if (status) {
+		rsi_dbg(ERR_ZONE, "%s: Unable to init rx thrd\n", __func__);
+		goto fail_kill_thread;
 	}
+	skb_queue_head_init(&sdev->rx_q.head);
+	sdev->rx_q.num_rx_pkts = 0;
 
+#ifdef CONFIG_SDIO_INTR_POLL
+	init_sdio_intr_status_poll_thread(adapter->priv);
+#endif
 	sdio_claim_host(pfunction);
 	if (sdio_claim_irq(pfunction, rsi_handle_interrupt)) {
 		rsi_dbg(ERR_ZONE, "%s: Failed to request IRQ\n", __func__);
 		sdio_release_host(pfunction);
-		goto fail;
+		goto fail_claim_irq;
 	}
-
 	sdio_release_host(pfunction);
 	rsi_dbg(INIT_ZONE, "%s: Registered Interrupt handler\n", __func__);
 
+	if (rsi_hal_device_init(adapter)) {
+		rsi_dbg(ERR_ZONE, "%s: Failed in device init\n", __func__);
+		goto fail_dev_init;
+	}
+	rsi_dbg(INFO_ZONE, "===> RSI Device Init Done <===\n");
+
+	if (rsi_sdio_master_access_msword(adapter, MISC_CFG_BASE_ADDR)) {
+		rsi_dbg(ERR_ZONE, "%s: Unable to set ms word reg\n", __func__);
+		goto fail_dev_init;
+	}
+	rsi_dbg(INIT_ZONE, "%s: Setting ms word to 0x41050000\n", __func__);
+
+	adapter->priv->hibernate_resume = false;
+
 	return 0;
-fail:
+
+fail_dev_init:
+	sdio_claim_host(pfunction);
+	sdio_release_irq(pfunction);
+	sdio_release_host(pfunction);
+fail_claim_irq:
+	rsi_kill_thread(&sdev->rx_thread);
+fail_kill_thread:
+	sdio_claim_host(pfunction);
+	sdio_disable_func(pfunction);
+	sdio_release_host(pfunction);
+fail_free_adapter:
+#ifdef CONFIG_SDIO_INTR_POLL
+	rsi_kill_thread(&adapter->priv->sdio_intr_poll_thread);
+#endif
 	rsi_91x_deinit(adapter);
 	rsi_dbg(ERR_ZONE, "%s: Failed in probe...Exiting\n", __func__);
 	return 1;
@@ -761,42 +1338,357 @@ static void rsi_disconnect(struct sdio_func *pfunction)
 
 	dev = (struct rsi_91x_sdiodev *)adapter->rsi_dev;
 
-	dev->write_fail = 2;
-	rsi_mac80211_detach(adapter);
+#ifdef CONFIG_SDIO_INTR_POLL
+	rsi_kill_thread(&adapter->priv->sdio_intr_poll_thread);
+#endif
+	rsi_kill_thread(&dev->rx_thread);
 
 	sdio_claim_host(pfunction);
 	sdio_release_irq(pfunction);
-	sdio_disable_func(pfunction);
-	rsi_91x_deinit(adapter);
-	/* Resetting to take care of the case, where-in driver is re-loaded */
+	sdio_release_host(pfunction);
+
+	rsi_mac80211_detach(adapter);
+
+#if defined(CONFIG_RSI_BT_ALONE) || defined(CONFIG_RSI_COEX)
+	if ((adapter->priv->coex_mode == 2) ||
+	    (adapter->priv->coex_mode == 4))
+		rsi_hci_detach(adapter->priv);
+#endif
+
+	/* Reset Chip */
+	rsi_reset_chip(adapter);
+
+	/* Resetting to take care of the case, where-in driver
+	 * is re-loaded */
+	sdio_claim_host(pfunction);
 	rsi_reset_card(pfunction);
+	sdio_disable_func(pfunction);
 	sdio_release_host(pfunction);
+	dev->write_fail = 2;
+	rsi_91x_deinit(adapter);
+
+	rsi_dbg(ERR_ZONE, "##### RSI SDIO device disconnected #####\n");
 }
 
 #ifdef CONFIG_PM
+static int rsi_set_sdio_pm_caps(struct rsi_hw *adapter)
+{
+	struct rsi_91x_sdiodev *dev =
+		(struct rsi_91x_sdiodev *)adapter->rsi_dev;
+	struct sdio_func *func = dev->pfunction;
+	int ret;
+
+	/* Keep Power to the MMC while suspend */
+	ret = sdio_set_host_pm_flags(func, MMC_PM_KEEP_POWER);
+	if (ret) {
+		rsi_dbg(ERR_ZONE, "set sdio keep pwr flag failed: %d\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+static int rsi_sdio_disable_interrupts(struct sdio_func *pfunction)
+{
+	struct rsi_hw *adapter = sdio_get_drvdata(pfunction);
+	u8 isr_status = 0, data = 0;
+	int ret;
+
+	rsi_dbg(ERR_ZONE, "Waiting for interrupts to be cleared..");
+	do {
+		rsi_sdio_read_register(adapter,
+				       RSI_FN1_INT_REGISTER,
+				       &isr_status);
+		rsi_dbg(ERR_ZONE, ".");
+	} while (isr_status); 
+	rsi_dbg(ERR_ZONE, "\nInterrupts cleared");
+
+	sdio_claim_host(pfunction);
+	ret = rsi_cmd52readbyte(pfunction->card, 0x04, &data, false);
+	if (ret < 0) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Failed to read INTR_EN register\n",
+			__func__);
+		sdio_release_host(pfunction);
+		return ret;
+	}
+	rsi_dbg(INFO_ZONE, "INTR_EN reg content = %x\n", data);
+
+	/* And bit0 and b1 */
+	data &= 0xfc;
+
+	ret = rsi_cmd52writebyte(pfunction->card, 0x04, data, false);
+	if (ret < 0) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Failed to Write to INTR_EN register\n",
+			__func__);
+		sdio_release_host(pfunction);
+		return ret;
+	}
+	ret = rsi_cmd52readbyte(pfunction->card, 0x04, &data, false);
+	if (ret < 0) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Failed to read INTR_EN register\n",
+			__func__);
+		sdio_release_host(pfunction);
+		return ret;
+	}
+	rsi_dbg(INFO_ZONE, "INTR_EN reg content. = %x\n", data);
+
+	sdio_release_host(pfunction);
+
+	return 0;
+}
+
+static int rsi_sdio_enable_interrupts(struct sdio_func *pfunction)
+{
+	u8 data;
+	int ret;
+
+	sdio_claim_host(pfunction);
+	ret = rsi_cmd52readbyte(pfunction->card, 0x04, &data, false);
+	if (ret < 0) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Failed to read INTR_EN register\n", __func__);
+		sdio_release_host(pfunction);
+		return ret;
+	}
+	rsi_dbg(INFO_ZONE, "INTR_EN reg content1 = %x\n", data);
+
+	/* Enable b1 and b0 */
+	data |= 0x03;
+
+	ret = rsi_cmd52writebyte(pfunction->card, 0x04, data, false);
+	if (ret < 0) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Failed to Write to INTR_EN register\n",
+			__func__);
+		sdio_release_host(pfunction);
+		return ret;
+	}
+	
+        ret = rsi_cmd52readbyte(pfunction->card, 0x04, &data, false);
+	if (ret < 0) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Failed to read INTR_EN register\n", __func__);
+		sdio_release_host(pfunction);
+		return ret;
+	}
+	rsi_dbg(INFO_ZONE, "INTR_EN reg content1.. = %x\n", data);
+	sdio_release_host(pfunction);
+
+	return ret;
+}
+
 static int rsi_suspend(struct device *dev)
 {
-	/* Not yet implemented */
-	return -ENOSYS;
+	int ret = 0;
+	struct sdio_func *pfunction = dev_to_sdio_func(dev);
+	struct rsi_hw *adapter = sdio_get_drvdata(pfunction);
+	struct rsi_common *common = adapter->priv;
+	struct rsi_91x_sdiodev *sdev =
+		(struct rsi_91x_sdiodev *)adapter->rsi_dev;
+
+	rsi_dbg(ERR_ZONE, "SDIO Bus suspend ===>\n");
+
+	if (!adapter) {
+		rsi_dbg(ERR_ZONE, "Device is not ready\n");
+		return -ENODEV;
+	}
+
+	common->suspend_in_prog = true;
+#ifdef CONFIG_RSI_WOW
+	if ((common->wow_flags & RSI_WOW_ENABLED) &&
+	    (common->wow_flags & RSI_WOW_NO_CONNECTION))
+		rsi_dbg(ERR_ZONE,
+			"##### Device can not wake up through WLAN\n");
+
+#endif
+
+	ret = rsi_sdio_disable_interrupts(pfunction);
+
+	if (sdev->write_fail)
+		rsi_dbg(INFO_ZONE, "###### Device is not ready #######\n");
+
+	ret = rsi_set_sdio_pm_caps(adapter);
+	if (ret)
+		rsi_dbg(INFO_ZONE,
+			"Setting power management caps failed\n");
+
+	common->fsm_state = FSM_CARD_NOT_READY;
+	rsi_dbg(INFO_ZONE, "***** RSI module suspended ******\n");
+
+	return 0;
 }
 
 static int rsi_resume(struct device *dev)
 {
-	/* Not yet implemented */
-	return -ENOSYS;
+	int ret = 0;
+	struct sdio_func *pfunction = dev_to_sdio_func(dev);
+	struct rsi_hw *adapter = sdio_get_drvdata(pfunction);
+	struct rsi_common *common = adapter->priv;
+        
+	rsi_dbg(INFO_ZONE, "SDIO Bus resume =====>\n");
+
+	common->suspend_in_prog = false;
+	common->fsm_state = FSM_MAC_INIT_DONE;
+
+	ret = rsi_sdio_enable_interrupts(pfunction);
+
+	rsi_dbg(INFO_ZONE, "***** RSI module resumed *****\n");
+
+	return 0;
+}
+
+static int rsi_freeze(struct device *dev)
+{
+	int ret = 0;
+	struct sdio_func *pfunction = dev_to_sdio_func(dev);
+	struct rsi_hw *adapter = sdio_get_drvdata(pfunction);
+	struct rsi_common *common;
+	struct rsi_91x_sdiodev *sdev;
+
+	rsi_dbg(INFO_ZONE, "SDIO Bus freeze ===>\n");
+
+	if (!adapter) {
+		rsi_dbg(ERR_ZONE, "Device is not ready\n");
+		return -ENODEV;
+	}
+	common = adapter->priv;
+	sdev = (struct rsi_91x_sdiodev *)adapter->rsi_dev;
+
+	common->suspend_in_prog = true;
+#ifdef CONFIG_RSI_WOW
+	if ((common->wow_flags & RSI_WOW_ENABLED) &&
+	    (common->wow_flags & RSI_WOW_NO_CONNECTION))
+		rsi_dbg(ERR_ZONE,
+			"##### Device can not wake up through WLAN\n");
+#endif
+#if defined(CONFIG_RSI_BT_ALONE) || defined(CONFIG_RSI_COEX)
+	rsi_hci_detach(common);
+#endif
+
+	ret = rsi_sdio_disable_interrupts(pfunction);
+
+	if (sdev->write_fail)
+		rsi_dbg(INFO_ZONE, "###### Device is not ready #######\n");
+	
+	ret = rsi_set_sdio_pm_caps(adapter);
+	if (ret)
+		rsi_dbg(INFO_ZONE, "Setting power management caps failed\n");
+	
+	rsi_dbg(INFO_ZONE, "***** RSI module freezed *****\n");
+
+	return 0;
+}
+
+static int rsi_thaw(struct device *dev)
+{
+	struct sdio_func *pfunction = dev_to_sdio_func(dev);
+	struct rsi_hw *adapter = sdio_get_drvdata(pfunction);
+        
+	rsi_dbg(ERR_ZONE, "SDIO Bus thaw =====>\n");
+
+	adapter->priv->hibernate_resume = true;
+	adapter->priv->fsm_state = FSM_CARD_NOT_READY;
+	adapter->priv->bt_fsm_state = BT_DEVICE_NOT_READY;
+	adapter->priv->iface_down = true;
+
+	rsi_sdio_enable_interrupts(pfunction);
+
+	rsi_dbg(INFO_ZONE, "***** RSI module thaw done *****\n");
+
+	return 0;
+}
+
+static int rsi_poweroff(struct device *dev)
+{
+	return rsi_freeze(dev);
+}
+
+static void rsi_shutdown(struct device *dev)
+{
+	struct sdio_func *pfunction = dev_to_sdio_func(dev);
+	struct rsi_hw *adapter = sdio_get_drvdata(pfunction);
+	struct rsi_91x_sdiodev *sdev =
+		(struct rsi_91x_sdiodev *)adapter->rsi_dev;
+#ifdef CONFIG_RSI_WOW
+	struct ieee80211_hw *hw = adapter->hw;
+	struct cfg80211_wowlan *wowlan = hw->wiphy->wowlan_config;
+#endif
+
+	rsi_dbg(ERR_ZONE, "SDIO Bus shutdown =====>\n");
+
+	adapter->priv->suspend_in_prog = true;
+
+#ifdef CONFIG_RSI_WOW
+	if (rsi_config_wowlan(adapter, wowlan))
+		rsi_dbg(ERR_ZONE, "Failed to configure WoWLAN\n");
+#endif
+
+#if defined(CONFIG_RSI_BT_ALONE) || defined(CONFIG_RSI_COEX)
+	rsi_hci_detach(adapter->priv);
+#endif
+
+	rsi_sdio_disable_interrupts(sdev->pfunction);
+
+	if (sdev->write_fail)
+		rsi_dbg(INFO_ZONE, "###### Device is not ready #######\n");
+	
+	if (rsi_set_sdio_pm_caps(adapter))
+		rsi_dbg(INFO_ZONE, "Setting power management caps failed\n");
+
+	rsi_dbg(INFO_ZONE, "***** RSI module shut down *****\n");
+}
+
+static int rsi_restore(struct device *dev)
+{
+	struct sdio_func *pfunction = dev_to_sdio_func(dev);
+	struct rsi_hw *adapter = sdio_get_drvdata(pfunction);
+
+	rsi_dbg(INFO_ZONE, "SDIO Bus restore ======>\n");
+
+	adapter->priv->suspend_in_prog = false;
+	adapter->priv->hibernate_resume = true;
+	adapter->priv->fsm_state = FSM_FW_NOT_LOADED;
+	adapter->priv->bt_fsm_state = BT_DEVICE_NOT_READY;
+	adapter->priv->iface_down = true;
+
+	adapter->sc_nvifs = 0;
+#ifdef CONFIG_HW_SCAN_OFFLOAD
+	rsi_mac80211_hw_scan_cancel(adapter->hw, adapter->priv->scan_vif);
+	flush_workqueue(adapter->priv->scan_workqueue);
+#endif
+	ieee80211_stop_queues(adapter->hw);
+	ieee80211_restart_hw(adapter->hw);
+
+	/* Initialize device again */
+	adapter->priv->reinit_hw = true;
+	rsi_sdio_reinit_device(adapter);
+
+#ifdef CONFIG_RSI_WOW
+	adapter->priv->wow_flags = 0;
+#endif
+	adapter->priv->iface_down = false;
+
+	rsi_dbg(INFO_ZONE, "RSI module restored\n");
+
+	return 0;
 }
 
 static const struct dev_pm_ops rsi_pm_ops = {
 	.suspend = rsi_suspend,
 	.resume = rsi_resume,
+	.freeze = rsi_freeze,
+	.thaw = rsi_thaw,
+	.poweroff = rsi_poweroff,
+	.restore = rsi_restore,
 };
 #endif
 
 static const struct sdio_device_id rsi_dev_table[] =  {
-	{ SDIO_DEVICE(0x303, 0x100) },
-	{ SDIO_DEVICE(0x041B, 0x0301) },
-	{ SDIO_DEVICE(0x041B, 0x0201) },
-	{ SDIO_DEVICE(0x041B, 0x9330) },
+	{ SDIO_DEVICE(SDIO_VENDOR_ID_RSI, SDIO_DEVICE_ID_RSI_9113) },
+	{ SDIO_DEVICE(SDIO_VENDOR_ID_RSI, SDIO_DEVICE_ID_RSI_9116) },
 	{ /* Blank */},
 };
 
@@ -808,6 +1700,7 @@ static int rsi_resume(struct device *dev)
 #ifdef CONFIG_PM
 	.drv = {
 		.pm = &rsi_pm_ops,
+	        .shutdown   = rsi_shutdown,
 	}
 #endif
 };
@@ -847,5 +1740,5 @@ static void rsi_module_exit(void)
 MODULE_SUPPORTED_DEVICE("RSI-91x");
 MODULE_DEVICE_TABLE(sdio, rsi_dev_table);
 MODULE_FIRMWARE(FIRMWARE_RSI9113);
-MODULE_VERSION("0.1");
+MODULE_VERSION(DRV_VER);
 MODULE_LICENSE("Dual BSD/GPL");
diff --git a/drivers/net/wireless/rsi/rsi_91x_sdio_ops.c b/drivers/net/wireless/rsi/rsi_91x_sdio_ops.c
index 40d7231..1d6c23b 100644
--- a/drivers/net/wireless/rsi/rsi_91x_sdio_ops.c
+++ b/drivers/net/wireless/rsi/rsi_91x_sdio_ops.c
@@ -1,23 +1,37 @@
-/**
- * Copyright (c) 2014 Redpine Signals Inc.
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
  *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
  *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
  *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include <linux/firmware.h>
 #include "rsi_sdio.h"
 #include "rsi_common.h"
+#include "rsi_hal.h"
 
 /**
  * rsi_sdio_master_access_msword() - This function sets the AHB master access
@@ -27,8 +41,8 @@
  *
  * Return: status: 0 on success, -1 on failure.
  */
-static int rsi_sdio_master_access_msword(struct rsi_hw *adapter,
-					 u16 ms_word)
+int rsi_sdio_master_access_msword(struct rsi_hw *adapter,
+				  u16 ms_word)
 {
 	u8 byte;
 	u8 function = 0;
@@ -36,7 +50,7 @@ static int rsi_sdio_master_access_msword(struct rsi_hw *adapter,
 
 	byte = (u8)(ms_word & 0x00FF);
 
-	rsi_dbg(INIT_ZONE,
+	rsi_dbg(INFO_ZONE,
 		"%s: MASTER_ACCESS_MSBYTE:0x%x\n", __func__, byte);
 
 	status = rsi_sdio_write_register(adapter,
@@ -52,7 +66,7 @@ static int rsi_sdio_master_access_msword(struct rsi_hw *adapter,
 
 	byte = (u8)(ms_word >> 8);
 
-	rsi_dbg(INIT_ZONE, "%s:MASTER_ACCESS_LSBYTE:0x%x\n", __func__, byte);
+	rsi_dbg(INFO_ZONE, "%s:MASTER_ACCESS_LSBYTE:0x%x\n", __func__, byte);
 	status = rsi_sdio_write_register(adapter,
 					 function,
 					 SDIO_MASTER_ACCESS_LSBYTE,
@@ -60,169 +74,48 @@ static int rsi_sdio_master_access_msword(struct rsi_hw *adapter,
 	return status;
 }
 
-/**
- * rsi_copy_to_card() - This function includes the actual funtionality of
- *			copying the TA firmware to the card.Basically this
- *			function includes opening the TA file,reading the
- *			TA file and writing their values in blocks of data.
- * @common: Pointer to the driver private structure.
- * @fw: Pointer to the firmware value to be written.
- * @len: length of firmware file.
- * @num_blocks: Number of blocks to be written to the card.
- *
- * Return: 0 on success and -1 on failure.
- */
-static int rsi_copy_to_card(struct rsi_common *common,
-			    const u8 *fw,
-			    u32 len,
-			    u32 num_blocks)
+void rsi_sdio_rx_thread(struct rsi_common *common)
 {
 	struct rsi_hw *adapter = common->priv;
-	struct rsi_91x_sdiodev *dev =
-		(struct rsi_91x_sdiodev *)adapter->rsi_dev;
-	u32 indx, ii;
-	u32 block_size = dev->tx_blk_size;
-	u32 lsb_address;
-	__le32 data[] = { TA_HOLD_THREAD_VALUE, TA_SOFT_RST_CLR,
-			  TA_PC_ZERO, TA_RELEASE_THREAD_VALUE };
-	u32 address[] = { TA_HOLD_THREAD_REG, TA_SOFT_RESET_REG,
-			  TA_TH0_PC_REG, TA_RELEASE_THREAD_REG };
-	u32 base_address;
-	u16 msb_address;
-
-	base_address = TA_LOAD_ADDRESS;
-	msb_address = base_address >> 16;
-
-	for (indx = 0, ii = 0; ii < num_blocks; ii++, indx += block_size) {
-		lsb_address = ((u16) base_address | RSI_SD_REQUEST_MASTER);
-		if (rsi_sdio_write_register_multiple(adapter,
-						     lsb_address,
-						     (u8 *)(fw + indx),
-						     block_size)) {
-			rsi_dbg(ERR_ZONE,
-				"%s: Unable to load %s blk\n", __func__,
-				FIRMWARE_RSI9113);
-			return -1;
-		}
-		rsi_dbg(INIT_ZONE, "%s: loading block: %d\n", __func__, ii);
-		base_address += block_size;
-		if ((base_address >> 16) != msb_address) {
-			msb_address += 1;
-			if (rsi_sdio_master_access_msword(adapter,
-							  msb_address)) {
-				rsi_dbg(ERR_ZONE,
-					"%s: Unable to set ms word reg\n",
-					__func__);
-				return -1;
-			}
-		}
-	}
+	struct rsi_91x_sdiodev *sdev = adapter->rsi_dev;
+	struct sk_buff *skb;
+	int status;
+	bool done = false;
 
-	if (len % block_size) {
-		lsb_address = ((u16) base_address | RSI_SD_REQUEST_MASTER);
-		if (rsi_sdio_write_register_multiple(adapter,
-						     lsb_address,
-						     (u8 *)(fw + indx),
-						     len % block_size)) {
-			rsi_dbg(ERR_ZONE,
-				"%s: Unable to load f/w\n", __func__);
-			return -1;
-		}
-	}
-	rsi_dbg(INIT_ZONE,
-		"%s: Succesfully loaded TA instructions\n", __func__);
+	do {
+		rsi_wait_event(&sdev->rx_thread.event, EVENT_WAIT_FOREVER);
 
-	if (rsi_sdio_master_access_msword(adapter, TA_BASE_ADDR)) {
-		rsi_dbg(ERR_ZONE,
-			"%s: Unable to set ms word to common reg\n",
-			__func__);
-		return -1;
-	}
+		if (atomic_read(&sdev->rx_thread.thread_done))
+			break;
 
-	for (ii = 0; ii < ARRAY_SIZE(data); ii++) {
-		/* Bringing TA out of reset */
-		if (rsi_sdio_write_register_multiple(adapter,
-						     (address[ii] |
-						     RSI_SD_REQUEST_MASTER),
-						     (u8 *)&data[ii],
-						     4)) {
-			rsi_dbg(ERR_ZONE,
-				"%s: Unable to hold TA threads\n", __func__);
-			return -1;
+		while (true) {
+			skb = skb_dequeue(&sdev->rx_q.head);
+			if (!skb)
+				break;
+			status = rsi_read_pkt(common, skb->data, skb->len);
+			if (status) {
+				rsi_dbg(ERR_ZONE, "Failed to read the packet\n");
+				dev_kfree_skb(skb);
+				return;
+			}
+			dev_kfree_skb(skb);
+			if (sdev->rx_q.num_rx_pkts > 0)
+				sdev->rx_q.num_rx_pkts--;
+			
+			if (atomic_read(&sdev->rx_thread.thread_done)) {
+				done = true;
+				break;
+			}
 		}
-	}
-
-	rsi_dbg(INIT_ZONE, "%s: loaded firmware\n", __func__);
-	return 0;
-}
-
-/**
- * rsi_load_ta_instructions() - This function includes the actual funtionality
- *				of loading the TA firmware.This function also
- *				includes opening the TA file,reading the TA
- *				file and writing their value in blocks of data.
- * @common: Pointer to the driver private structure.
- *
- * Return: status: 0 on success, -1 on failure.
- */
-static int rsi_load_ta_instructions(struct rsi_common *common)
-{
-	struct rsi_hw *adapter = common->priv;
-	struct rsi_91x_sdiodev *dev =
-		(struct rsi_91x_sdiodev *)adapter->rsi_dev;
-	u32 len;
-	u32 num_blocks;
-	const u8 *fw;
-	const struct firmware *fw_entry = NULL;
-	u32 block_size = dev->tx_blk_size;
-	int status = 0;
-	u32 base_address;
-	u16 msb_address;
-
-	if (rsi_sdio_master_access_msword(adapter, TA_BASE_ADDR)) {
-		rsi_dbg(ERR_ZONE,
-			"%s: Unable to set ms word to common reg\n",
-			__func__);
-		return -1;
-	}
-	base_address = TA_LOAD_ADDRESS;
-	msb_address = (base_address >> 16);
-
-	if (rsi_sdio_master_access_msword(adapter, msb_address)) {
-		rsi_dbg(ERR_ZONE,
-			"%s: Unable to set ms word reg\n", __func__);
-		return -1;
-	}
-
-	status = request_firmware(&fw_entry, FIRMWARE_RSI9113, adapter->device);
-	if (status < 0) {
-		rsi_dbg(ERR_ZONE, "%s Firmware file %s not found\n",
-			__func__, FIRMWARE_RSI9113);
-		return status;
-	}
-
-	/* Copy firmware into DMA-accessible memory */
-	fw = kmemdup(fw_entry->data, fw_entry->size, GFP_KERNEL);
-	if (!fw) {
-		status = -ENOMEM;
-		goto out;
-	}
-	len = fw_entry->size;
-
-	if (len % 4)
-		len += (4 - (len % 4));
-
-	num_blocks = (len / block_size);
-
-	rsi_dbg(INIT_ZONE, "%s: Instruction size:%d\n", __func__, len);
-	rsi_dbg(INIT_ZONE, "%s: num blocks: %d\n", __func__, num_blocks);
-
-	status = rsi_copy_to_card(common, fw, len, num_blocks);
-	kfree(fw);
+		rsi_reset_event(&sdev->rx_thread.event);
+		if (done)
+			break;
+	} while (1);
 
-out:
-	release_firmware(fw_entry);
-	return status;
+	rsi_dbg(INFO_ZONE, "%s: Terminated SDIO RX thread\n", __func__);
+	skb_queue_purge(&sdev->rx_q.head);
+	atomic_inc(&sdev->rx_thread.thread_done);
+	complete_and_exit(&sdev->rx_thread.completion, 0);
 }
 
 /**
@@ -235,43 +128,75 @@ static int rsi_load_ta_instructions(struct rsi_common *common)
 static int rsi_process_pkt(struct rsi_common *common)
 {
 	struct rsi_hw *adapter = common->priv;
+	struct rsi_91x_sdiodev *dev =
+		(struct rsi_91x_sdiodev *)adapter->rsi_dev;
 	u8 num_blks = 0;
 	u32 rcv_pkt_len = 0;
 	int status = 0;
+	u8 value = 0;
+	u8 protocol = 0, unaggr_pkt = 0;
+	struct sk_buff *skb;
+
+	if (dev->rx_q.num_rx_pkts >= RSI_SDIO_MAX_RX_PKTS)
+		return 0;
+
+#define COEX_PKT 0
+#define WLAN_PKT 3
+#define ZIGB_PKT 1
+#define BT_PKT   2
+	num_blks = ((adapter->interrupt_status & 1) |
+			((adapter->interrupt_status >> 4) << 1));
+
+	if (!num_blks) {
+		status = rsi_sdio_read_register(adapter,
+						SDIO_RX_NUM_BLOCKS_REG,
+						&value);
+		if (status) {
+			rsi_dbg(ERR_ZONE,
+				"%s: Failed to read pkt length from the card:\n",
+				__func__);
+			return status;
+		}
 
-	status = rsi_sdio_read_register(adapter,
-					SDIO_RX_NUM_BLOCKS_REG,
-					&num_blks);
+		protocol = value >> 5;
+		num_blks = value & 0x1f;
+	} else {
+		protocol = WLAN_PKT;
+	}
 
-	if (status) {
-		rsi_dbg(ERR_ZONE,
-			"%s: Failed to read pkt length from the card:\n",
-			__func__);
-		return status;
+	if (dev->write_fail == 2) {
+		rsi_sdio_ack_intr(common->priv, (1 << MSDU_PKT_PENDING));
 	}
-	rcv_pkt_len = (num_blks * 256);
+	if (unlikely(!num_blks)) {
+		dev->write_fail = 2;
+		return -1;
+	}
+
+	if (protocol == BT_PKT || protocol == ZIGB_PKT)  //unaggr_pkt FIXME
+		unaggr_pkt = 1;
 
-	common->rx_data_pkt = kmalloc(rcv_pkt_len, GFP_KERNEL);
-	if (!common->rx_data_pkt) {
-		rsi_dbg(ERR_ZONE, "%s: Failed in memory allocation\n",
+	rcv_pkt_len = (num_blks * 256);
+	
+	skb = dev_alloc_skb(rcv_pkt_len);
+	if (!skb) {
+		rsi_dbg(ERR_ZONE, "%s: Failed to allocate rx packet\n",
 			__func__);
 		return -ENOMEM;
 	}
+	skb_put(skb, rcv_pkt_len);
 
-	status = rsi_sdio_host_intf_read_pkt(adapter,
-					     common->rx_data_pkt,
-					     rcv_pkt_len);
+	status = rsi_sdio_host_intf_read_pkt(adapter, skb->data, skb->len);
 	if (status) {
 		rsi_dbg(ERR_ZONE, "%s: Failed to read packet from card\n",
 			__func__);
-		goto fail;
+		dev_kfree_skb(skb);
+		return status;
 	}
+	skb_queue_tail(&dev->rx_q.head, skb);
+	dev->rx_q.num_rx_pkts++;
+	rsi_set_event(&dev->rx_thread.event);
 
-	status = rsi_read_pkt(common, rcv_pkt_len);
-
-fail:
-	kfree(common->rx_data_pkt);
-	return status;
+	return 0;
 }
 
 /**
@@ -360,6 +285,22 @@ int rsi_init_sdio_slave_regs(struct rsi_hw *adapter)
 	return 0;
 }
 
+int rsi_read_intr_status_reg(struct rsi_hw *adapter)
+{
+	u8 isr_status = 0;
+	struct rsi_common *common = adapter->priv;
+	int status;
+
+	status = rsi_sdio_read_register(common->priv,
+						RSI_FN1_INT_REGISTER,
+						&isr_status);
+	isr_status &= 0xE;
+	
+	if(isr_status & BIT(MSDU_PKT_PENDING))
+		adapter->isr_pending = 1;
+	return 0;
+}
+
 /**
  * rsi_interrupt_handler() - This function read and process SDIO interrupts.
  * @adapter: Pointer to the adapter structure.
@@ -379,7 +320,7 @@ void rsi_interrupt_handler(struct rsi_hw *adapter)
 	dev->rx_info.sdio_int_counter++;
 
 	do {
-		mutex_lock(&common->tx_rxlock);
+		mutex_lock(&common->rx_lock);
 		status = rsi_sdio_read_register(common->priv,
 						RSI_FN1_INT_REGISTER,
 						&isr_status);
@@ -387,17 +328,23 @@ void rsi_interrupt_handler(struct rsi_hw *adapter)
 			rsi_dbg(ERR_ZONE,
 				"%s: Failed to Read Intr Status Register\n",
 				__func__);
-			mutex_unlock(&common->tx_rxlock);
+			mutex_unlock(&common->rx_lock);
 			return;
 		}
 
+		adapter->interrupt_status = isr_status;
+		isr_status &= 0xE;
+
 		if (isr_status == 0) {
 			rsi_set_event(&common->tx_thread.event);
 			dev->rx_info.sdio_intr_status_zero++;
-			mutex_unlock(&common->tx_rxlock);
+			mutex_unlock(&common->rx_lock);
 			return;
 		}
 
+//		adapter->interrupt_status = isr_status;
+//		isr_status &= 0xE;
+
 		rsi_dbg(ISR_ZONE, "%s: Intr_status = %x %d %d\n",
 			__func__, isr_status, (1 << MSDU_PKT_PENDING),
 			(1 << FW_ASSERT_IND));
@@ -407,18 +354,19 @@ void rsi_interrupt_handler(struct rsi_hw *adapter)
 
 			switch (isr_type) {
 			case BUFFER_AVAILABLE:
-				dev->rx_info.watch_bufferfull_count = 0;
-				dev->rx_info.buffer_full = false;
-				dev->rx_info.semi_buffer_full = false;
-				dev->rx_info.mgmt_buffer_full = false;
+				status = rsi_sdio_check_buffer_status(adapter, 0);
+				if (status < 0)
+					rsi_dbg(ERR_ZONE,
+						"%s: Failed to check buffer status\n",
+						__func__);
 				rsi_sdio_ack_intr(common->priv,
 						  (1 << PKT_BUFF_AVAILABLE));
 				rsi_set_event(&common->tx_thread.event);
 
 				rsi_dbg(ISR_ZONE,
-					"%s: ==> BUFFER_AVAILABLE <==\n",
+					"%s: Buffer full/available\n",
 					__func__);
-				dev->rx_info.buf_available_counter++;
+				dev->buff_status_updated = 1;
 				break;
 
 			case FIRMWARE_ASSERT_IND:
@@ -426,8 +374,8 @@ void rsi_interrupt_handler(struct rsi_hw *adapter)
 					"%s: ==> FIRMWARE Assert <==\n",
 					__func__);
 				status = rsi_sdio_read_register(common->priv,
-							SDIO_FW_STATUS_REG,
-							&fw_status);
+								SDIO_FW_STATUS_REG,
+								&fw_status);
 				if (status) {
 					rsi_dbg(ERR_ZONE,
 						"%s: Failed to read f/w reg\n",
@@ -435,7 +383,7 @@ void rsi_interrupt_handler(struct rsi_hw *adapter)
 				} else {
 					rsi_dbg(ERR_ZONE,
 						"%s: Firmware Status is 0x%x\n",
-						__func__ , fw_status);
+						__func__, fw_status);
 					rsi_sdio_ack_intr(common->priv,
 							  (1 << FW_ASSERT_IND));
 				}
@@ -452,7 +400,7 @@ void rsi_interrupt_handler(struct rsi_hw *adapter)
 					rsi_dbg(ERR_ZONE,
 						"%s: Failed to read pkt\n",
 						__func__);
-					mutex_unlock(&common->tx_rxlock);
+					mutex_unlock(&common->rx_lock);
 					return;
 				}
 				break;
@@ -467,34 +415,12 @@ void rsi_interrupt_handler(struct rsi_hw *adapter)
 			}
 			isr_status ^= BIT(isr_type - 1);
 		} while (isr_status);
-		mutex_unlock(&common->tx_rxlock);
+		mutex_unlock(&common->rx_lock);
 	} while (1);
 }
 
 /**
- * rsi_device_init() - This Function Initializes The HAL.
- * @common: Pointer to the driver private structure.
- *
- * Return: 0 on success, -1 on failure.
- */
-int rsi_sdio_device_init(struct rsi_common *common)
-{
-	if (rsi_load_ta_instructions(common))
-		return -1;
-
-	if (rsi_sdio_master_access_msword(common->priv, MISC_CFG_BASE_ADDR)) {
-		rsi_dbg(ERR_ZONE, "%s: Unable to set ms word reg\n",
-			__func__);
-		return -1;
-	}
-	rsi_dbg(INIT_ZONE,
-		"%s: Setting ms word to 0x41050000\n", __func__);
-
-	return 0;
-}
-
-/**
- * rsi_sdio_read_buffer_status_register() - This function is used to the read
+ * rsi_sdio_check_buffer_status() - This function is used to the read
  *					    buffer status register and set
  *					    relevant fields in
  *					    rsi_91x_sdiodev struct.
@@ -503,18 +429,24 @@ int rsi_sdio_device_init(struct rsi_common *common)
  *
  * Return: status: -1 on failure or else queue full/stop is indicated.
  */
-int rsi_sdio_read_buffer_status_register(struct rsi_hw *adapter, u8 q_num)
+int rsi_sdio_check_buffer_status(struct rsi_hw *adapter, u8 q_num)
 {
 	struct rsi_common *common = adapter->priv;
 	struct rsi_91x_sdiodev *dev =
 		(struct rsi_91x_sdiodev *)adapter->rsi_dev;
 	u8 buf_status = 0;
 	int status = 0;
+	static int counter = 4;
+
+	if (!dev->buff_status_updated && counter) {
+		counter--;
+		goto out;
+	}
 
+	dev->buff_status_updated = 0;
 	status = rsi_sdio_read_register(common->priv,
 					RSI_DEVICE_BUFFER_STATUS_REGISTER,
 					&buf_status);
-
 	if (status) {
 		rsi_dbg(ERR_ZONE,
 			"%s: Failed to read status register\n", __func__);
@@ -525,30 +457,33 @@ int rsi_sdio_read_buffer_status_register(struct rsi_hw *adapter, u8 q_num)
 		if (!dev->rx_info.mgmt_buffer_full)
 			dev->rx_info.mgmt_buf_full_counter++;
 		dev->rx_info.mgmt_buffer_full = true;
-	} else {
+	} else
 		dev->rx_info.mgmt_buffer_full = false;
-	}
 
 	if (buf_status & (BIT(PKT_BUFF_FULL))) {
 		if (!dev->rx_info.buffer_full)
 			dev->rx_info.buf_full_counter++;
 		dev->rx_info.buffer_full = true;
-	} else {
+	} else
 		dev->rx_info.buffer_full = false;
-	}
 
 	if (buf_status & (BIT(PKT_BUFF_SEMI_FULL))) {
 		if (!dev->rx_info.semi_buffer_full)
 			dev->rx_info.buf_semi_full_counter++;
 		dev->rx_info.semi_buffer_full = true;
-	} else {
+	} else
 		dev->rx_info.semi_buffer_full = false;
-	}
 
+	if (dev->rx_info.mgmt_buffer_full || dev->rx_info.buf_full_counter)
+		counter = 1;
+	else
+		counter = 4;
+
+out:
 	if ((q_num == MGMT_SOFT_Q) && (dev->rx_info.mgmt_buffer_full))
 		return QUEUE_FULL;
 
-	if (dev->rx_info.buffer_full)
+	if ((q_num < MGMT_SOFT_Q) && (dev->rx_info.buffer_full))
 		return QUEUE_FULL;
 
 	return QUEUE_NOT_FULL;
diff --git a/drivers/net/wireless/rsi/rsi_91x_usb.c b/drivers/net/wireless/rsi/rsi_91x_usb.c
index ef5d394..d96727c 100644
--- a/drivers/net/wireless/rsi/rsi_91x_usb.c
+++ b/drivers/net/wireless/rsi/rsi_91x_usb.c
@@ -1,25 +1,50 @@
-/**
- * Copyright (c) 2014 Redpine Signals Inc.
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
  *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
  *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
  *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include <linux/module.h>
+#include <linux/usb.h>
 #include "rsi_usb.h"
+#include "rsi_hal.h"
+
+static struct rsi_host_intf_ops usb_host_intf_ops = {
+	.write_pkt		= rsi_usb_host_intf_write_pkt,
+	.master_reg_read	= rsi_usb_master_reg_read,
+	.master_reg_write	= rsi_usb_master_reg_write,
+	.read_reg_multiple	= rsi_usb_read_register_multiple,
+	.write_reg_multiple	= rsi_usb_write_register_multiple,
+	.load_data_master_write	= rsi_usb_load_data_master_write,
+	.check_hw_queue_status	= rsi_usb_check_queue_status,
+};
 
 /**
- * rsi_usb_card_write() - This function writes to the USB Card.
+ * rsi_usb_card_write() - This function writes data to the USB Card.
  * @adapter: Pointer to the adapter structure.
  * @buf: Pointer to the buffer from where the data has to be taken.
  * @len: Length to be written.
@@ -28,27 +53,41 @@
  * Return: status: 0 on success, a negative error code on failure.
  */
 static int rsi_usb_card_write(struct rsi_hw *adapter,
-			      void *buf,
+			      u8 *buf,
 			      u16 len,
-			      u8 endpoint)
+			      u32 endpoint)
 {
 	struct rsi_91x_usbdev *dev = (struct rsi_91x_usbdev *)adapter->rsi_dev;
-	int status;
-	s32 transfer;
+	int status = 0;
+	u8 *seg = dev->tx_buffer;
+	int transfer = 0;
+	int ep = dev->bulkout_endpoint_addr[endpoint - 1];
+
+	if ((endpoint == 2) &&
+	    (adapter->priv->zb_fsm_state == ZB_DEVICE_READY)) {
+		memcpy(seg, buf, len);
+	} else {
+		memset(seg, 0, len + 128);
+		memcpy(seg + 128, buf, len);
+		len += 128;
+	}
+	transfer = len;
 
 	status = usb_bulk_msg(dev->usbdev,
-			      usb_sndbulkpipe(dev->usbdev,
-			      dev->bulkout_endpoint_addr[endpoint - 1]),
-			      buf,
-			      len,
+			      usb_sndbulkpipe(dev->usbdev, ep),
+			      (void *)seg,
+			      (int)len,
 			      &transfer,
 			      HZ * 5);
-
 	if (status < 0) {
 		rsi_dbg(ERR_ZONE,
-			"Card write failed with error code :%10d\n", status);
+			"Card write failed with error code :%d\n", status);
 		dev->write_fail = 1;
+		goto fail;
 	}
+	rsi_dbg(MGMT_TX_ZONE, "%s: Sent Message successfully\n", __func__);
+
+fail:
 	return status;
 }
 
@@ -63,84 +102,28 @@ static int rsi_usb_card_write(struct rsi_hw *adapter,
  * Return: 0 on success, a negative error code on failure.
  */
 static int rsi_write_multiple(struct rsi_hw *adapter,
-			      u8 endpoint,
+			      u32 addr,
 			      u8 *data,
 			      u32 count)
 {
-	struct rsi_91x_usbdev *dev = (struct rsi_91x_usbdev *)adapter->rsi_dev;
-	u8 *seg = dev->tx_buffer;
-
-	if (dev->write_fail)
-		return 0;
-
-	if (endpoint == MGMT_EP) {
-		memset(seg, 0, RSI_USB_TX_HEAD_ROOM);
-		memcpy(seg + RSI_USB_TX_HEAD_ROOM, data, count);
-	} else {
-		seg = ((u8 *)data - RSI_USB_TX_HEAD_ROOM);
-	}
-
-	return rsi_usb_card_write(adapter,
-				  seg,
-				  count + RSI_USB_TX_HEAD_ROOM,
-				  endpoint);
-}
-
-/**
- * rsi_find_bulk_in_and_out_endpoints() - This function initializes the bulk
- *					  endpoints to the device.
- * @interface: Pointer to the USB interface structure.
- * @adapter: Pointer to the adapter structure.
- *
- * Return: ret_val: 0 on success, -ENOMEM on failure.
- */
-static int rsi_find_bulk_in_and_out_endpoints(struct usb_interface *interface,
-					      struct rsi_hw *adapter)
-{
-	struct rsi_91x_usbdev *dev = (struct rsi_91x_usbdev *)adapter->rsi_dev;
-	struct usb_host_interface *iface_desc;
-	struct usb_endpoint_descriptor *endpoint;
-	__le16 buffer_size;
-	int ii, bep_found = 0;
-
-	iface_desc = &(interface->altsetting[0]);
-
-	for (ii = 0; ii < iface_desc->desc.bNumEndpoints; ++ii) {
-		endpoint = &(iface_desc->endpoint[ii].desc);
-
-		if ((!(dev->bulkin_endpoint_addr)) &&
-		    (endpoint->bEndpointAddress & USB_DIR_IN) &&
-		    ((endpoint->bmAttributes &
-		    USB_ENDPOINT_XFERTYPE_MASK) ==
-		    USB_ENDPOINT_XFER_BULK)) {
-			buffer_size = endpoint->wMaxPacketSize;
-			dev->bulkin_size = buffer_size;
-			dev->bulkin_endpoint_addr =
-				endpoint->bEndpointAddress;
-		}
+	struct rsi_91x_usbdev *dev =
+		(struct rsi_91x_usbdev *)adapter->rsi_dev;
 
-		if (!dev->bulkout_endpoint_addr[bep_found] &&
-		    !(endpoint->bEndpointAddress & USB_DIR_IN) &&
-		    ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
-		      USB_ENDPOINT_XFER_BULK)) {
-			dev->bulkout_endpoint_addr[bep_found] =
-				endpoint->bEndpointAddress;
-			buffer_size = endpoint->wMaxPacketSize;
-			dev->bulkout_size[bep_found] = buffer_size;
-			bep_found++;
-		}
-
-		if (bep_found >= MAX_BULK_EP)
-			break;
+	if (!adapter || addr == 0) {
+		rsi_dbg(INFO_ZONE,
+			"%s: Unable to write to card\n", __func__);
+		return -1;
 	}
 
-	if (!(dev->bulkin_endpoint_addr) &&
-	    (dev->bulkout_endpoint_addr[0]))
-		return -EINVAL;
+	if (dev->write_fail)
+		return -1;
 
-	return 0;
+	return rsi_usb_card_write(adapter, data, count, addr);
 }
 
+#define RSI_USB_REQ_OUT	(USB_TYPE_VENDOR | USB_DIR_OUT | USB_RECIP_DEVICE)
+#define RSI_USB_REQ_IN	(USB_TYPE_VENDOR | USB_DIR_IN | USB_RECIP_DEVICE)
+
 /* rsi_usb_reg_read() - This function reads data from given register address.
  * @usbdev: Pointer to the usb_device structure.
  * @reg: Address of the register to be read.
@@ -151,24 +134,29 @@ static int rsi_find_bulk_in_and_out_endpoints(struct usb_interface *interface,
  */
 static int rsi_usb_reg_read(struct usb_device *usbdev,
 			    u32 reg,
-			    u16 *value,
+			    u32 *value,
 			    u16 len)
 {
 	u8 *buf;
-	int status = -ENOMEM;
+	int status = 0;
+	u16 reg_value;
+	u16 index;
 
-	buf  = kmalloc(0x04, GFP_KERNEL);
+	buf = kmalloc(4, GFP_KERNEL);
 	if (!buf)
-		return status;
-
+		return -ENOMEM;
+	len = 2;
+	reg_value = cpu_to_le16(((u16 *)&reg)[1] & 0xffff);
+	index = cpu_to_le16(((u16 *)&reg)[0] & 0xffff);
 	status = usb_control_msg(usbdev,
 				 usb_rcvctrlpipe(usbdev, 0),
 				 USB_VENDOR_REGISTER_READ,
-				 USB_TYPE_VENDOR,
-				 ((reg & 0xffff0000) >> 16), (reg & 0xffff),
+				 RSI_USB_REQ_IN,
+				 reg_value,
+				 index,
 				 (void *)buf,
 				 len,
-				 HZ * 5);
+				 USB_CTRL_GET_TIMEOUT);
 
 	*value = (buf[0] | (buf[1] << 8));
 	if (status < 0) {
@@ -192,31 +180,33 @@ static int rsi_usb_reg_read(struct usb_device *usbdev,
  * Return: status: 0 on success, a negative error code on failure.
  */
 static int rsi_usb_reg_write(struct usb_device *usbdev,
-			     u32 reg,
-			     u16 value,
+			     unsigned long reg,
+			     unsigned long value,
 			     u16 len)
 {
 	u8 *usb_reg_buf;
-	int status = -ENOMEM;
+	int status = 0;
+	u16 reg_value, index;
 
-	usb_reg_buf  = kmalloc(0x04, GFP_KERNEL);
+	usb_reg_buf = kmalloc(4, GFP_KERNEL);
 	if (!usb_reg_buf)
-		return status;
-
+		return -ENOMEM;
 	usb_reg_buf[0] = (value & 0x00ff);
 	usb_reg_buf[1] = (value & 0xff00) >> 8;
-	usb_reg_buf[2] = 0x0;
-	usb_reg_buf[3] = 0x0;
+	usb_reg_buf[2] = (value & 0x00ff0000) >> 16;
+	usb_reg_buf[3] = (value & 0xff000000) >> 24;
 
+	reg_value = ((u16 *)&reg)[1] & 0xffff;
+	index = ((u16 *)&reg)[0] & 0xffff;
 	status = usb_control_msg(usbdev,
 				 usb_sndctrlpipe(usbdev, 0),
 				 USB_VENDOR_REGISTER_WRITE,
-				 USB_TYPE_VENDOR,
-				 ((reg & 0xffff0000) >> 16),
-				 (reg & 0xffff),
+				 RSI_USB_REQ_OUT,
+				 reg_value,
+				 index,
 				 (void *)usb_reg_buf,
 				 len,
-				 HZ * 5);
+				 USB_CTRL_SET_TIMEOUT);
 	if (status < 0) {
 		rsi_dbg(ERR_ZONE,
 			"%s: Reg write failed with error code :%d\n",
@@ -228,100 +218,191 @@ static int rsi_usb_reg_write(struct usb_device *usbdev,
 }
 
 /**
- * rsi_rx_done_handler() - This function is called when a packet is received
- *			   from USB stack. This is callback to recieve done.
- * @urb: Received URB.
+ * rsi_usb_read_register_multiple() - This function reads multiple
+ *					bytes of data from the address.
+ * @adapter:	Pointer to the adapter structure.
+ * @addr:	Address of the register.
+ * @data:	Read data.
+ * @len:	Number of bytes to read.
  *
- * Return: None.
+ * Return: status: 0 on success, a negative error code on failure.
  */
-static void rsi_rx_done_handler(struct urb *urb)
+int rsi_usb_read_register_multiple(struct rsi_hw *adapter,
+				   u32 addr,
+				   u8 *data,
+				   u16 count)
 {
-	struct rsi_hw *adapter = urb->context;
 	struct rsi_91x_usbdev *dev = (struct rsi_91x_usbdev *)adapter->rsi_dev;
+	u8 *buf;
+	u16 transfer;
+	int status = 0;
+	u16 reg_val, index;
 
-	if (urb->status)
-		return;
-
-	rsi_set_event(&dev->rx_thread.event);
-}
-
-/**
- * rsi_rx_urb_submit() - This function submits the given URB to the USB stack.
- * @adapter: Pointer to the adapter structure.
- *
- * Return: 0 on success, a negative error code on failure.
- */
-static int rsi_rx_urb_submit(struct rsi_hw *adapter)
-{
-	struct rsi_91x_usbdev *dev = (struct rsi_91x_usbdev *)adapter->rsi_dev;
-	struct urb *urb = dev->rx_usb_urb[0];
-	int status;
+	if (addr == 0)
+		return -EINVAL;
 
-	usb_fill_bulk_urb(urb,
-			  dev->usbdev,
-			  usb_rcvbulkpipe(dev->usbdev,
-				dev->bulkin_endpoint_addr),
-			  urb->transfer_buffer,
-			  3000,
-			  rsi_rx_done_handler,
-			  adapter);
+	buf = kzalloc(4096, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
 
-	status = usb_submit_urb(urb, GFP_KERNEL);
-	if (status)
-		rsi_dbg(ERR_ZONE, "%s: Failed in urb submission\n", __func__);
+	reg_val = ((u16 *)&addr)[1] & 0xffff;
+	index = ((u16 *)&addr)[0] & 0xffff;
+	while (count) {
+		transfer = min_t(u16, count, 4096);
+		status = usb_control_msg(dev->usbdev,
+					 usb_rcvctrlpipe(dev->usbdev, 0),
+					 USB_VENDOR_REGISTER_READ,
+					 RSI_USB_REQ_IN,
+					 reg_val,
+					 index,
+					 (void *)buf,
+					 transfer,
+					 USB_CTRL_GET_TIMEOUT);
+		if (status < 0) {
+			rsi_dbg(ERR_ZONE,
+				"Reg read failed with error code :%d\n",
+				 status);
+			kfree(buf);
+			return status;
 
+		} else {
+			memcpy(data, buf, transfer);
+			count -= transfer;
+			data += transfer;
+			addr += transfer;
+		}
+	}
+	kfree(buf);
 	return status;
 }
 
 /**
  * rsi_usb_write_register_multiple() - This function writes multiple bytes of
- *				       information to multiple registers.
- * @adapter: Pointer to the adapter structure.
- * @addr: Address of the register.
- * @data: Pointer to the data that has to be written.
- * @count: Number of multiple bytes to be written on to the registers.
+ *				       information to the given address.
+ * @adapter:	Pointer to the adapter structure.
+ * @addr:	Address of the register.
+ * @data:	Pointer to the data that has to be written.
+ * @count:	Number of multiple bytes to be written on to the registers.
  *
  * Return: status: 0 on success, a negative error code on failure.
  */
 int rsi_usb_write_register_multiple(struct rsi_hw *adapter,
 				    u32 addr,
 				    u8 *data,
-				    u32 count)
+				    u16 count)
 {
-	struct rsi_91x_usbdev *dev = (struct rsi_91x_usbdev *)adapter->rsi_dev;
+	struct rsi_91x_usbdev *dev =
+		(struct rsi_91x_usbdev *)adapter->rsi_dev;
 	u8 *buf;
-	u8 transfer;
+	u16 transfer;
 	int status = 0;
+	u16 reg_val, index;
 
 	buf = kzalloc(4096, GFP_KERNEL);
 	if (!buf)
 		return -ENOMEM;
 
+	reg_val = ((u16 *)&addr)[1] & 0xffff;
+	index = ((u16 *)&addr)[0] & 0xffff;
 	while (count) {
-		transfer = (u8)(min_t(u32, count, 4096));
+		transfer = min_t(u16, count, 4096);
 		memcpy(buf, data, transfer);
 		status = usb_control_msg(dev->usbdev,
 					 usb_sndctrlpipe(dev->usbdev, 0),
 					 USB_VENDOR_REGISTER_WRITE,
-					 USB_TYPE_VENDOR,
-					 ((addr & 0xffff0000) >> 16),
-					 (addr & 0xffff),
+					 RSI_USB_REQ_OUT,
+					 reg_val,
+					 index,
 					 (void *)buf,
 					 transfer,
-					 HZ * 5);
+					 USB_CTRL_SET_TIMEOUT);
 		if (status < 0) {
 			rsi_dbg(ERR_ZONE,
 				"Reg write failed with error code :%d\n",
 				status);
-		} else {
-			count -= transfer;
-			data += transfer;
-			addr += transfer;
+			kfree(buf);
+			return status;
 		}
+		count -= transfer;
+		data += transfer;
+		addr += transfer;
 	}
 
 	kfree(buf);
-	return 0;
+	return status;
+}
+
+/**
+ * rsi_rx_done_handler() - This function is called when a packet is received
+ *			   from USB stack. This is callback to receive done.
+ * @urb: Received URB.
+ *
+ * Return: None.
+ */
+static void rsi_rx_done_handler(struct urb *urb)
+{
+	struct rx_usb_ctrl_block *rx_cb = urb->context;
+	struct rsi_91x_usbdev *dev = (struct rsi_91x_usbdev *)rx_cb->data;
+
+	if (urb->status)
+		return;
+
+	if (urb->actual_length <= 0 || urb->actual_length > rx_cb->rx_skb->len) {
+		rsi_dbg(INFO_ZONE, "%s: Invalid packet length = %d\n", __func__, urb->actual_length);
+		return;
+	}
+	
+	skb_trim(rx_cb->rx_skb, urb->actual_length);
+	skb_queue_tail(&dev->rx_q[rx_cb->ep_num - 1], rx_cb->rx_skb);
+
+	rsi_set_event(&dev->rx_thread.event);
+
+	if (rsi_rx_urb_submit(dev->priv, rx_cb->ep_num))
+		rsi_dbg(ERR_ZONE, "%s: Failed in urb submission", __func__);
+
+}
+
+/**
+ * rsi_rx_urb_submit() - This function submits the given URB to the USB stack.
+ * @adapter: Pointer to the adapter structure.
+ *
+ * Return: 0 on success, a negative error code on failure.
+ */
+int rsi_rx_urb_submit(struct rsi_hw *adapter, u8 ep_num)
+{
+	struct rsi_91x_usbdev *dev = (struct rsi_91x_usbdev *)adapter->rsi_dev;
+	struct rx_usb_ctrl_block *rx_cb = &dev->rx_cb[ep_num - 1];
+	struct urb *urb = rx_cb->rx_urb;
+	int status;
+	struct sk_buff *skb;
+	u8 dword_align_bytes;
+
+	skb = dev_alloc_skb(3000);
+	if (!skb)
+		return -ENOMEM;
+	skb_reserve(skb, 64); /* For dword alignment */
+	skb_put(skb, 3000 - 64);
+	dword_align_bytes = (unsigned long)skb->data & 0x3f;
+	if (dword_align_bytes)
+		skb_push(skb, dword_align_bytes);
+
+	urb->transfer_buffer = skb->data;
+	rx_cb->rx_skb = skb;
+
+	usb_fill_bulk_urb(urb,
+			dev->usbdev,
+			usb_rcvbulkpipe(dev->usbdev,
+					dev->bulkin_endpoint_addr[ep_num - 1]),
+			urb->transfer_buffer,
+			skb->len,
+			rsi_rx_done_handler,
+			rx_cb);
+
+	status = usb_submit_urb(urb, GFP_KERNEL);
+	if (status)
+		rsi_dbg(ERR_ZONE, "%s: Failed in urb submission\n", __func__);
+
+	return status;
 }
 
 /**
@@ -333,21 +414,142 @@ int rsi_usb_write_register_multiple(struct rsi_hw *adapter,
  *
  * Return: 0 on success, a negative error code on failure.
  */
-static int rsi_usb_host_intf_write_pkt(struct rsi_hw *adapter,
-				       u8 *pkt,
-				       u32 len)
+int rsi_usb_host_intf_write_pkt(struct rsi_hw *adapter,
+				u8 *pkt,
+				u32 len)
 {
-	u32 queueno = ((pkt[1] >> 4) & 0xf);
+	u32 queueno = ((pkt[1] >> 4) & 0x7);
 	u8 endpoint;
 
-	endpoint = ((queueno == RSI_WIFI_MGMT_Q) ? MGMT_EP : DATA_EP);
+	rsi_dbg(DATA_TX_ZONE, "%s: queueno=%d\n", __func__, queueno);
+	endpoint = ((queueno == RSI_WIFI_MGMT_Q || queueno == RSI_COEX_Q ||
+		     queueno == RSI_WIFI_DATA_Q) ?
+		    MGMT_EP : DATA_EP);
 
 	return rsi_write_multiple(adapter,
 				  endpoint,
-				  (u8 *)pkt,
+				  pkt,
 				  len);
 }
 
+int rsi_usb_master_reg_read(struct rsi_hw *adapter,
+			    u32 reg,
+			    u32 *value,
+			    u16 len)
+{
+	struct usb_device *usbdev =
+		((struct rsi_91x_usbdev *)adapter->rsi_dev)->usbdev;
+
+	return rsi_usb_reg_read(usbdev, reg, value, len);
+}
+
+int rsi_usb_master_reg_write(struct rsi_hw *adapter,
+			     unsigned long reg,
+			     unsigned long value,
+			     u16 len)
+{
+	struct usb_device *usbdev =
+		((struct rsi_91x_usbdev *)adapter->rsi_dev)->usbdev;
+
+	return rsi_usb_reg_write(usbdev, reg, value, len);
+}
+
+int rsi_usb_load_data_master_write(struct rsi_hw *adapter,
+				   u32 base_address,
+				   u32 instructions_sz,
+				   u16 block_size,
+				   u8 *ta_firmware)
+{
+	u16 num_blocks;
+	u32 cur_indx, ii;
+	u8 temp_buf[256];
+
+	num_blocks = instructions_sz / block_size;
+	rsi_dbg(INFO_ZONE, "num_blocks: %d\n", num_blocks);
+
+	for (cur_indx = 0, ii = 0;
+	     ii < num_blocks;
+	     ii++, cur_indx += block_size) {
+		memset(temp_buf, 0, block_size);
+		memcpy(temp_buf, ta_firmware + cur_indx, block_size);
+		if ((rsi_usb_write_register_multiple(adapter,
+						     base_address,
+						     (u8 *)(temp_buf),
+						     block_size)) < 0)
+			return -EIO;
+
+		rsi_dbg(INFO_ZONE, "%s: loading block: %d\n", __func__, ii);
+		base_address += block_size;
+	}
+
+	if (instructions_sz % block_size) {
+		memset(temp_buf, 0, block_size);
+		memcpy(temp_buf, ta_firmware + cur_indx,
+		       instructions_sz % block_size);
+		if ((rsi_usb_write_register_multiple(adapter,
+					     base_address,
+					     (u8 *)temp_buf,
+					     instructions_sz % block_size)) < 0)
+			return -EIO;
+		rsi_dbg(INFO_ZONE,
+			"Written Last Block in Address 0x%x Successfully\n",
+			cur_indx);
+	}
+	return 0;
+}
+
+int rsi_usb_check_queue_status(struct rsi_hw *adapter, u8 q_num)
+{
+	return QUEUE_NOT_FULL;
+
+#if 0
+	struct rsi_91x_usbdev *dev = (struct rsi_91x_usbdev *)adapter->rsi_dev;
+	int status;
+	u32 buf_status = 0;
+
+	if (adapter->priv->fsm_state != FSM_MAC_INIT_DONE)
+		return QUEUE_NOT_FULL;
+
+	status = rsi_usb_reg_read(dev->usbdev, adapter->usb_buffer_status_reg,
+				  &buf_status, 2);
+	if (status < 0)
+		return status;
+
+	printk("buffer_status = %x\n", buf_status);
+	if (buf_status & (BIT(PKT_MGMT_BUFF_FULL))) {
+		if (!dev->rx_info.mgmt_buffer_full)
+			dev->rx_info.mgmt_buf_full_counter++;
+		dev->rx_info.mgmt_buffer_full = true;
+	} else {
+		dev->rx_info.mgmt_buffer_full = false;
+	}
+
+	if (buf_status & (BIT(PKT_BUFF_FULL))) {
+		if (!dev->rx_info.buffer_full)
+			dev->rx_info.buf_full_counter++;
+		dev->rx_info.buffer_full = true;
+	} else {
+		dev->rx_info.buffer_full = false;
+	}
+
+	if (buf_status & (BIT(PKT_BUFF_SEMI_FULL))) {
+		if (!dev->rx_info.semi_buffer_full)
+			dev->rx_info.buf_semi_full_counter++;
+		dev->rx_info.semi_buffer_full = true;
+	} else {
+		dev->rx_info.semi_buffer_full = false;
+	}
+
+	if ((q_num == MGMT_SOFT_Q) && (dev->rx_info.mgmt_buffer_full))
+		return QUEUE_FULL;
+
+	if ((q_num < MGMT_SOFT_Q) && (dev->rx_info.buffer_full))
+		return QUEUE_FULL;
+
+	return QUEUE_NOT_FULL;
+#endif
+}
+
 /**
  * rsi_deinit_usb_interface() - This function deinitializes the usb interface.
  * @adapter: Pointer to the adapter structure.
@@ -358,10 +560,105 @@ static void rsi_deinit_usb_interface(struct rsi_hw *adapter)
 {
 	struct rsi_91x_usbdev *dev = (struct rsi_91x_usbdev *)adapter->rsi_dev;
 
+	rsi_dbg(INFO_ZONE, "Deinitializing USB interface...\n");
+
 	rsi_kill_thread(&dev->rx_thread);
-	usb_free_urb(dev->rx_usb_urb[0]);
-	kfree(adapter->priv->rx_data_pkt);
-	kfree(dev->tx_buffer);
+	//kfree(dev->rx_cb[0].rx_buffer);
+	skb_queue_purge(&dev->rx_q[0]);
+	usb_free_urb(dev->rx_cb[0].rx_urb);
+#if defined (CONFIG_RSI_BT_ALONE) || defined(CONFIG_RSI_COEX)	
+	//kfree(dev->rx_cb[1].rx_buffer);
+	skb_queue_purge(&dev->rx_q[1]);
+	usb_free_urb(dev->rx_cb[1].rx_urb);
+#endif
+	kfree(dev->saved_tx_buffer);
+}
+
+/**
+ * rsi_find_bulk_in_and_out_endpoints() - This function initializes the bulk
+ *					  endpoints to the device.
+ * @interface: Pointer to the USB interface structure.
+ * @adapter: Pointer to the adapter structure.
+ *
+ * Return: ret_val: 0 on success, -ENOMEM on failure.
+ */
+static int rsi_find_bulk_in_and_out_endpoints(struct usb_interface *interface,
+					      struct rsi_hw *adapter)
+{
+	struct rsi_91x_usbdev *dev = (struct rsi_91x_usbdev *)adapter->rsi_dev;
+	struct usb_host_interface *iface_desc;
+	struct usb_endpoint_descriptor *endpoint;
+	__le16 buffer_size;
+	int ii, bin_found = 0, bout_found = 0;
+
+	iface_desc = &interface->altsetting[0];
+
+	for (ii = 0; ii < iface_desc->desc.bNumEndpoints; ++ii) {
+		endpoint = &(iface_desc->endpoint[ii].desc);
+
+		if ((!dev->bulkin_endpoint_addr[bin_found]) &&
+		    (endpoint->bEndpointAddress & USB_DIR_IN) &&
+		    ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
+		     USB_ENDPOINT_XFER_BULK)) {
+			buffer_size = endpoint->wMaxPacketSize;
+			dev->bulkin_size[bin_found] = buffer_size;
+			dev->bulkin_endpoint_addr[bin_found] =
+					endpoint->bEndpointAddress;
+			printk("bulkin addr[%d] = %d\n", bin_found, dev->bulkin_endpoint_addr[bin_found]);
+			bin_found++;
+		}
+
+		if (!dev->bulkout_endpoint_addr[bout_found] &&
+		    !(endpoint->bEndpointAddress & USB_DIR_IN) &&
+		    ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
+		     USB_ENDPOINT_XFER_BULK)) {
+			printk("%s:%d\n", __func__, __LINE__);
+			buffer_size = endpoint->wMaxPacketSize;
+			dev->bulkout_endpoint_addr[bout_found] =
+					endpoint->bEndpointAddress;
+			buffer_size = endpoint->wMaxPacketSize;
+			dev->bulkout_size[bout_found] = buffer_size;
+			printk("bulkout addr[%d] = %d\n", bout_found, dev->bulkout_endpoint_addr[bout_found]);
+			bout_found++;
+		}
+
+		if ((bin_found >= MAX_BULK_EP) || (bout_found >= MAX_BULK_EP))
+			break;
+	}
+
+	if (!(dev->bulkin_endpoint_addr[0]) &&
+	    (dev->bulkout_endpoint_addr[0]))
+		return -EINVAL;
+
+	return 0;
+}
+
+static int rsi_usb_init_rx(struct rsi_hw *adapter)
+{
+	struct rsi_91x_usbdev *dev = (struct rsi_91x_usbdev *)adapter->rsi_dev;
+	struct rx_usb_ctrl_block *rx_cb;
+	u8 idx;
+
+	for (idx = 0; idx < MAX_RX_URBS; idx++) {
+		rx_cb = &dev->rx_cb[idx];
+
+
+		rx_cb->rx_urb = usb_alloc_urb(0, GFP_KERNEL);
+		if (!rx_cb->rx_urb) {
+			rsi_dbg(ERR_ZONE, "Failed alloc rx urb[%d]\n", idx);
+			goto err;
+		}
+		rx_cb->ep_num = idx + 1;
+		rx_cb->data = (void *)dev;
+
+		skb_queue_head_init(&dev->rx_q[idx]);
+	}
+	return 0;
+
+err:
+	kfree(rx_cb[0].rx_urb);
+	kfree(rx_cb[1].rx_urb);
+	return -1;
 }
 
 /**
@@ -376,7 +673,8 @@ static int rsi_init_usb_interface(struct rsi_hw *adapter,
 {
 	struct rsi_91x_usbdev *rsi_dev;
 	struct rsi_common *common = adapter->priv;
-	int status;
+	int status = 0;
+	u8 dword_align_bytes = 0;
 
 	rsi_dev = kzalloc(sizeof(*rsi_dev), GFP_KERNEL);
 	if (!rsi_dev)
@@ -384,6 +682,7 @@ static int rsi_init_usb_interface(struct rsi_hw *adapter,
 
 	adapter->rsi_dev = rsi_dev;
 	rsi_dev->usbdev = interface_to_usbdev(pfunction);
+	rsi_dev->priv = (void *)adapter;
 
 	if (rsi_find_bulk_in_and_out_endpoints(pfunction, adapter))
 		return -EINVAL;
@@ -391,57 +690,188 @@ static int rsi_init_usb_interface(struct rsi_hw *adapter,
 	adapter->device = &pfunction->dev;
 	usb_set_intfdata(pfunction, adapter);
 
-	common->rx_data_pkt = kmalloc(2048, GFP_KERNEL);
-	if (!common->rx_data_pkt) {
-		rsi_dbg(ERR_ZONE, "%s: Failed to allocate memory\n",
-			__func__);
-		return -ENOMEM;
-	}
-
 	rsi_dev->tx_buffer = kmalloc(2048, GFP_KERNEL);
 	if (!rsi_dev->tx_buffer) {
 		status = -ENOMEM;
-		goto fail_tx;
+		goto fail_1;
 	}
-	rsi_dev->rx_usb_urb[0] = usb_alloc_urb(0, GFP_KERNEL);
-	if (!rsi_dev->rx_usb_urb[0]) {
-		status = -ENOMEM;
-		goto fail_rx;
+	rsi_dev->saved_tx_buffer = rsi_dev->tx_buffer;
+	dword_align_bytes = (unsigned long)rsi_dev->tx_buffer & 0x3f;
+	if (dword_align_bytes)
+		rsi_dev->tx_buffer = rsi_dev->tx_buffer +
+				     (64 - dword_align_bytes);
+
+	/* Initialize RX handle */
+	if (rsi_usb_init_rx(adapter)) {
+		rsi_dbg(ERR_ZONE, "Failed to init RX handle\n");
+		goto fail_1;
 	}
-	rsi_dev->rx_usb_urb[0]->transfer_buffer = adapter->priv->rx_data_pkt;
+
 	rsi_dev->tx_blk_size = 252;
+	adapter->tx_blk_size = rsi_dev->tx_blk_size;
 
 	/* Initializing function callbacks */
 	adapter->rx_urb_submit = rsi_rx_urb_submit;
-	adapter->host_intf_write_pkt = rsi_usb_host_intf_write_pkt;
 	adapter->check_hw_queue_status = rsi_usb_check_queue_status;
 	adapter->determine_event_timeout = rsi_usb_event_timeout;
+	adapter->host_intf_ops = &usb_host_intf_ops;
 
 	rsi_init_event(&rsi_dev->rx_thread.event);
 	status = rsi_create_kthread(common, &rsi_dev->rx_thread,
-				    rsi_usb_rx_thread, "RX-Thread");
+				    rsi_usb_rx_thread, "USB-RX-Thread");
 	if (status) {
 		rsi_dbg(ERR_ZONE, "%s: Unable to init rx thrd\n", __func__);
-		goto fail_thread;
+		goto fail_2;
 	}
 
 #ifdef CONFIG_RSI_DEBUGFS
-	/* In USB, one less than the MAX_DEBUGFS_ENTRIES entries is required */
-	adapter->num_debugfs_entries = (MAX_DEBUGFS_ENTRIES - 1);
+	/* In USB, one less than the MAX_DEBUGFS_ENTRIES entries
+	 * is required */
+	adapter->num_debugfs_entries = MAX_DEBUGFS_ENTRIES - 1;
 #endif
 
 	rsi_dbg(INIT_ZONE, "%s: Enabled the interface\n", __func__);
 	return 0;
 
-fail_thread:
-	usb_free_urb(rsi_dev->rx_usb_urb[0]);
-fail_rx:
-	kfree(rsi_dev->tx_buffer);
-fail_tx:
-	kfree(common->rx_data_pkt);
+fail_2:
+	kfree(rsi_dev->saved_tx_buffer);
+	rsi_kill_thread(&rsi_dev->rx_thread);
+fail_1:
 	return status;
 }
 
+static int rsi_usb_gspi_init(struct rsi_hw *adapter)
+{
+	u32 gspi_ctrl_reg0_val;
+
+	/**
+	 * Programming gspi frequency = soc_frequency / 2
+	 * Warning : ULP seemed to be not working
+	 * well at high frequencies. Modify accordingly
+	 */
+	gspi_ctrl_reg0_val = 0x4;
+	gspi_ctrl_reg0_val |= 0x10;
+	gspi_ctrl_reg0_val |= 0x40;
+	gspi_ctrl_reg0_val |= 0x100;
+	gspi_ctrl_reg0_val |= 0x000;
+	gspi_ctrl_reg0_val |= 0x000;
+
+	/* Initializing GSPI for ULP read/writes */
+	return rsi_usb_master_reg_write(adapter, GSPI_CTRL_REG0,
+			gspi_ctrl_reg0_val, 2);
+}
+
+static int usb_ulp_read_write(struct rsi_hw *adapter,
+			      u16 addr,
+			      u16 *data,
+			      u16 len_in_bits)
+{
+	if ((rsi_usb_master_reg_write(adapter,
+				      GSPI_DATA_REG1,
+				      ((addr << 6) | (data[1] & 0x3f)),
+				      2) < 0))
+		goto fail;
+
+	if ((rsi_usb_master_reg_write(adapter,
+				      GSPI_DATA_REG0,
+				      (*(u16 *)&data[0]),
+				      2)) < 0)
+		goto fail;
+
+	if ((rsi_usb_gspi_init(adapter)) < 0)
+		goto fail;
+
+	if ((rsi_usb_master_reg_write(adapter, GSPI_CTRL_REG1,
+				      ((len_in_bits - 1) | GSPI_TRIG),
+				      2)) < 0)
+		goto fail;
+
+	msleep(10);
+
+	return 0;
+
+fail:
+	return -1;
+}
+
+static int rsi_reset_card(struct rsi_hw *adapter)
+{
+	u16 temp[4] = {0};
+
+	rsi_dbg(INFO_ZONE, "Resetting Card...\n");
+
+	if (rsi_usb_master_reg_write(adapter, SWBL_REGOUT,
+				     FW_WDT_DISABLE_REQ, 2) < 0) {
+		rsi_dbg(ERR_ZONE, "%s: FW WDT Disable failed...\n",
+			__func__);
+		goto fail;
+	}
+
+#define TA_HOLD_REG 0x22000844
+	rsi_usb_master_reg_write(adapter, TA_HOLD_REG, 0xE, 4);
+	msleep(100);
+
+	if (adapter->device_model != RSI_DEV_9116) {
+		*(u32 *)temp = 2;
+		if ((usb_ulp_read_write(adapter,
+					WATCH_DOG_TIMER_1,
+					&temp[0], 32)) < 0) {
+			goto fail;
+		}
+
+		*(u32 *)temp = 0;
+		if ((usb_ulp_read_write(adapter,
+					WATCH_DOG_TIMER_2,
+					temp, 32)) < 0) {
+			goto fail;
+		}
+
+		*(u32 *)temp = 50;
+		if ((usb_ulp_read_write(adapter,
+					WATCH_DOG_DELAY_TIMER_1,
+					temp, 32)) < 0) {
+			goto fail;
+		}
+
+		*(u32 *)temp = 0;
+		if ((usb_ulp_read_write(adapter,
+					WATCH_DOG_DELAY_TIMER_2,
+					temp, 32)) < 0) {
+			goto fail;
+		}
+
+		*(u32 *)temp = ((0xaa000) | RESTART_WDT | BYPASS_ULP_ON_WDT);
+		if ((usb_ulp_read_write(adapter,
+					WATCH_DOG_TIMER_ENABLE,
+					temp, 32)) < 0) {
+			goto fail;
+		}
+	} else {
+		if ((rsi_usb_master_reg_write(adapter,
+					      NWP_WWD_INTERRUPT_TIMER,
+					      5, 4)) < 0) {
+			goto fail;
+		}
+		if ((rsi_usb_master_reg_write(adapter,
+					      NWP_WWD_SYSTEM_RESET_TIMER,
+					      4, 4)) < 0) {
+			goto fail;
+		}
+		if ((rsi_usb_master_reg_write(adapter,
+					      NWP_WWD_MODE_AND_RSTART,
+					      0xAA0001, 4)) < 0) {
+			goto fail;
+		}
+	}
+
+	rsi_dbg(INFO_ZONE, "***** Card Reset Done *****\n");
+	return 0;
+
+fail:
+	rsi_dbg(ERR_ZONE, "Reset card Failed\n");
+	return -1;
+}
+
 /**
  * rsi_probe() - This function is called by kernel when the driver provided
  *		 Vendor and device IDs are matched. All the initialization
@@ -456,8 +886,9 @@ static int rsi_probe(struct usb_interface *pfunction,
 {
 	struct rsi_hw *adapter;
 	struct rsi_91x_usbdev *dev;
-	u16 fw_status;
-	int status;
+	struct rsi_common *common;
+	u32 fw_status = 0;
+	int status = 0;
 
 	rsi_dbg(INIT_ZONE, "%s: Init function called\n", __func__);
 
@@ -468,6 +899,14 @@ static int rsi_probe(struct usb_interface *pfunction,
 		return -ENOMEM;
 	}
 
+	common = adapter->priv;
+	adapter->rsi_host_intf = RSI_HOST_INTF_USB;
+	if (rsi_opermode_instances(adapter)) {
+		rsi_dbg(ERR_ZONE, "%s: Invalid operating modes\n",
+			__func__);
+		goto err;
+	}
+
 	status = rsi_init_usb_interface(adapter, pfunction);
 	if (status) {
 		rsi_dbg(ERR_ZONE, "%s: Failed to init usb interface\n",
@@ -477,34 +916,53 @@ static int rsi_probe(struct usb_interface *pfunction,
 
 	rsi_dbg(ERR_ZONE, "%s: Initialized os intf ops\n", __func__);
 
+	rsi_dbg(INIT_ZONE, "%s: product id = 0x%x vendor id = 0x%x\n",
+		__func__, id->idProduct, id->idVendor);
+
+	if (id && (id->idProduct == 0x9113)) {
+		rsi_dbg(INIT_ZONE, "%s: 9113 MODULE IS CONNECTED\n",
+			__func__);
+		adapter->device_model = RSI_DEV_9113;
+	} else if (id && (id->idProduct == 0x9116)) {
+		adapter->device_model = RSI_DEV_9116;
+		rsi_dbg(INIT_ZONE, "%s: 9116 MODULE IS CONNECTED\n",
+			__func__);
+	} else {
+		rsi_dbg(ERR_ZONE,
+			"##### Invalid RSI device id 0x%x\n",
+			id->idProduct);
+		goto err1;
+	}
+
 	dev = (struct rsi_91x_usbdev *)adapter->rsi_dev;
 
 	status = rsi_usb_reg_read(dev->usbdev, FW_STATUS_REG, &fw_status, 2);
-	if (status)
+	if (status < 0)
 		goto err1;
 	else
 		fw_status &= 1;
 
 	if (!fw_status) {
-		status = rsi_usb_device_init(adapter->priv);
+		rsi_dbg(INIT_ZONE, "Loading firmware...\n");
+		status = rsi_hal_device_init(adapter);
 		if (status) {
 			rsi_dbg(ERR_ZONE, "%s: Failed in device init\n",
 				__func__);
 			goto err1;
 		}
-
-		status = rsi_usb_reg_write(dev->usbdev,
-					   USB_INTERNAL_REG_1,
-					   RSI_USB_READY_MAGIC_NUM, 1);
-		if (status)
-			goto err1;
-		rsi_dbg(INIT_ZONE, "%s: Performed device init\n", __func__);
+		rsi_dbg(INIT_ZONE, "%s: Device Init Done\n", __func__);
 	}
 
-	status = rsi_rx_urb_submit(adapter);
+	status = rsi_rx_urb_submit(adapter, 1 /* RX_WLAN_EP */);  
 	if (status)
 		goto err1;
 
+#if defined(CONFIG_RSI_BT_ALONE) || defined(CONFIG_RSI_COEX)
+	status = rsi_rx_urb_submit(adapter, 2 /* RX_BT_EP */);
+	if (status)
+		goto err1;
+#endif
+
 	return 0;
 err1:
 	rsi_deinit_usb_interface(adapter);
@@ -529,7 +987,20 @@ static void rsi_disconnect(struct usb_interface *pfunction)
 		return;
 
 	rsi_mac80211_detach(adapter);
+	rsi_dbg(INFO_ZONE, "mac80211 detach done\n");
+
+#if defined(CONFIG_RSI_BT_ALONE) || defined(CONFIG_RSI_COEX)
+	if ((adapter->priv->coex_mode == 2) ||
+	    (adapter->priv->coex_mode == 4))
+		rsi_hci_detach(adapter->priv);
+	rsi_dbg(INFO_ZONE, "HCI Detach Done\n");
+#endif
+
+	rsi_reset_card(adapter);
+
 	rsi_deinit_usb_interface(adapter);
+	rsi_dbg(INFO_ZONE, "USB interface down\n");
+
 	rsi_91x_deinit(adapter);
 
 	rsi_dbg(INFO_ZONE, "%s: Deinitialization completed\n", __func__);
@@ -550,10 +1021,8 @@ static int rsi_resume(struct usb_interface *intf)
 #endif
 
 static const struct usb_device_id rsi_dev_table[] = {
-	{ USB_DEVICE(0x0303, 0x0100) },
-	{ USB_DEVICE(0x041B, 0x0301) },
-	{ USB_DEVICE(0x041B, 0x0201) },
-	{ USB_DEVICE(0x041B, 0x9330) },
+	{ USB_DEVICE(USB_VENDOR_ID_RSI, USB_DEVICE_ID_RSI_9113) },
+	{ USB_DEVICE(USB_VENDOR_ID_RSI, USB_DEVICE_ID_RSI_9116) },
 	{ /* Blank */},
 };
 
@@ -568,12 +1037,25 @@ static int rsi_resume(struct usb_interface *intf)
 #endif
 };
 
-module_usb_driver(rsi_driver);
+static int __init rsi_usb_module_init(void)
+{
+	rsi_dbg(INIT_ZONE,
+		"=====> RSI USB Module Initialize <=====\n");
+	return usb_register(&rsi_driver);
+}
+
+static void __exit rsi_usb_module_exit(void)
+{
+	usb_deregister(&rsi_driver);
+}
+
+module_init(rsi_usb_module_init);
+module_exit(rsi_usb_module_exit);
 
 MODULE_AUTHOR("Redpine Signals Inc");
 MODULE_DESCRIPTION("Common USB layer for RSI drivers");
 MODULE_SUPPORTED_DEVICE("RSI-91x");
 MODULE_DEVICE_TABLE(usb, rsi_dev_table);
 MODULE_FIRMWARE(FIRMWARE_RSI9113);
-MODULE_VERSION("0.1");
+MODULE_VERSION(DRV_VER);
 MODULE_LICENSE("Dual BSD/GPL");
diff --git a/drivers/net/wireless/rsi/rsi_91x_usb_ops.c b/drivers/net/wireless/rsi/rsi_91x_usb_ops.c
index de49008..a882eb8 100644
--- a/drivers/net/wireless/rsi/rsi_91x_usb_ops.c
+++ b/drivers/net/wireless/rsi/rsi_91x_usb_ops.c
@@ -1,85 +1,37 @@
-/**
- * Copyright (c) 2014 Redpine Signals Inc.
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
  *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
  *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
  *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include <linux/firmware.h>
 #include "rsi_usb.h"
 
 /**
- * rsi_copy_to_card() - This function includes the actual funtionality of
- *			copying the TA firmware to the card.Basically this
- *			function includes opening the TA file,reading the TA
- *			file and writing their values in blocks of data.
- * @common: Pointer to the driver private structure.
- * @fw: Pointer to the firmware value to be written.
- * @len: length of firmware file.
- * @num_blocks: Number of blocks to be written to the card.
- *
- * Return: 0 on success and -1 on failure.
- */
-static int rsi_copy_to_card(struct rsi_common *common,
-			    const u8 *fw,
-			    u32 len,
-			    u32 num_blocks)
-{
-	struct rsi_hw *adapter = common->priv;
-	struct rsi_91x_usbdev *dev = (struct rsi_91x_usbdev *)adapter->rsi_dev;
-	u32 indx, ii;
-	u32 block_size = dev->tx_blk_size;
-	u32 lsb_address;
-	u32 base_address;
-
-	base_address = TA_LOAD_ADDRESS;
-
-	for (indx = 0, ii = 0; ii < num_blocks; ii++, indx += block_size) {
-		lsb_address = base_address;
-		if (rsi_usb_write_register_multiple(adapter,
-						    lsb_address,
-						    (u8 *)(fw + indx),
-						    block_size)) {
-			rsi_dbg(ERR_ZONE,
-				"%s: Unable to load %s blk\n", __func__,
-				FIRMWARE_RSI9113);
-			return -EIO;
-		}
-		rsi_dbg(INIT_ZONE, "%s: loading block: %d\n", __func__, ii);
-		base_address += block_size;
-	}
-
-	if (len % block_size) {
-		lsb_address = base_address;
-		if (rsi_usb_write_register_multiple(adapter,
-						    lsb_address,
-						    (u8 *)(fw + indx),
-						    len % block_size)) {
-			rsi_dbg(ERR_ZONE,
-				"%s: Unable to load %s blk\n", __func__,
-				FIRMWARE_RSI9113);
-			return -EIO;
-		}
-	}
-	rsi_dbg(INIT_ZONE,
-		"%s: Succesfully loaded %s instructions\n", __func__,
-		FIRMWARE_RSI9113);
-
-	rsi_dbg(INIT_ZONE, "%s: loaded firmware\n", __func__);
-	return 0;
-}
-
-/**
  * rsi_usb_rx_thread() - This is a kernel thread to receive the packets from
  *			 the USB device.
  * @common: Pointer to the driver private structure.
@@ -90,96 +42,34 @@ void rsi_usb_rx_thread(struct rsi_common *common)
 {
 	struct rsi_hw *adapter = common->priv;
 	struct rsi_91x_usbdev *dev = (struct rsi_91x_usbdev *)adapter->rsi_dev;
-	int status;
+	struct sk_buff *skb;
+	int status, idx;
 
 	do {
 		rsi_wait_event(&dev->rx_thread.event, EVENT_WAIT_FOREVER);
+		rsi_reset_event(&dev->rx_thread.event);
 
 		if (atomic_read(&dev->rx_thread.thread_done))
-			goto out;
-
-		mutex_lock(&common->tx_rxlock);
-		status = rsi_read_pkt(common, 0);
-		if (status) {
-			rsi_dbg(ERR_ZONE, "%s: Failed To read data", __func__);
-			mutex_unlock(&common->tx_rxlock);
-			return;
-		}
-		mutex_unlock(&common->tx_rxlock);
-		rsi_reset_event(&dev->rx_thread.event);
-		if (adapter->rx_urb_submit(adapter)) {
-			rsi_dbg(ERR_ZONE,
-				"%s: Failed in urb submission", __func__);
-			return;
+			break;
+
+		for (idx = 0; idx < MAX_RX_URBS; idx++) {
+			while (true) {
+				skb = skb_dequeue(&dev->rx_q[idx]);
+				if (!skb)
+					break;
+
+				status = rsi_read_pkt(common, skb->data, 0);
+				if (status) {
+					rsi_dbg(ERR_ZONE, "%s: Failed To read data",
+							__func__);
+				}
+				dev_kfree_skb(skb);
+			}
 		}
 	} while (1);
 
-out:
-	rsi_dbg(INFO_ZONE, "%s: Terminated thread\n", __func__);
+	rsi_dbg(INFO_ZONE, "%s: Terminated USB RX thread\n", __func__);
+	atomic_inc(&dev->rx_thread.thread_done);
 	complete_and_exit(&dev->rx_thread.completion, 0);
 }
 
-
-/**
- * rsi_load_ta_instructions() - This function includes the actual funtionality
- *				of loading the TA firmware.This function also
- *				includes opening the TA file,reading the TA
- *				file and writing their value in blocks of data.
- * @common: Pointer to the driver private structure.
- *
- * Return: status: 0 on success, -1 on failure.
- */
-static int rsi_load_ta_instructions(struct rsi_common *common)
-{
-	struct rsi_hw *adapter = common->priv;
-	struct rsi_91x_usbdev *dev = (struct rsi_91x_usbdev *)adapter->rsi_dev;
-	const struct firmware *fw_entry = NULL;
-	u32 block_size = dev->tx_blk_size;
-	const u8 *fw;
-	u32 num_blocks, len;
-	int status = 0;
-
-	status = request_firmware(&fw_entry, FIRMWARE_RSI9113, adapter->device);
-	if (status < 0) {
-		rsi_dbg(ERR_ZONE, "%s Firmware file %s not found\n",
-			__func__, FIRMWARE_RSI9113);
-		return status;
-	}
-
-	/* Copy firmware into DMA-accessible memory */
-	fw = kmemdup(fw_entry->data, fw_entry->size, GFP_KERNEL);
-	if (!fw) {
-		status = -ENOMEM;
-		goto out;
-	}
-	len = fw_entry->size;
-
-	if (len % 4)
-		len += (4 - (len % 4));
-
-	num_blocks = (len / block_size);
-
-	rsi_dbg(INIT_ZONE, "%s: Instruction size:%d\n", __func__, len);
-	rsi_dbg(INIT_ZONE, "%s: num blocks: %d\n", __func__, num_blocks);
-
-	status = rsi_copy_to_card(common, fw, len, num_blocks);
-	kfree(fw);
-
-out:
-	release_firmware(fw_entry);
-	return status;
-}
-
-/**
- * rsi_device_init() - This Function Initializes The HAL.
- * @common: Pointer to the driver private structure.
- *
- * Return: 0 on success, -1 on failure.
- */
-int rsi_usb_device_init(struct rsi_common *common)
-{
-	if (rsi_load_ta_instructions(common))
-		return -EIO;
-
-	return 0;
-		}
diff --git a/drivers/net/wireless/rsi/rsi_91x_zigb.c b/drivers/net/wireless/rsi/rsi_91x_zigb.c
new file mode 100644
index 0000000..515a7f0
--- /dev/null
+++ b/drivers/net/wireless/rsi/rsi_91x_zigb.c
@@ -0,0 +1,488 @@
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *	1. Redistributions of source code must retain the above copyright
+ *	   notice, this list of conditions and the following disclaimer.
+ *
+ *	2. Redistributions in binary form must reproduce the above copyright
+ *	   notice, this list of conditions and the following disclaimer in the
+ *	   documentation and/or other materials provided with the distribution.
+ *
+ *	3. Neither the name of the copyright holder nor the names of it
+ *	   contributors may be used to endorse or promote products derived from
+ *	   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include "rsi_main.h"
+#include "rsi_zigb.h"
+
+#define RSI_ZIGB_GENL_FAMILY "Obx-ZIGBgenl"
+
+#define RSI_USER_A_MAX	(__RSI_USER_A_MAX - 1)
+#define RSI_VERSION_NR	1
+
+static struct genl_cb *global_gcb;
+
+struct rsi_proto_ops *g_proto_ops;
+
+/*
+ * attribute policy: defines which attribute has
+ * which type (e.g int, char * etc)
+ * possible values defined in net/netlink.h
+ */
+static struct nla_policy zigb_genl_policy[RSI_USER_A_MAX + 1] = {
+	[RSI_USER_A_MSG] = { .type = NLA_NUL_STRING },
+};
+
+/* family definition */
+static struct genl_family zigb_genl_family = {
+	.id      = 0,
+	.hdrsize = 0,
+	.name    = RSI_ZIGB_GENL_FAMILY,
+	.version = RSI_VERSION_NR,
+	.maxattr = RSI_USER_A_MAX,
+};
+
+static struct genl_ops zigb_genl_ops = {
+	.cmd    = RSI_USER_C_CMD,
+	.flags  = 0,
+	.policy = zigb_genl_policy,
+	.doit   = zigb_genl_recv,
+	.dumpit = NULL,
+};
+
+struct rsi_mod_ops rsi_zb_ops = {
+	.attach	= rsi_zigb_attach,
+	.detach	= rsi_zigb_detach,
+	.recv_pkt = rsi_zigb_recv_pkt,
+};
+
+u16 rsi_zb_zone_enabled = (ERR_ZONE | 0);
+
+void rsi_zb_dbg(u32 zone, const char *fmt, ...)
+{
+	struct va_format vaf;
+	va_list args;
+
+	va_start(args, fmt);
+
+	vaf.fmt = fmt;
+	vaf.va = &args;
+
+	if (zone & rsi_zb_zone_enabled)
+		pr_info("%pV", &vaf);
+	va_end(args);
+}
+
+/* This function gets command request from user space over netlink socket */
+int zigb_genl_recv(struct sk_buff *skb, struct genl_info *info)
+{
+	struct rsi_zb_adapter *zb_adapter;
+	u8 *data;
+	u16 desc;
+	int  rc = -1, len, pkttype;
+	struct genl_cb *gcb;
+	struct nlattr *na;
+	u32 dword_align_req_bytes = 0;
+
+	gcb = global_gcb;
+	if(!gcb){
+		rsi_zb_dbg(ERR_ZONE, "%s: NULL gcb\n", __func__);
+		return -EINVAL;
+	}
+	zb_adapter = (struct rsi_zb_adapter *)global_gcb->gc_drvpriv;
+	if (!zb_adapter){
+		rsi_zb_dbg(ERR_ZONE, "%s: NULL zb_adapter\n", __func__);
+		return -EINVAL;
+	}
+
+	gcb->gc_info = info;
+	gcb->gc_skb  = skb;
+
+	if (!info) {
+		rsi_zb_dbg(ERR_ZONE, "%s: NULL info\n", __func__);
+		goto err;
+	}
+
+        if (!gcb->gc_done) {
+		rsi_zb_dbg(ERR_ZONE, "%s: NULL gcb->gc_done\n", __func__);
+		goto err;
+	}
+
+	gcb->gc_pid = get_portid(info);
+	gcb->gc_seq = info->snd_seq;
+
+	na = info->attrs[RSI_USER_A_MSG];
+	if (na) {
+		data = (u8 *)nla_data(na);
+		if (!data) {
+			rsi_zb_dbg(ERR_ZONE,
+				"%s: no data recevied on family `%s'\n",
+				__func__, gcb->gc_name);
+			goto err;
+		}
+	} else {
+		rsi_zb_dbg(ERR_ZONE,
+			"%s: netlink attr is NULL on family `%s'\n",
+			__func__, gcb->gc_name);
+		goto err;
+	}
+
+	if (!data) {
+		rsi_zb_dbg(ERR_ZONE, "%s: NULL data\n", __func__);
+		goto err;
+	}
+
+	gcb->gc_info = NULL;
+	gcb->gc_skb  = NULL;
+
+	desc = *(u16 *)&data[0];
+	len = desc & 0x0FFF;
+	pkttype = ((desc & 0xF000) >> 12);
+
+	rsi_zb_dbg(INFO_ZONE, "%s: rx data, desc %x len %x pkttype %x\n",
+		   __func__, desc, len, pkttype);
+
+	skb = dev_alloc_skb(len + FRAME_DESC_SZ + DWORD_ALIGN_SZ);
+	if (!skb) {
+		rsi_zb_dbg(ERR_ZONE, "%s: Failed to alloc skb\n", __func__);
+		return -ENOMEM;
+	}
+	memset(skb->data, 0, FRAME_DESC_SZ);
+        skb_reserve(skb, FRAME_DESC_SZ + DWORD_ALIGN_SZ);
+	dword_align_req_bytes = ((unsigned long)skb->data) & 0x3f;
+	if (dword_align_req_bytes)
+		skb_push(skb, dword_align_req_bytes);
+        skb_put(skb, len);
+	memcpy(skb->data, data, skb->len);
+	if (g_proto_ops->coex_send_pkt)
+		g_proto_ops->coex_send_pkt(zb_adapter->priv, skb, RSI_ZIGB_Q);
+	rsi_zb_dbg(INFO_ZONE, "%s: sent the coex_send_pkt\n", __func__, rc);
+
+	return 0;
+
+err:
+	rsi_zb_dbg(ERR_ZONE, "%s: error(%d) occured\n", __func__, rc);
+	return rc;
+}
+
+/* This function register the network device */
+static int register_dev(struct net_device *dev)
+{
+	if (rtnl_is_locked())
+		return register_netdevice(dev);
+	else
+		return register_netdev(dev);
+}
+
+/*This function unregisters the network device &
+  returns it back to the kernel */
+void unregister_dev(struct net_device *dev)
+{
+	if (rtnl_is_locked()) {
+		unregister_netdevice(dev);
+	} else {
+		unregister_netdev(dev);
+		free_netdev(dev);
+	}
+}
+
+static int zigb_deregister_fw(void *priv)
+{
+	struct rsi_zb_adapter *zb_adapter =
+		(struct rsi_zb_adapter *)g_proto_ops->get_zb_context(priv);
+	u8 *frame_desc;
+	struct sk_buff *skb = NULL;
+	int status = 0;
+        u32 dword_align_req_bytes = 0;
+
+	rsi_zb_dbg(INFO_ZONE, "===> Deregister ZIGB FW <=== \n");
+
+	skb = dev_alloc_skb(FRAME_DESC_SZ + DWORD_ALIGN_SZ);
+	if (!skb) {
+		rsi_zb_dbg(ERR_ZONE, "%s: Failed to alloc skb\n", __func__);
+		return -ENOMEM;
+	}
+	skb_reserve(skb, DWORD_ALIGN_SZ);
+	dword_align_req_bytes = ((unsigned long)skb->data & 0x3f);
+	if (dword_align_req_bytes)
+		skb_push(skb, dword_align_req_bytes);
+        skb_put(skb, FRAME_DESC_SZ);
+	memset(skb->data, 0, FRAME_DESC_SZ);
+
+	frame_desc = skb->data;
+
+	frame_desc[12] = 0x0; /* Sequence Number */
+	frame_desc[13] = 0x1; /* Direction */
+	frame_desc[14] = 0x7; /* Interface */
+	frame_desc[15] = ZIGB_DEREGISTER; /* Packet Type */
+
+	if (g_proto_ops->coex_send_pkt)
+		g_proto_ops->coex_send_pkt(zb_adapter->priv, skb, RSI_WLAN_Q);
+	dev_kfree_skb(skb);
+
+	return status;
+}
+
+/* This function is called by OS when we UP the interface */
+int rsi_zigb_open(struct net_device *dev)
+{
+	rsi_zb_dbg(INFO_ZONE, "RSI ZiGB device open...\n");
+	dev->flags |=  IFF_RUNNING;
+
+	return 0;
+}
+
+/* This function is called by OS when the interface status changed to DOWN */
+int rsi_zigb_close(struct net_device *dev)
+{
+	rsi_zb_dbg(INFO_ZONE, "RSI ZigB device close\n",__func__);
+
+	if (!netif_queue_stopped(dev))
+		netif_stop_queue(dev);
+
+	return 0;
+}
+
+/* This function is used by Os to send packets to driver */
+int rsi_zigb_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	rsi_zb_dbg(INFO_ZONE, " %s\n",__func__);
+	
+	return 0;
+}
+
+
+int rsi_zigb_ioctl(struct net_device *dev,struct ifreq *ifr, int cmd)
+{
+       return 0;
+}
+
+int zigb_genl_send(struct genl_cb *gcb, struct sk_buff *skb)
+{
+	u8 *data;
+	u32 len;
+	int rc = -1;
+	void *hdr;
+	struct sk_buff *gskb;
+	struct net *net = &init_net;
+
+	if (!gcb || !skb)
+		return -EFAULT;
+
+	if (!gcb->gc_done)
+		return -ENODEV;
+
+	data = skb->data;
+	len  = skb->len;
+
+	if (!data || !len)
+		return -ENODATA;
+
+	rsi_zb_dbg(INFO_ZONE, "%s: sending data-%p len-%d pid-%d family-`%s'\n",
+		   __func__, data, len, gcb->gc_pid, gcb->gc_name);
+
+	gskb = genlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
+	if (!gskb) {
+		rsi_zb_dbg(ERR_ZONE, "%s: 'genlmsg_new' failed\n", __func__);
+		rc = -ENOMEM;
+		goto err;
+	}
+
+	hdr = genlmsg_put(gskb, 0, gcb->gc_seq + 1,
+              		  gcb->gc_family, 0, RSI_USER_C_CMD);
+	if (!hdr) {
+		rsi_zb_dbg(ERR_ZONE, "%s: Failed to set msg\n", __func__);
+		rc = -EINVAL;
+		goto err_fill;
+	}
+
+	rc = nla_put(gskb, RSI_USER_A_MAX, len, data);
+	if (rc) {
+		rsi_zb_dbg(ERR_ZONE, "%s: 'nla_put' fail(%d) family '%s'\n",
+			   __func__, rc, gcb->gc_name );
+		goto err_fill;
+	}
+	genlmsg_end(gskb, hdr);
+	rc = genlmsg_unicast(net, gskb, gcb->gc_pid);
+	if (rc) {
+		rsi_zb_dbg(ERR_ZONE, "%s: 'genlmsg_unicast' fail(%d) family '%s'\n",
+			   __func__, rc, gcb->gc_name );
+		goto err;
+	}
+	return rc;
+
+err_fill:
+	nlmsg_free(gskb);
+err:
+	return rc;
+}
+
+int rsi_zigb_recv_pkt(void *priv, u8 *pkt)
+{
+	struct rsi_zb_adapter *zb_adapter = g_proto_ops->get_zb_context(priv);
+	struct net_device *dev = NULL;
+	struct sk_buff *skb = NULL;
+	struct genl_cb *gcb;
+	int status;
+	int pkt_len = (le16_to_cpu(*(__le16 *)pkt)) & 0x0fff;
+
+	pkt_len += FRAME_DESC_SZ;
+	gcb = global_gcb;
+	if (!gcb) {
+		rsi_zb_dbg(ERR_ZONE, "NULL GCB\n");
+		return -EINVAL;
+	}
+
+	if (zb_adapter->fsm_state != RSI_ZB_FSM_DEVICE_READY) {
+		rsi_zb_dbg(INFO_ZONE, "ZIGB Device not ready\n");
+		return 0;
+	}
+	skb = dev_alloc_skb(pkt_len);
+	if (!skb) {
+		rsi_zb_dbg(ERR_ZONE, "%s: Failed to alloc skb\n", __func__);
+		return -ENOMEM;
+	}
+	dev = zb_adapter->dev;
+	memcpy(skb->data, pkt, pkt_len);
+	skb_put(skb, pkt_len);
+
+	skb->dev = (void *)dev;
+        status = zigb_genl_send(gcb, skb);
+        if (status != 0)
+		rsi_zb_dbg(ERR_ZONE, "%s: Failed return form zigb_genl_send \n",
+			   __func__);
+	dev_kfree_skb(skb);
+
+	return status;
+}
+
+int rsi_zigb_attach(void *priv, struct rsi_proto_ops *ops)
+{
+	struct rsi_zb_adapter *zb_adapter;
+	struct net_device *dev;
+	struct genl_cb *gcb = NULL;
+
+	static const struct net_device_ops zigb_netdev_ops = {
+		.ndo_open           = rsi_zigb_open,
+		.ndo_stop           = rsi_zigb_close,
+		.ndo_start_xmit     = rsi_zigb_xmit,
+		.ndo_do_ioctl       = rsi_zigb_ioctl,
+	};
+ 	dev = alloc_netdev(sizeof(struct rsi_zb_adapter), "zigb%d",
+			   NET_NAME_UNKNOWN, ether_setup);
+	if (!dev) {
+		rsi_zb_dbg(ERR_ZONE, "%s: Failed to alloc netdev\n", __func__);
+		return -EINVAL;
+	}
+	dev->hard_header_len = FRAME_DESC_SZ + DWORD_ALIGN_SZ;
+	dev->netdev_ops = &zigb_netdev_ops;
+
+	zb_adapter = (struct rsi_zb_adapter *)netdev_priv(dev);
+	zb_adapter->priv = priv;
+	ops->set_zb_context(priv, zb_adapter);
+	g_proto_ops = ops;
+	ops->zb_ops = &rsi_zb_ops;
+	zb_adapter->fsm_state = RSI_ZB_FSM_DEVICE_READY;
+
+	if (register_dev(dev) != 0) {
+		rsi_zb_dbg(ERR_ZONE, "%s: Failed to register zigb device\n",
+			   __func__);
+		goto err;
+	}
+	zb_adapter->dev = dev;
+	memcpy(zb_adapter->mac_addr, device_mac_addr, 6);
+	memcpy(zb_adapter->dev->dev_addr, zb_adapter->mac_addr, 6);
+	zb_adapter->fsm_state = RSI_ZB_FSM_DEVICE_READY;
+
+	gcb = kzalloc(sizeof(*gcb), GFP_KERNEL);
+	if (!gcb) {
+		rsi_zb_dbg(ERR_ZONE, "%s: Failed to alloc genl control block\n",
+			   __func__);
+		goto err;
+	}
+	zb_adapter->gcb = gcb;
+	global_gcb = gcb;
+
+	gcb->gc_drvpriv = zb_adapter;
+	gcb->gc_family = &zigb_genl_family;
+	gcb->gc_policy = &zigb_genl_policy[0];
+	gcb->gc_ops = &zigb_genl_ops;
+	gcb->gc_n_ops = 1;
+	gcb->gc_name = RSI_ZIGB_GENL_FAMILY;
+	gcb->gc_done = 0;
+	gcb->gc_pid = gcb->gc_done;
+
+	rsi_zb_dbg(INIT_ZONE, "genl-register: nl_family `%s'\n", gcb->gc_name);
+
+	gcb->gc_family->ops = gcb->gc_ops;
+	gcb->gc_family->n_ops = gcb->gc_n_ops;
+
+	if (genl_register_family(gcb->gc_family)) {
+		rsi_zb_dbg(ERR_ZONE, "%s: genl_register_family failed\n",
+			   __func__);
+		goto err;
+	}
+	gcb->gc_done = 1;
+	rsi_zb_dbg(ERR_ZONE, "RSI ZIGBEE module init done\n");
+
+	return 0;
+
+err:
+	if (dev) {
+		unregister_dev(dev);
+		free_netdev(dev);
+	        zb_adapter->dev = NULL;
+	}
+	if (gcb) {
+		genl_unregister_family(gcb->gc_family);
+		kfree(gcb);
+	}
+	zb_adapter->gcb = NULL;
+	return -EINVAL;
+}
+
+/*This function de-initializes zigbee interface*/
+void rsi_zigb_detach(void *priv)
+{
+	struct rsi_zb_adapter *zb_adapter = g_proto_ops->get_zb_context(priv);
+	struct net_device *dev = zb_adapter->dev;
+	struct genl_cb *gcb = NULL;
+	int status;
+	gcb = zb_adapter->gcb;
+        
+	status = zigb_deregister_fw(priv);
+	if (!status)
+		rsi_zb_dbg(ERR_ZONE, "%s: Failed sending deregister zigb\n",
+			   __func__);
+	if (dev) {
+		unregister_dev(dev);
+	        zb_adapter->dev = NULL;
+	}
+	if (gcb) {
+		genl_unregister_family(gcb->gc_family);
+		kfree(gcb);
+	}
+	rsi_zb_dbg(ERR_ZONE, "%s: ZiGB detach done\n", __func__);
+}
+
+struct rsi_mod_ops *rsi_get_zb_ops(void)
+{
+	return &rsi_zb_ops;
+};
diff --git a/drivers/net/wireless/rsi/rsi_boot_params.h b/drivers/net/wireless/rsi/rsi_boot_params.h
index 5e2721f..cd89688 100644
--- a/drivers/net/wireless/rsi/rsi_boot_params.h
+++ b/drivers/net/wireless/rsi/rsi_boot_params.h
@@ -1,87 +1,119 @@
-/**
- * Copyright (c) 2014 Redpine Signals Inc.
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
  *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
  *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
+ *
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
+ *
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #ifndef __RSI_BOOTPARAMS_HEADER_H__
 #define __RSI_BOOTPARAMS_HEADER_H__
 
-#define CRYSTAL_GOOD_TIME                BIT(0)
-#define BOOTUP_MODE_INFO                 BIT(1)
-#define WIFI_TAPLL_CONFIGS               BIT(5)
-#define WIFI_PLL960_CONFIGS              BIT(6)
-#define WIFI_AFEPLL_CONFIGS              BIT(7)
-#define WIFI_SWITCH_CLK_CONFIGS          BIT(8)
+#define CRYSTAL_GOOD_TIME		BIT(0)
+#define BOOTUP_MODE_INFO                BIT(1)
+#define WIFI_TAPLL_CONFIGS              BIT(5)
+#define WIFI_PLL960_CONFIGS             BIT(6)
+#define WIFI_AFEPLL_CONFIGS             BIT(7)
+#define WIFI_SWITCH_CLK_CONFIGS         BIT(8)
 
-#define TA_PLL_M_VAL_20                  8
-#define TA_PLL_N_VAL_20                  1
-#define TA_PLL_P_VAL_20                  4
+#define TAPLL_M_VAL_20			9
+#define TAPLL_N_VAL_20			0
+#define TAPLL_P_VAL_20			4
 
-#define PLL960_M_VAL_20                  0x14
-#define PLL960_N_VAL_20                  0
-#define PLL960_P_VAL_20                  5
+#define PLL960_M_VAL_20                 0x14
+#define PLL960_N_VAL_20                 0
+#define PLL960_P_VAL_20                 5
 
-#define UMAC_CLK_40MHZ                   40
+#define UMAC_CLK_40MHZ                  80
 
-#define TA_PLL_M_VAL_40                  46
-#define TA_PLL_N_VAL_40                  3
-#define TA_PLL_P_VAL_40                  3
+#define TAPLL_M_VAL_40                  9
+#define TAPLL_N_VAL_40                  0
+#define TAPLL_P_VAL_40                  4
 
-#define PLL960_M_VAL_40                  0x14
-#define PLL960_N_VAL_40                  0
-#define PLL960_P_VAL_40                  5
+#define PLL960_M_VAL_40                 0x14
+#define PLL960_N_VAL_40                 0
+#define PLL960_P_VAL_40                 5
 
 #define UMAC_CLK_20BW \
-	(((TA_PLL_M_VAL_20 + 1) * 40) / \
-	 ((TA_PLL_N_VAL_20 + 1) * (TA_PLL_P_VAL_20 + 1)))
+	(((TAPLL_M_VAL_20 + 1) * 40) / \
+	 ((TAPLL_N_VAL_20 + 1) * (TAPLL_P_VAL_20 + 1)))
 #define VALID_20 \
-	(WIFI_PLL960_CONFIGS | WIFI_AFEPLL_CONFIGS | WIFI_SWITCH_CLK_CONFIGS)
+	(WIFI_TAPLL_CONFIGS | WIFI_PLL960_CONFIGS | WIFI_AFEPLL_CONFIGS | \
+	 WIFI_SWITCH_CLK_CONFIGS | BOOTUP_MODE_INFO | CRYSTAL_GOOD_TIME)
+
 #define UMAC_CLK_40BW   \
-	(((TA_PLL_M_VAL_40 + 1) * 40) / \
-	 ((TA_PLL_N_VAL_40 + 1) * (TA_PLL_P_VAL_40 + 1)))
+	(((TAPLL_M_VAL_40 + 1) * 40) / \
+	 ((TAPLL_N_VAL_40 + 1) * (TAPLL_P_VAL_40 + 1)))
 #define VALID_40 \
 	(WIFI_PLL960_CONFIGS | WIFI_AFEPLL_CONFIGS | WIFI_SWITCH_CLK_CONFIGS | \
 	 WIFI_TAPLL_CONFIGS | CRYSTAL_GOOD_TIME | BOOTUP_MODE_INFO)
 
-/* structure to store configs related to TAPLL programming */
+/* TAPLL programming configurations */
 struct tapll_info {
 	__le16 pll_reg_1;
 	__le16 pll_reg_2;
 } __packed;
 
-/* structure to store configs related to PLL960 programming */
+/* PLL960 programming configurations */
 struct pll960_info {
 	__le16 pll_reg_1;
 	__le16 pll_reg_2;
 	__le16 pll_reg_3;
 } __packed;
 
-/* structure to store configs related to AFEPLL programming */
+/* AFEPLL programming configurations */
 struct afepll_info {
 	__le16 pll_reg;
 } __packed;
 
-/* structure to store configs related to pll configs */
+/* PLL configurations */
 struct pll_config {
 	struct tapll_info tapll_info_g;
 	struct pll960_info pll960_info_g;
 	struct afepll_info afepll_info_g;
 } __packed;
 
-/* structure to store configs related to UMAC clk programming */
+/* PLL configurations for RS9116 */
+struct pll_config_9116 {
+	__le16 pll_ctrl_set_reg;
+	__le16 pll_ctrl_clr_reg;
+	__le16 pll_modem_conig_reg;
+	__le16 soc_clk_config_reg;
+	__le16 adc_dac_strm1_config_reg;
+	__le16 adc_dac_strm2_config_reg;
+} __packed;
+
+/* UMAC clk programming configurations */
 struct switch_clk {
-	__le16 switch_clk_info;
+	__le16 switch_umac_clk : 1; /* If set rest is valid */
+	__le16 switch_qspi_clk : 1; /* If set qspi clk will be changed */
+	__le16 switch_slp_clk_2_32 : 1;
+	__le16 switch_bbp_lmac_clk_reg : 1;
+	__le16 switch_mem_ctrl_cfg : 1;
+	__le16 reserved : 11;
+
 	/* If switch_bbp_lmac_clk_reg is set then this value will be programmed
 	 * into reg
 	 */
@@ -92,18 +124,73 @@ struct switch_clk {
 	__le16 qspi_uart_clock_reg_config;
 } __packed;
 
+#define RSI_SWITCH_TASS_CLK					BIT(0)
+#define RSI_SWITCH_QSPI_CLK					BIT(1)
+#define RSI_SWITCH_SLP_CLK_2_32				BIT(2)
+#define RSI_SWITCH_WLAN_BBP_LMAC_CLK_REG			BIT(3)
+#define RSI_SWITCH_ZBBT_BBP_LMAC_CLK_REG			BIT(4)
+#define RSI_SWITCH_BBP_LMAC_CLK_REG				BIT(5)
+#define RSI_MODEM_CLK_160MHZ					BIT(6)
+
+/* UMAC clk programming configurations for RS9116 */
+struct switch_clk_9116 {
+	__le32 switch_clk_info;
+	__le32 tass_clock_reg;
+	__le32 wlan_bbp_lmac_clk_reg_val;
+	__le32 zbbt_bbp_lmac_clk_reg_val;
+	__le32 bbp_lmac_clk_en_val;
+} __packed;
+
 struct device_clk_info {
 	struct pll_config pll_config_g;
 	struct switch_clk switch_clk_g;
 } __packed;
 
+/* device clock info configurations for RS9116 */
+struct device_clk_info_9116 {
+	struct pll_config_9116 pll_config_9116_g;
+	struct switch_clk_9116 switch_clk_9116_g;
+} __packed;
+
 struct bootup_params {
 	__le16 magic_number;
+#define LOADED_TOKEN  0x5AA5   /* Bootup params are installed by host
+				* or OTP/FLASH (Bootloader)
+				*/
+#define ROM_TOKEN     0x55AA   /* Bootup params are taken from ROM
+				* itself in MCU mode.
+				*/
 	__le16 crystal_good_time;
 	__le32 valid;
+#define CRYSTAL_GOOD_TIME                BIT(0)
+#define BOOTUP_MODE_INFO                 BIT(1)
+#define DIGITAL_LOOP_BACK_PARAMS         BIT(2)
+#define RTLS_TIMESTAMP_EN                BIT(3)
+#define HOST_SPI_INTR_CFG                BIT(4)
+#define WIFI_TAPLL_CONFIGS               BIT(5)
+#define WIFI_PLL960_CONFIGS              BIT(6)
+#define WIFI_AFEPLL_CONFIGS              BIT(7)
+#define WIFI_SWITCH_CLK_CONFIGS          BIT(8)
+#define BT_TAPLL_CONFIGS                 BIT(9)
+#define BT_PLL960_CONFIGS                BIT(10)
+#define BT_AFEPLL_CONFIGS                BIT(11)
+#define BT_SWITCH_CLK_CONFIGS            BIT(12)
+#define ZB_TAPLL_CONFIGS                 BIT(13)
+#define ZB_PLL960_CONFIGS                BIT(14)
+#define ZB_AFEPLL_CONFIGS                BIT(15)
+#define ZB_SWITCH_CLK_CONFIGS            BIT(16)
+#define BUCKBOOST_WAIT_INFO              BIT(17)
+#define PMU_WAKEUP_SHUTDOWN_W            BIT(18)
+#define WDT_PROG_VALUES                  BIT(19)
+#define WDT_RESET_DELAY_VALUE            BIT(20)
+#define DCDC_OPERATION_MODE_VALID        BIT(21)
+#define PMU_SLP_CLKOUT_SEL               BIT(22)
+#define SOC_RESET_WAIT_CNT               BIT(23)
 	__le32 reserved_for_valids;
 	__le16 bootup_mode_info;
-	/* configuration used for digital loop back */
+#define BT_COEXIST                       BIT(0)
+#define BOOTUP_MODE                     (BIT(2) | BIT(1))
+#define CUR_DEV_MODE                    (bootup_params.bootup_mode_info >> 1)
 	__le16 digital_loop_back_params;
 	__le16 rtls_timestamp_en;
 	__le16 host_spi_intr_cfg;
@@ -122,5 +209,71 @@ struct bootup_params {
 	/* dcdc modes configs */
 	__le32 dcdc_operation_mode;
 	__le32 soc_reset_wait_cnt;
+	__le32 waiting_time_at_fresh_sleep;
+	__le32 max_threshold_to_avoid_sleep;
+	u8 beacon_resedue_alg_en;
+} __packed;
+
+/* bootup params for RS9116 */
+struct bootup_params_9116 {
+	__le16 magic_number;
+#define LOADED_TOKEN  0x5AA5   /* Bootup params are installed by host
+				* or OTP/FLASH (Bootloader)
+				*/
+#define ROM_TOKEN     0x55AA   /* Bootup params are taken from ROM
+				* itself in MCU mode.
+				*/
+	__le16 crystal_good_time;
+	__le32 valid;
+#define CRYSTAL_GOOD_TIME                BIT(0)
+#define BOOTUP_MODE_INFO                 BIT(1)
+#define DIGITAL_LOOP_BACK_PARAMS         BIT(2)
+#define RTLS_TIMESTAMP_EN                BIT(3)
+#define HOST_SPI_INTR_CFG                BIT(4)
+#define WIFI_TAPLL_CONFIGS               BIT(5)
+#define WIFI_PLL960_CONFIGS              BIT(6)
+#define WIFI_AFEPLL_CONFIGS              BIT(7)
+#define WIFI_SWITCH_CLK_CONFIGS          BIT(8)
+#define BT_TAPLL_CONFIGS                 BIT(9)
+#define BT_PLL960_CONFIGS                BIT(10)
+#define BT_AFEPLL_CONFIGS                BIT(11)
+#define BT_SWITCH_CLK_CONFIGS            BIT(12)
+#define ZB_TAPLL_CONFIGS                 BIT(13)
+#define ZB_PLL960_CONFIGS                BIT(14)
+#define ZB_AFEPLL_CONFIGS                BIT(15)
+#define ZB_SWITCH_CLK_CONFIGS            BIT(16)
+#define BUCKBOOST_WAIT_INFO              BIT(17)
+#define PMU_WAKEUP_SHUTDOWN_W            BIT(18)
+#define WDT_PROG_VALUES                  BIT(19)
+#define WDT_RESET_DELAY_VALUE            BIT(20)
+#define DCDC_OPERATION_MODE_VALID        BIT(21)
+#define PMU_SLP_CLKOUT_SEL               BIT(22)
+#define SOC_RESET_WAIT_CNT               BIT(23)
+	__le32 reserved_for_valids;
+	__le16 bootup_mode_info;
+#define BT_COEXIST                       BIT(0)
+#define BOOTUP_MODE                     (BIT(2) | BIT(1))
+#define CUR_DEV_MODE_9116	(bootup_params_9116.bootup_mode_info >> 1)
+	__le16 digital_loop_back_params;
+	__le16 rtls_timestamp_en;
+	__le16 host_spi_intr_cfg;
+	struct device_clk_info_9116 device_clk_info_9116[1];
+	/* ulp buckboost wait time  */
+	__le32 buckboost_wakeup_cnt;
+	/* pmu wakeup wait time & WDT EN info */
+	__le16 pmu_wakeup_wait;
+	u8 shutdown_wait_time;
+	/* Sleep clock source selection */
+	u8 pmu_slp_clkout_sel;
+	/* WDT programming values */
+	__le32 wdt_prog_value;
+	/* WDT soc reset delay */
+	__le32 wdt_soc_rst_delay;
+	/* dcdc modes configs */
+	__le32 dcdc_operation_mode;
+	__le32 soc_reset_wait_cnt;
+	__le32 waiting_time_at_fresh_sleep;
+	__le32 max_threshold_to_avoid_sleep;
+	u8 beacon_resedue_alg_en;
 } __packed;
 #endif
diff --git a/drivers/net/wireless/rsi/rsi_coex.h b/drivers/net/wireless/rsi/rsi_coex.h
new file mode 100644
index 0000000..2a35d36
--- /dev/null
+++ b/drivers/net/wireless/rsi/rsi_coex.h
@@ -0,0 +1,67 @@
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
+ *
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
+ *
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __RSI_COEX_H__
+#define __RSI_COEX_H__
+
+#include "rsi_common.h"
+
+#define RSI_COEX_TXQ_MAX_PKTS		64
+#define RSI_COEX_TXQ_WATER_MARK		50
+#define COMMON_CARD_READY_IND           0
+
+#define COEX_Q				0
+#define BT_Q				1
+#define WLAN_Q				2
+#define VIP_Q				3
+#define ZIGB_Q				4
+#define NUM_COEX_TX_QUEUES		5
+
+#include "rsi_main.h"
+
+enum rsi_proto {
+	RSI_PROTO_WLAN = 0,
+	RSI_PROTO_BT
+};
+
+struct rsi_coex_ctrl_block {
+	struct rsi_common *priv;
+	struct sk_buff_head coex_tx_qs[NUM_COEX_TX_QUEUES];
+        struct semaphore tx_bus_lock;
+	struct rsi_thread coex_tx_thread;
+};
+
+int rsi_coex_init(struct rsi_common *common);
+int rsi_coex_send_pkt(void *priv,
+		      struct sk_buff *skb,
+		      u8 proto_type);
+int rsi_coex_recv_pkt(struct rsi_common *common, u8 *msg);
+void rsi_coex_deinit(struct rsi_common *common);
+#endif
diff --git a/drivers/net/wireless/rsi/rsi_common.h b/drivers/net/wireless/rsi/rsi_common.h
index d3fbe33..bf9f177 100644
--- a/drivers/net/wireless/rsi/rsi_common.h
+++ b/drivers/net/wireless/rsi/rsi_common.h
@@ -1,17 +1,31 @@
-/**
- * Copyright (c) 2014 Redpine Signals Inc.
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
  *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
  *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
+ *
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
+ *
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #ifndef __RSI_COMMON_H__
@@ -20,8 +34,6 @@
 #include <linux/kthread.h>
 
 #define EVENT_WAIT_FOREVER              0
-#define TA_LOAD_ADDRESS                 0x00
-#define FIRMWARE_RSI9113                "rsi_91x.fw"
 #define QUEUE_NOT_FULL                  1
 #define QUEUE_FULL                      0
 
@@ -38,10 +50,10 @@ static inline int rsi_wait_event(struct rsi_event *event, u32 timeout)
 
 	if (!timeout)
 		status = wait_event_interruptible(event->event_queue,
-				(atomic_read(&event->event_condition) == 0));
+				(!atomic_read(&event->event_condition)));
 	else
 		status = wait_event_interruptible_timeout(event->event_queue,
-				(atomic_read(&event->event_condition) == 0),
+				(!atomic_read(&event->event_condition)),
 				timeout);
 	return status;
 }
@@ -63,6 +75,7 @@ static inline int rsi_create_kthread(struct rsi_common *common,
 				     u8 *name)
 {
 	init_completion(&thread->completion);
+	atomic_set(&thread->thread_done, 0);
 	thread->task = kthread_run(func_ptr, common, "%s", name);
 	if (IS_ERR(thread->task))
 		return (int)PTR_ERR(thread->task);
@@ -72,10 +85,12 @@ static inline int rsi_create_kthread(struct rsi_common *common,
 
 static inline int rsi_kill_thread(struct rsi_thread *handle)
 {
+	if (atomic_read(&handle->thread_done) > 0)
+		return 0;
 	atomic_inc(&handle->thread_done);
 	rsi_set_event(&handle->event);
 
-	wait_for_completion(&handle->completion);
+	//wait_for_completion(&handle->completion);
 	return kthread_stop(handle->task);
 }
 
@@ -83,5 +98,29 @@ static inline int rsi_kill_thread(struct rsi_thread *handle)
 u16 rsi_get_connected_channel(struct rsi_hw *adapter);
 struct rsi_hw *rsi_91x_init(void);
 void rsi_91x_deinit(struct rsi_hw *adapter);
-int rsi_read_pkt(struct rsi_common *common, s32 rcv_pkt_len);
+int rsi_read_pkt(struct rsi_common *common, u8 *rx_pkt, s32 rcv_pkt_len);
+void rsi_indicate_bcnmiss(struct rsi_common *common);
+void rsi_resume_conn_channel(struct rsi_hw *adapter, struct ieee80211_vif *vif);
+void rsi_hci_detach(struct rsi_common *common);
+char *dot11_pkt_type(__le16 frame_control);
+struct rsi_sta *rsi_find_sta(struct rsi_common *common, u8 *mac_addr);
+void rsi_init_bcn_timer(struct rsi_common *common);
+void rsi_del_bcn_timer(struct rsi_common *common);
+void rsi_bcn_scheduler_thread(struct rsi_common *common);
+#ifdef CONFIG_SDIO_INTR_POLL
+void init_sdio_intr_status_poll_thread(struct rsi_common *common);
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION (4, 15, 0)
+void rsi_roc_timeout(unsigned long data);
+#else
+void rsi_roc_timeout(struct timer_list *t);
+#endif
+struct ieee80211_vif *rsi_get_vif(struct rsi_hw *adapter, u8 *mac);
+#ifdef CONFIG_HW_SCAN_OFFLOAD
+void rsi_mac80211_hw_scan_cancel(struct ieee80211_hw *hw,
+				 struct ieee80211_vif *vif);
+#endif
+#ifdef CONFIG_RSI_WOW
+int rsi_config_wowlan(struct rsi_hw *adapter, struct cfg80211_wowlan *wowlan);
+#endif
 #endif
diff --git a/drivers/net/wireless/rsi/rsi_debugfs.h b/drivers/net/wireless/rsi/rsi_debugfs.h
index 580ad3b..58085fd 100644
--- a/drivers/net/wireless/rsi/rsi_debugfs.h
+++ b/drivers/net/wireless/rsi/rsi_debugfs.h
@@ -1,17 +1,31 @@
-/**
- * Copyright (c) 2014 Redpine Signals Inc.
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
  *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
  *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
+ *
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
+ *
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #ifndef __RSI_DEBUGFS_H__
diff --git a/drivers/net/wireless/rsi/rsi_hal.h b/drivers/net/wireless/rsi/rsi_hal.h
new file mode 100644
index 0000000..521dd54
--- /dev/null
+++ b/drivers/net/wireless/rsi/rsi_hal.h
@@ -0,0 +1,252 @@
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
+ *
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
+ *
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __RSI_HAL_H__
+#define __RSI_HAL_H__
+
+/* Device Operating modes */
+#define DEV_OPMODE_WIFI_ALONE		1
+#define DEV_OPMODE_BT_ALONE		4
+#define DEV_OPMODE_BT_LE_ALONE		8
+#define DEV_OPMODE_BT_DUAL		12
+#define DEV_OPMODE_STA_BT		5
+#define DEV_OPMODE_STA_BT_LE		9
+#define DEV_OPMODE_STA_BT_DUAL		13
+#define DEV_OPMODE_AP_BT		6
+#define DEV_OPMODE_AP_BT_DUAL		14
+#define DEV_OPMODE_ZB_ALONE		16
+#define DEV_OPMODE_STA_ZB		17
+#define DEV_OPMODE_ZB_COORDINATOR	32
+#define DEV_OPMODE_ZB_ROUTER		48
+
+/* ZigBee Operating Modes */
+#define ZIGBEE_END_DEVICE		1
+#define ZIGBEE_COORDINATOR		2
+#define ZIGBEE_ROUTER			3
+
+#define ZIGBEE_OPERMODE_MASK		0x3
+
+#define TA_LOAD_ADDRESS			0x00
+#define FIRMWARE_RSI9113		"rsi_91x.fw"
+#define FLASH_WRITE_CHUNK_SIZE		(4 * 1024)
+#define USB_FLASH_READ_CHUNK_SIZE	((2 * 1024) - 4)
+#define SDIO_FLASH_READ_CHUNK_SIZE	(2 * 1024)
+#define FLASH_SECTOR_SIZE		(4 * 1024)
+#define STARTING_BLOCK_INDEX		0
+#define FLASH_BLOCK_SIZE		(32 * 1024)
+
+#define FLASH_SIZE_ADDR			0x04000016
+
+#define PING_BUFFER_ADDRESS_9116	0x18400
+#define PONG_BUFFER_ADDRESS_9116	0x19400
+
+#define PING_BUFFER_ADDRESS		0x19000
+#define PONG_BUFFER_ADDRESS		0x1a000
+
+#define SWBL_REGIN			0x41050034
+#define SWBL_REGOUT			0x4105003c
+#define PING_WRITE			0x1
+#define PONG_WRITE			0x2
+#define FW_WDT_DISABLE_REQ		0x69
+#define FW_WDT_DISABLE_DONE		0x96
+
+#define BL_CMD_TIMEOUT			2000
+#define BL_BURN_TIMEOUT			(50 * 1000)
+
+#define MASTER_READ_MODE		1
+#define EEPROM_READ_MODE		2
+
+#define REGIN_VALID			0xA
+#define REGIN_INPUT			0xA0
+#define REGOUT_VALID			0xAB
+#define REGOUT_INVALID			(~0xAB)
+#define CMD_PASS			0xAA
+#define CMD_FAIL			0xCC
+#define INVALID_ADDR			0x4C
+
+#define BURN_BL				0x23
+#define LOAD_HOSTED_FW			'A'
+#define BURN_HOSTED_FW			'B'
+#define PING_VALID			'I'
+#define PONG_VALID			'O'
+#define PING_AVAIL			'I'
+#define PONG_AVAIL			'O'
+#define EOF_REACHED			'E'
+#define CHECK_CRC			'K'
+#define POLLING_MODE			'P'
+#define CONFIG_AUTO_READ_MODE		'R'
+#define JUMP_TO_ZERO_PC			'J'
+#define FW_LOADING_SUCCESSFUL		'S'
+#define LOADING_INITIATED		'1'
+
+/* Total RAM access commands from TA */
+#define MEM_ACCESS_CTRL_FROM_HOST  0x41300000
+#define RAM_384K_ACCESS_FROM_TA (BIT(2) | BIT(3) | BIT(4) | BIT(5) \
+				 | BIT(20) | BIT(21) | BIT(22) | BIT(23) \
+				 | BIT(24) | BIT(25))
+
+/* Boot loader commands */
+#define HOST_INTF_REG_OUT		0x4105003C
+#define HOST_INTF_REG_IN		0x41050034
+#define BOARD_READY			0xABCD
+#define REG_READ			0xD1
+#define REG_WRITE			0xD2
+#define SEND_RPS_FILE			'2'
+#define BOOTUP_OPTIONS_LAST_CONFIG_NOT_SAVED 0xF1
+#define BOOTUP_OPTIONS_CHECKSUM_FAIL 0xF2
+#define INVALID_OPTION			0xF3
+#define CHECKSUM_SUCCESS		0xAA
+#define CHECKSUM_FAILURE		0xCC
+#define CHECKSUM_INVALID_ADDRESS	0x4C
+
+#define EEPROM_VERSION_OFFSET		77
+#define CALIB_CRC_OFFSET		4092
+#define MAGIC_WORD			0x5A
+#define MAGIC_WORD_OFFSET_1		40
+#define MAGIC_WORD_OFFSET_2		424
+#define FW_IMAGE_MIN_ADDRESS		(68 * 1024)
+#define FLASH_MAX_ADDRESS		(4 * 1024 * 1024) //4MB
+#define MAX_FLASH_FILE_SIZE		(400 * 1024) //400K
+#define FLASHING_START_ADDRESS		16
+#define CALIB_VALUES_START_ADDR		16
+#define SOC_FLASH_ADDR			0x04000000
+#define EEPROM_DATA_SIZE		4096
+#define CALIB_DATA_SIZE		(EEPROM_DATA_SIZE - CALIB_VALUES_START_ADDR)
+#define BL_HEADER			32
+
+#define BT_CARD_READY_IND		0x89
+#define WLAN_CARD_READY_IND		0x0
+#define COMMON_HAL_CARD_READY_IND	0x0
+#define ZIGB_CARD_READY_IND		0xff
+
+#define COMMAN_HAL_WAIT_FOR_CARD_READY	1
+#define COMMON_HAL_SEND_CONFIG_PARAMS	2
+#define COMMON_HAL_TX_ACCESS		3
+#define COMMON_HAL_WAIT_FOR_PROTO_CARD_READY 4
+#define HEX_FILE			1
+#define BIN_FILE			0
+#define UNIX_FILE_TYPE			8
+#define DOS_FILE_TYPE			9
+#define LMAC_INSTRUCTIONS_SIZE		(16  * 1024) /* 16Kbytes */
+
+#define ULP_RESET_REG			0x161
+#define WATCH_DOG_TIMER_1		0x16c
+#define WATCH_DOG_TIMER_2		0x16d
+#define WATCH_DOG_DELAY_TIMER_1		0x16e
+#define WATCH_DOG_DELAY_TIMER_2		0x16f
+#define WATCH_DOG_TIMER_ENABLE		0x170
+
+#define RESTART_WDT			BIT(11)
+#define BYPASS_ULP_ON_WDT		BIT(1)
+
+#define RF_SPI_PROG_REG_BASE_ADDR	0x40080000
+
+#define GSPI_CTRL_REG0			(RF_SPI_PROG_REG_BASE_ADDR)
+#define GSPI_CTRL_REG1			(RF_SPI_PROG_REG_BASE_ADDR + 0x2)
+#define GSPI_DATA_REG0			(RF_SPI_PROG_REG_BASE_ADDR + 0x4)
+#define GSPI_DATA_REG1			(RF_SPI_PROG_REG_BASE_ADDR + 0x6)
+#define GSPI_DATA_REG2			(RF_SPI_PROG_REG_BASE_ADDR + 0x8)
+
+#define GSPI_DMA_MODE			BIT(13)
+
+#define GSPI_2_ULP			BIT(12)
+#define GSPI_TRIG			BIT(7)
+#define GSPI_READ			BIT(6)
+#define GSPI_RF_SPI_ACTIVE		BIT(8)
+
+#define FW_FLASH_OFFSET			0x820
+#define LMAC_VER_OFFSET			FW_FLASH_OFFSET +0x200
+#define LMAC_VER_OFFSET_RS9116			0x22c2
+
+/* Buffer status register related info */
+#define PKT_BUFF_SEMI_FULL		0
+#define PKT_BUFF_FULL			1
+#define PKT_MGMT_BUFF_FULL		2
+#define MSDU_PKT_PENDING		3
+
+#define NWP_AHB_BASE_ADDR               0x41300000
+#define NWP_WWD_INTERRUPT_TIMER         (NWP_AHB_BASE_ADDR + 0x300)
+#define NWP_WWD_SYSTEM_RESET_TIMER      (NWP_AHB_BASE_ADDR + 0x304)
+#define NWP_WWD_WINDOW_TIMER            (NWP_AHB_BASE_ADDR + 0x308)
+#define NWP_WWD_TIMER_SETTINGS          (NWP_AHB_BASE_ADDR + 0x30C)
+#define NWP_WWD_MODE_AND_RSTART         (NWP_AHB_BASE_ADDR + 0x310)
+#define NWP_WWD_RESET_BYPASS            (NWP_AHB_BASE_ADDR + 0x314)
+#define NWP_FSM_INTR_MASK_REG           (NWP_AHB_BASE_ADDR + 0x104)
+
+struct bl_header {
+	__le32 flags;
+	__le32 image_no;
+	__le32 check_sum;
+	__le32 flash_start_address;
+	__le32 flash_len;
+} __packed;
+
+struct ta_metadata {
+	char *name;
+	unsigned int address;
+};
+
+extern atomic_t drv_instances[5];
+#define DRV_INSTANCE(__x) (atomic_read(&drv_instances[(__x) - 1]))
+#define DRV_INSTANCE_SET(__x, __y) \
+	(atomic_set(&drv_instances[(__x) - 1], (__y)))
+#define MAX_INSTANCES 5
+
+#define RSI_BL_CTRL_LEN_MASK			0xFFFFFF
+#define RSI_BL_CTRL_SPI_32BIT_MODE		BIT(27)
+#define RSI_BL_CTRL_REL_TA_SOFTRESET		BIT(28)
+#define RSI_BL_CTRL_START_FROM_ROM_PC		BIT(29)
+#define RSI_BL_CTRL_SPI_8BIT_MODE		BIT(30)
+#define RSI_BL_CTRL_LAST_ENTRY			BIT(31)
+
+struct bootload_entry {
+	__le32 control;
+	__le32 dst_addr;                       /* Destination address */
+} __packed;
+
+struct bootload_ds {
+	__le16 fixed_pattern;
+	__le16 offset;
+	__le32 reserved;
+	struct bootload_entry bl_entry[7];
+} __packed;
+
+int rsi_prepare_mgmt_desc(struct rsi_common *common, struct sk_buff *skb);
+int rsi_prepare_data_desc(struct rsi_common *common, struct sk_buff *skb);
+int rsi_hal_device_init(struct rsi_hw *adapter);
+int rsi_send_data_pkt(struct rsi_common *common, struct sk_buff *skb);
+int rsi_send_bt_pkt(struct rsi_common *common, struct sk_buff *skb);
+int rsi_send_zb_pkt(struct rsi_common *common, struct sk_buff *skb);
+int rsi_prepare_beacon(struct rsi_common *common, struct sk_buff *skb);
+int rsi_deregister_bt(struct rsi_common *common);
+int rsi_validate_oper_mode(u16 oper_mode);
+int rsi_opermode_instances(struct rsi_hw *adapter);
+
+#endif
diff --git a/drivers/net/wireless/rsi/rsi_hci.h b/drivers/net/wireless/rsi/rsi_hci.h
new file mode 100644
index 0000000..6873bf2
--- /dev/null
+++ b/drivers/net/wireless/rsi/rsi_hci.h
@@ -0,0 +1,128 @@
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
+ *
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
+ *
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __RSI_HCI_H__
+#define __RSI_HCI_H__
+
+#include <net/bluetooth/bluetooth.h>
+#include <net/bluetooth/hci_core.h>
+#include <net/genetlink.h>
+#include <linux/version.h>
+
+#include "rsi_main.h"
+
+#define BB_READ 			0x0
+#define BB_WRITE 			0x1
+#define RF_READ 			0x2
+#define RF_WRITE 			0x3
+#define BT_PER_TRANSMIT 	0x4
+#define BT_RECEIVE 			0x5
+#define BUFFER_READ 		0x6
+#define BUFFER_WRITE 		0x7
+#define BT_PER_STATS 		0x8
+#define ANT_SEL 			0x9
+#define BT_BER_PKT_CNT 		0xA
+#define BT_BER_RECEIVE 		0xB
+#define BT_BER_MODE 		0xC
+#define BT_CW_MODE 			0xD 
+#define TX_STATUS 			0xE
+#define GET_DRV_COEX_MODE 	0xF
+
+/* RX frame types */
+#define RESULT_CONFIRM		0x80
+#define BT_PER 				0x10
+#define BT_BER 				0x11
+#define BT_CW 				0x12
+
+#define REQUIRED_HEADROOM_FOR_BT_HAL     16
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(3, 6, 11)
+# define get_portid(_info) (_info)->snd_pid
+#else
+# define get_portid(_info) (_info)->snd_portid
+#endif
+    
+enum {
+	RSI_USER_A_UNSPEC,
+	RSI_USER_A_MSG,
+	__RSI_USER_A_MAX,
+};
+
+enum {
+	RSI_USER_C_UNSPEC,
+	RSI_USER_C_CMD,
+	__RSI_USER_C_MAX,
+};
+
+enum {
+	BT_DEVICE_NOT_READY = 0,
+	BT_DEVICE_READY
+};
+
+struct rsi_hci_adapter {
+	struct rsi_common *priv;
+	struct hci_dev *hdev;
+	struct sk_buff_head hci_tx_queue;
+};
+
+/* TX BT command packet types */
+#define RSI_BT_PKT_TYPE_DEREGISTR		0x11
+#define RSI_BT_PKT_TYPE_RFMODE			0x55
+
+struct rsi_bt_cmd_frame {
+#ifdef __LITTLE_ENDIAN
+	u16 len:12;
+	u16 q_no:4;
+#else
+	u16 reserved1:4;
+	u16 q_no:12;
+#endif
+	__le16 reserved2[6];
+	u8 pkt_type;
+	u8 reserved3;
+};
+
+struct rsi_bt_rfmode_frame {
+	struct rsi_bt_cmd_frame desc;
+#ifdef __LITTLE_ENDIAN
+	u8 bt_rf_tx_power_mode:4;
+	u8 bt_rf_rx_power_mode:4;
+#else
+	u8 bt_rf_rx_power_mode:4;
+	u8 bt_rf_tx_power_mode:4;
+#endif
+	u8 reserved;
+};
+
+int rsi_hci_attach (struct rsi_common *common);
+void rsi_hci_detach(struct rsi_common *common);
+int rsi_hci_recv_pkt(struct rsi_common *common, u8 *pkt);
+
+#endif
diff --git a/drivers/net/wireless/rsi/rsi_main.h b/drivers/net/wireless/rsi/rsi_main.h
index dcd0957..ecdfdc8 100644
--- a/drivers/net/wireless/rsi/rsi_main.h
+++ b/drivers/net/wireless/rsi/rsi_main.h
@@ -1,17 +1,31 @@
-/**
- * Copyright (c) 2014 Redpine Signals Inc.
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
  *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
  *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
+ *
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
+ *
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #ifndef __RSI_MAIN_H__
@@ -20,55 +34,92 @@
 #include <linux/string.h>
 #include <linux/skbuff.h>
 #include <net/mac80211.h>
+#include <linux/etherdevice.h>
+#include <linux/version.h>
+
+struct rsi_hw;
 
-#define ERR_ZONE                        BIT(0)  /* For Error Msgs             */
-#define INFO_ZONE                       BIT(1)  /* For General Status Msgs    */
-#define INIT_ZONE                       BIT(2)  /* For Driver Init Seq Msgs   */
-#define MGMT_TX_ZONE                    BIT(3)  /* For TX Mgmt Path Msgs      */
-#define MGMT_RX_ZONE                    BIT(4)  /* For RX Mgmt Path Msgs      */
-#define DATA_TX_ZONE                    BIT(5)  /* For TX Data Path Msgs      */
-#define DATA_RX_ZONE                    BIT(6)  /* For RX Data Path Msgs      */
-#define FSM_ZONE                        BIT(7)  /* For State Machine Msgs     */
-#define ISR_ZONE                        BIT(8)  /* For Interrupt Msgs         */
-
-#define FSM_CARD_NOT_READY              0
-#define FSM_BOOT_PARAMS_SENT            1
-#define FSM_EEPROM_READ_MAC_ADDR        2
-#define FSM_RESET_MAC_SENT              3
-#define FSM_RADIO_CAPS_SENT             4
-#define FSM_BB_RF_PROG_SENT             5
-#define FSM_MAC_INIT_DONE               6
-
-extern u32 rsi_zone_enabled;
+#include "rsi_ps.h"
+
+#define DRV_VER				"RS9113.NBZ.NL.GNU.LNX.1.4.RC1"
+
+#define ERR_ZONE                        BIT(0) /* Error Msgs		*/
+#define INFO_ZONE                       BIT(1) /* Generic Debug Msgs	*/
+#define INIT_ZONE                       BIT(2) /* Driver Init Msgs	*/
+#define MGMT_TX_ZONE                    BIT(3) /* TX Mgmt Path Msgs	*/
+#define MGMT_RX_ZONE                    BIT(4) /* RX Mgmt Path Msgs	*/
+#define DATA_TX_ZONE                    BIT(5) /* TX Data Path Msgs	*/
+#define DATA_RX_ZONE                    BIT(6) /* RX Data Path Msgs	*/
+#define FSM_ZONE                        BIT(7) /* State Machine Msgs	*/
+#define ISR_ZONE                        BIT(8) /* Interrupt Msgs	*/
+
+#define FSM_FW_NOT_LOADED		0
+#define FSM_CARD_NOT_READY              1
+#define FSM_COMMON_DEV_PARAMS_SENT	2
+#define FSM_BOOT_PARAMS_SENT            3
+#define FSM_EEPROM_READ_MAC_ADDR        4
+#define FSM_EEPROM_READ_RF_TYPE		5
+#define FSM_RESET_MAC_SENT              6
+#define FSM_RADIO_CAPS_SENT             7
+#define FSM_BB_RF_PROG_SENT             8
+#define FSM_MAC_INIT_DONE               9
+
+extern u16 rsi_zone_enabled;
 extern __printf(2, 3) void rsi_dbg(u32 zone, const char *fmt, ...);
+void rsi_hex_dump(u32 zone, char *msg_str, const u8 *msg, u32 len);
 
-#define RSI_MAX_VIFS                    1
+#define RSI_MAX_VIFS                    3
 #define NUM_EDCA_QUEUES                 4
 #define IEEE80211_ADDR_LEN              6
 #define FRAME_DESC_SZ                   16
 #define MIN_802_11_HDR_LEN              24
+#define FLAGS				5
 
 #define DATA_QUEUE_WATER_MARK           400
 #define MIN_DATA_QUEUE_WATER_MARK       300
+#define BK_DATA_QUEUE_WATER_MARK	600
+#define BE_DATA_QUEUE_WATER_MARK	3200
+#define VI_DATA_QUEUE_WATER_MARK	3900
+#define VO_DATA_QUEUE_WATER_MARK	4500
 #define MULTICAST_WATER_MARK            200
 #define MAC_80211_HDR_FRAME_CONTROL     0
 #define WME_NUM_AC                      4
-#define NUM_SOFT_QUEUES                 5
-#define MAX_HW_QUEUES                   8
+#define NUM_SOFT_QUEUES                 6
+#define MAX_HW_QUEUES                   12
 #define INVALID_QUEUE                   0xff
 #define MAX_CONTINUOUS_VO_PKTS          8
 #define MAX_CONTINUOUS_VI_PKTS          4
+#define MGMT_HW_Q			10 /* Queue No 10 is used for
+					    * MGMT_QUEUE in Device FW,
+					    *  Hence this is Reserved
+					    */
+#define BROADCAST_HW_Q			9
+#define BEACON_HW_Q			11
 
 /* Queue information */
+#define RSI_COEX_Q			0x0
+#define RSI_ZIGB_Q			0x1
+#define RSI_BT_Q			0x2
+#define RSI_WLAN_Q			0x3
 #define RSI_WIFI_MGMT_Q                 0x4
 #define RSI_WIFI_DATA_Q                 0x5
+#define RSI_BT_MGMT_Q			0x6
+#define RSI_BT_DATA_Q			0x7
 #define IEEE80211_MGMT_FRAME            0x00
 #define IEEE80211_CTL_FRAME             0x04
 
+#define RSI_MAX_ASSOC_STAS		32
+#define RSI_MAX_COEX_ASSOC_STAS		4
 #define IEEE80211_QOS_TID               0x0f
 #define IEEE80211_NONQOS_TID            16
 
-#define MAX_DEBUGFS_ENTRIES             4
+#if defined(CONFIG_RSI_11K) && defined(RSI_DEBUG_RRM)
+#define MAX_DEBUGFS_ENTRIES             8
+#else
+#define MAX_DEBUGFS_ENTRIES             5
+#endif
+#define MAX_BGSCAN_CHANNELS		38
+
 
 #define TID_TO_WME_AC(_tid) (      \
 	((_tid) == 0 || (_tid) == 3) ? BE_Q : \
@@ -82,11 +133,23 @@
 	((_q) == VI_Q) ? IEEE80211_AC_VI : \
 	IEEE80211_AC_VO)
 
+/* WoWLAN flags */
+#define RSI_WOW_ENABLED			BIT(0)
+#define RSI_WOW_NO_CONNECTION		BIT(1)
+
+#define MAX_REG_COUNTRIES		30
+#define NL80211_DFS_WORLD		4
+
 struct version_info {
 	u16 major;
 	u16 minor;
-	u16 release_num;
-	u16 patch_num;
+	u8 release_num;
+	u8 patch_num;
+	union {
+		struct {
+			u8 fw_ver[8];
+		} info;
+	} ver;
 } __packed;
 
 struct skb_info {
@@ -95,14 +158,17 @@ struct skb_info {
 	u16 channel;
 	s8 tid;
 	s8 sta_id;
+	u8 internal_hdr_size;
+	struct ieee80211_sta *sta;
 };
 
 enum edca_queue {
-	BK_Q,
+	BK_Q = 0,
 	BE_Q,
 	VI_Q,
 	VO_Q,
-	MGMT_SOFT_Q
+	MGMT_SOFT_Q,
+	MGMT_BEACON_Q
 };
 
 struct security_info {
@@ -119,14 +185,18 @@ struct wmm_qinfo {
 };
 
 struct transmit_q_stats {
-	u32 total_tx_pkt_send[NUM_EDCA_QUEUES + 1];
-	u32 total_tx_pkt_freed[NUM_EDCA_QUEUES + 1];
+	u32 total_tx_pkt_send[NUM_EDCA_QUEUES + 2];
+	u32 total_tx_pkt_freed[NUM_EDCA_QUEUES + 2];
 };
 
 struct vif_priv {
 	bool is_ht;
 	bool sgi;
 	u16 seq_start;
+	u8 vap_id;
+	struct ieee80211_key_conf *key;
+	u8 rx_bcmc_pn[IEEE80211_CCMP_PN_LEN];
+	bool rx_pn_valid;
 };
 
 struct rsi_event {
@@ -134,6 +204,11 @@ struct rsi_event {
 	wait_queue_head_t event_queue;
 };
 
+enum {
+	ZB_DEVICE_NOT_READY = 0,
+	ZB_DEVICE_READY
+};
+
 struct rsi_thread {
 	void (*thread_function)(void *);
 	struct completion completion;
@@ -148,6 +223,109 @@ struct cqm_info {
 	u32 rssi_hyst;
 };
 
+struct bgscan_config_params {
+	u16 bgscan_threshold;
+	u16 roam_threshold;
+	u16 bgscan_periodicity;
+	u8 num_user_channels;
+	u8 num_bg_channels;
+	u8 two_probe;
+	u16 active_scan_duration;
+	u16 passive_scan_duration;
+	u16 user_channels[MAX_BGSCAN_CHANNELS];
+	u16 channels2scan[MAX_BGSCAN_CHANNELS];
+};
+
+#ifdef RSI_DEBUG_RRM
+struct rsi_chload_meas_req_params {
+	u8 macid[ETH_ALEN];
+	u8 regulatory_class;
+	u8 channel_num;
+	u16 rand_interval;
+	u16 meas_duration;
+	u8 meas_req_mode;
+	u8 meas_type;
+};
+
+struct rsi_frame_meas_req_params {
+	u8 destid[ETH_ALEN];
+	u8 regulatory_class;
+	u8 channel_num;
+	u16 rand_interval;
+	u16 meas_duration;
+	u8 meas_req_mode;
+	u8 meas_type;
+	u8 frame_req_type;
+	u8 macid[ETH_ALEN];
+};
+
+struct rsi_beacon_meas_req_params {
+	u8 destid[ETH_ALEN];
+	u8 regulatory_class;
+	u8 channel_num;
+	u16 rand_interval;
+	u16 meas_duration;
+	u8 meas_req_mode;
+	u8 meas_type;
+	u8 meas_mode;
+	u8 bssid[ETH_ALEN];
+	char str[32];
+};
+#endif
+
+#ifdef CONFIG_RSI_11K
+struct rsi_meas_params {
+	u8 dialog_token;
+	u8 channel_num;
+	u8 meas_req_mode;
+	u8 meas_type;
+	u16 meas_duration;
+	u16 rand_interval;
+	u8 channel_width;
+	u8 regulatory_class;
+};
+
+struct rsi_frame_meas_params {
+	struct rsi_meas_params mp;
+	u8 frame_req_type;
+	u8 mac_addr[ETH_ALEN];
+};
+
+struct rsi_beacon_meas_params {
+	struct rsi_meas_params mp;
+	u8 meas_mode;
+	u8 mac_addr[ETH_ALEN];
+	u8 ssid_ie[32 + 2];
+	u8 bcn_rpt_info[64];
+	u8 rpt_detail;
+};
+#endif
+
+struct rsi_9116_features {
+	u8 pll_mode;
+	u8 rf_type;
+	u8 wireless_mode;
+	u8 afe_type;
+	u8 enable_ppe;
+	u8 dpd;
+	u32 sifs_tx_enable;
+	u32 ps_options;
+};
+
+struct xtended_desc {
+	u8 confirm_frame_type;
+	u8 retry_cnt;
+	u16 reserved;
+};
+
+struct rsi_sta {
+	struct ieee80211_sta *sta;
+	s16 sta_id;
+	u16 seq_no[IEEE80211_NUM_ACS];
+	u16 seq_start[IEEE80211_NUM_ACS];
+	bool start_tx_aggr[IEEE80211_NUM_TIDS];
+};
+
 struct rsi_hw;
 
 struct rsi_common {
@@ -155,19 +333,26 @@ struct rsi_common {
 	struct vif_priv vif_info[RSI_MAX_VIFS];
 
 	bool mgmt_q_block;
-	struct version_info driver_ver;
-	struct version_info fw_ver;
+	char driver_ver[32];
+	struct version_info lmac_ver;
 
 	struct rsi_thread tx_thread;
-	struct sk_buff_head tx_queue[NUM_EDCA_QUEUES + 1];
+#ifdef CONFIG_SDIO_INTR_POLL
+	struct rsi_thread sdio_intr_poll_thread;
+#endif
+	struct sk_buff_head tx_queue[NUM_EDCA_QUEUES + 2];
+
 	/* Mutex declaration */
 	struct mutex mutex;
+	struct mutex pslock;
 	/* Mutex used between tx/rx threads */
-	struct mutex tx_rxlock;
+	struct mutex tx_lock;
+	struct mutex rx_lock;
 	u8 endpoint;
 
 	/* Channel/band related */
 	u8 band;
+	u8 num_supp_bands;
 	u8 channel_width;
 
 	u16 rts_threshold;
@@ -183,13 +368,15 @@ struct rsi_common {
 
 	/* state related */
 	u32 fsm_state;
+	u8 bt_fsm_state;
+	u8 zb_fsm_state;
 	bool init_done;
 	u8 bb_rf_prog_count;
 	bool iface_down;
 
 	/* Generic */
 	u8 channel;
-	u8 *rx_data_pkt;
+	u8 *saved_rx_data_pkt;
 	u8 mac_id;
 	u8 radio_id;
 	u16 rate_pwr[20];
@@ -202,29 +389,225 @@ struct rsi_common {
 
 	/* bgscan related */
 	struct cqm_info cqm_info;
-
+	struct bgscan_config_params bgscan_info;
+	int bgscan_en;
+	u8  start_bgscan;
+	u8 bgscan_probe_req[1500];
+	int bgscan_probe_req_len;
+	u16 bgscan_seq_ctrl;
+	u8 mac80211_cur_channel;
 	bool hw_data_qs_blocked;
+	u8 driver_mode;
+	u8 coex_mode;
+	u16 oper_mode;
+	u8 ta_aggr;
+	u8 skip_fw_load;
+	u8 lp_ps_handshake_mode;
+	u8 ulp_ps_handshake_mode;
+	u8 uapsd_bitmap;
+	u8 rf_power_val;
+	u8 device_gpio_type;
+	u16 country_code;
+	u8 wlan_rf_power_mode;
+	u8 bt_rf_power_mode;
+	u8 obm_ant_sel_val;
+	u8 antenna_diversity;
+	u16 rf_pwr_mode;
+	char antenna_gain[2];
+	u8 host_wakeup_intr_enable;
+	u8 host_wakeup_intr_active_high;
+	int tx_power;
+	u8 ant_in_use;
+	bool suspend_in_prog;
+	bool hibernate_resume;
+	bool reinit_hw;
+	struct completion wlan_init_completion;
+#ifdef CONFIG_RSI_WOW
+	u8 wow_flags;
+#endif
+
+#if defined (CONFIG_RSI_BT_ALONE) || defined(CONFIG_RSI_COEX)
+	void *hci_adapter;
+#endif
+
+#ifdef CONFIG_RSI_COEX
+	void *coex_cb;
+#endif
+
+	/* AP mode related */
+	u8 beacon_enabled;
+	u16 beacon_interval;
+	u16 beacon_cnt;
+	u8 dtim_cnt;
+	u16 bc_mc_seqno;
+	struct rsi_sta stations[RSI_MAX_ASSOC_STAS + 1];
+	int num_stations;
+	int max_stations;
+	struct ieee80211_channel *ap_channel;
+	struct ieee80211_key_conf *key;
+	u8 eapol4_confirm;
+
+	/* Wi-Fi direct mode related */
+	bool p2p_enabled;
+	struct timer_list roc_timer;
+	struct ieee80211_vif *roc_vif;
+	int last_vap_type;
+	u8 last_vap_addr[6];
+	u8 last_vap_id;
+
+        struct semaphore tx_bus_lock;
+
+#ifdef CONFIG_HW_SCAN_OFFLOAD
+	struct cfg80211_scan_request *scan_request;
+	struct ieee80211_vif *scan_vif;
+	bool scan_in_prog;
+	struct workqueue_struct *scan_workqueue;
+	struct work_struct scan_work;
+	struct rsi_event chan_set_event;
+	struct rsi_event probe_cfm_event;
+	struct rsi_event chan_change_event;
+	struct rsi_event cancel_hw_scan_event;
+	struct timer_list scan_timer;
+	bool hw_scan_cancel;
+#endif
+	struct rsi_event mgmt_cfm_event;
+	void *zb_adapter;
+
+	/* 11k related */
+#ifdef RSI_DEBUG_RRM
+	struct rsi_chload_meas_req_params rrm_chload_params;
+	struct rsi_frame_meas_req_params rrm_frame_params;
+	struct rsi_beacon_meas_req_params rrm_beacon_params;
+#endif
+#ifdef CONFIG_RSI_11K
+	u8 num_pend_rrm_reqs;
+	struct sk_buff_head rrm_queue;
+	struct sk_buff *rrm_pending_frame;
+	struct rsi_meas_params chload_meas;
+	struct rsi_frame_meas_params frame_meas;
+	struct rsi_beacon_meas_params beacon_meas;
+#endif
+	struct rsi_9116_features w9116_features;
+	u16 dev_oper_mode[6];
+};
+
+enum host_intf {
+	RSI_HOST_INTF_SDIO = 0,
+	RSI_HOST_INTF_USB
+};
+
+enum rsi_dev_model {
+	RSI_DEV_9113 = 0,
+	RSI_DEV_9116
+};
+
+struct eepromrw_info {
+	u32 offset;
+	u32 length;
+	u8  write;
+	u16 eeprom_erase;
+	u8 data[480];
+};
+
+struct eeprom_read {
+	u16 length;
+	u16 off_set;
 };
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 7, 0))
+#define NUM_NL80211_BANDS	3
+#endif
+
 struct rsi_hw {
 	struct rsi_common *priv;
+	enum rsi_dev_model device_model;
 	struct ieee80211_hw *hw;
 	struct ieee80211_vif *vifs[RSI_MAX_VIFS];
 	struct ieee80211_tx_queue_params edca_params[NUM_EDCA_QUEUES];
+
 	struct ieee80211_supported_band sbands[NUM_NL80211_BANDS];
 
 	struct device *device;
-	u8 sc_nvifs;
-
+	int sc_nvifs;
+	enum host_intf rsi_host_intf;
+	enum ps_state ps_state;
+	struct rsi_ps_info ps_info;
+	spinlock_t ps_lock;
+	u32 isr_pending;
+	u32 usb_buffer_status_reg;
 #ifdef CONFIG_RSI_DEBUGFS
 	struct rsi_debugfs *dfsentry;
 	u8 num_debugfs_entries;
 #endif
+
+	char *fw_file_name;
+	struct timer_list bl_cmd_timer;
+	u8 blcmd_timer_expired;
+	u32 flash_capacity;
+	u32 tx_blk_size;
+	u32 common_hal_fsm;
+	u8 eeprom_init;
+	struct eepromrw_info eeprom;
+	u32 interrupt_status;
+
+	u8 dfs_region;
+	char country[2];
+	bool peer_notify;
 	void *rsi_dev;
-	int (*host_intf_read_pkt)(struct rsi_hw *adapter, u8 *pkt, u32 len);
-	int (*host_intf_write_pkt)(struct rsi_hw *adapter, u8 *pkt, u32 len);
+
+	struct rsi_host_intf_ops *host_intf_ops;
 	int (*check_hw_queue_status)(struct rsi_hw *adapter, u8 q_num);
-	int (*rx_urb_submit)(struct rsi_hw *adapter);
+	int (*rx_urb_submit)(struct rsi_hw *adapter, u8 ep_num);
 	int (*determine_event_timeout)(struct rsi_hw *adapter);
+	void (*process_isr_hci)(struct rsi_hw *adapter);
+	int  (*check_intr_status_reg)(struct rsi_hw *adapter);
+	u8 rrm_state;
+	u8 rrm_enq_state;
+	int drv_instance_index;
 };
+
+void rsi_print_version(struct rsi_common *common);
+struct rsi_host_intf_ops {
+	int (*read_pkt)(struct rsi_hw *adapter, u8 *pkt, u32 len);
+	int (*write_pkt)(struct rsi_hw *adapter, u8 *pkt, u32 len);
+	int (*master_access_msword)(struct rsi_hw *adapter, u16 ms_word);
+	int (*read_reg_multiple)(struct rsi_hw *adapter, u32 addr,
+				 u8 *data, u16 count);
+	int (*write_reg_multiple)(struct rsi_hw *adapter, u32 addr,
+				  u8 *data, u16 count);
+	int (*master_reg_read)(struct rsi_hw *adapter, u32 addr,
+			       u32 *read_buf, u16 size);
+	int (*master_reg_write)(struct rsi_hw *adapter,
+				unsigned long addr, unsigned long data,
+				u16 size);
+	int (*load_data_master_write)(struct rsi_hw *adapter, u32 addr,
+				      u32 instructions_size, u16 block_size,
+				      u8 *fw);
+	int (*ta_reset_ops)(struct rsi_hw *adapter);
+	int (*rsi_check_bus_status)(struct rsi_hw *adapter);
+	int (*check_hw_queue_status)(struct rsi_hw *adapter, u8 q_num);
+	int (*reinit_device)(struct rsi_hw *adapter);
+};
+
+struct rsi_proto_ops;
+
+enum host_intf rsi_get_host_intf(void *priv);
+void rsi_set_zb_context(void *priv, void *zb_context);
+void *rsi_get_zb_context(void *priv);
+struct rsi_proto_ops {
+	int (*coex_send_pkt)(void *priv, struct sk_buff *skb, u8 hal_queue);
+	enum host_intf (*get_host_intf)(void *priv);
+	void (*set_zb_context)(void *priv, void *context);
+	void *(*get_zb_context)(void *priv);
+	struct rsi_mod_ops *zb_ops;
+};
+struct rsi_mod_ops {
+	int (*attach)(void *priv, struct rsi_proto_ops *ops);
+	void (*detach)(void *priv);
+	int (*recv_pkt)(void *priv, u8 *msg);
+};
+
+#if defined(CONFIG_RSI_COEX) && defined(CONFIG_RSI_ZIGB)
+struct rsi_mod_ops *rsi_get_zb_ops(void);
+#endif
 #endif
diff --git a/drivers/net/wireless/rsi/rsi_mgmt.h b/drivers/net/wireless/rsi/rsi_mgmt.h
index 3741173..d62cceb 100644
--- a/drivers/net/wireless/rsi/rsi_mgmt.h
+++ b/drivers/net/wireless/rsi/rsi_mgmt.h
@@ -1,17 +1,31 @@
-/**
- * Copyright (c) 2014 Redpine Signals Inc.
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
  *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
  *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
+ *
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
+ *
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #ifndef __RSI_MGMT_H__
@@ -27,7 +41,7 @@
 
 #define RSI_11B_MODE                    0
 #define RSI_11G_MODE                    BIT(7)
-#define RETRY_COUNT                     8
+#define RETRY_COUNT                     15
 #define RETRY_LONG                      4
 #define RETRY_SHORT                     7
 #define WMM_SHORT_SLOT_TIME             9
@@ -37,19 +51,54 @@
 #define RSI_PAIRWISE_KEY                1
 #define RSI_GROUP_KEY                   2
 
+#define RSI_MAC_SUB_LEN                3
+
 /* EPPROM_READ_ADDRESS */
 #define WLAN_MAC_EEPROM_ADDR            40
 #define WLAN_MAC_MAGIC_WORD_LEN         0x01
 #define WLAN_HOST_MODE_LEN              0x04
 #define WLAN_FW_VERSION_LEN             0x08
 #define MAGIC_WORD                      0x5A
+#define WLAN_EEPROM_RFTYPE_ADDR		424
+
+/*WOWLAN RESUME WAKEUP TYPES*/
+#define	UNICAST_MAGIC_PKT       	BIT(0) 
+#define	BROADCAST_MAGICPKT      	BIT(1) 
+#define	EAPOL_PKT               	BIT(2) 
+#define	DISCONNECT_PKT          	BIT(3) 
+#define	HW_BMISS_PKT            	BIT(4) 
+#define INSERT_SEQ_IN_FW                BIT(2)
 
 /* Receive Frame Types */
-#define TA_CONFIRM_TYPE                 0x01
-#define RX_DOT11_MGMT                   0x02
-#define TX_STATUS_IND                   0x04
+enum rx_cmd_type {
+	CARD_READY_IND = 0x0,
+	TA_CONFIRM_TYPE = 0x01,
+	RX_DOT11_MGMT = 0x02,
+	RX_DOT11_DATA = 0x03,
+	TX_STATUS_IND = 0x04,
+	PS_NOTIFY_IND = 0x05,
+	SLEEP_NOTIFY_IND = 0x06,
+	DECRYPT_ERROR_IND = 0x07,
+	BEACON_EVENT_IND = 0x08,
+	DEBUG_IND = 0x09,
+	RX_MISC_IND = 0xa,
+	UNCONNECTED_PEER = 0xb,
+	HW_BMISS_EVENT = 0xc,
+	RATE_GC_TABLE_UPDATE = 0xd,
+	RADAR_DETECTED = 0x0e,
+	TSF_SYNC_CONFIRM = 0xc0,
+	ANTENNA_SELECT = 0xf,
+	RADIO_MEAS_RPT = 0x10,
+
+};
+
+#ifdef CONFIG_RSI_WOW
+#define WOW_MAX_FILTERS_PER_LIST 16
+#define WOW_PATTERN_SIZE 256
+#endif
+#define EAPOL4_CONFIRM			1
 #define PROBEREQ_CONFIRM                2
-#define CARD_READY_IND                  0x00
+#define NULLDATA_CONFIRM		3
 
 #define RSI_DELETE_PEER                 0x0
 #define RSI_ADD_PEER                    0x1
@@ -61,41 +110,47 @@
 #define BBP_REG_WRITE                   0
 #define RF_RESET_ENABLE                 BIT(3)
 #define RATE_INFO_ENABLE                BIT(0)
+#define MORE_DATA_PRESENT		BIT(1)
 #define RSI_BROADCAST_PKT               BIT(9)
+#define RSI_DESC_11G_MODE		BIT(7)
+#define RSI_DESC_REQUIRE_CFM_TO_HOST	BIT(10)
+#define ADD_DELTA_TSF_VAP_ID		BIT(11)
+#define FETCH_RETRY_CNT_FRM_HST		BIT(12)
 
 #define UPPER_20_ENABLE                 (0x2 << 12)
 #define LOWER_20_ENABLE                 (0x4 << 12)
 #define FULL40M_ENABLE                  0x6
-
+#define RSI_UAPSD_WAKEUP_PERIOD         0x1e
+#define RSI_DEFAULT_DTIM_INTERVAL       0x1
 #define RSI_LMAC_CLOCK_80MHZ            0x1
 #define RSI_ENABLE_40MHZ                (0x1 << 3)
 #define ENABLE_SHORTGI_RATE		BIT(9)
 
-#define RX_BA_INDICATION                1
-#define RSI_TBL_SZ                      40
-#define MAX_RETRIES                     8
-#define RSI_IFTYPE_STATION		 0
-
-#define STD_RATE_MCS7                   0x07
-#define STD_RATE_MCS6                   0x06
-#define STD_RATE_MCS5                   0x05
-#define STD_RATE_MCS4                   0x04
-#define STD_RATE_MCS3                   0x03
-#define STD_RATE_MCS2                   0x02
-#define STD_RATE_MCS1                   0x01
-#define STD_RATE_MCS0                   0x00
-#define STD_RATE_54                     0x6c
-#define STD_RATE_48                     0x60
-#define STD_RATE_36                     0x48
-#define STD_RATE_24                     0x30
-#define STD_RATE_18                     0x24
-#define STD_RATE_12                     0x18
-#define STD_RATE_11                     0x16
-#define STD_RATE_09                     0x12
-#define STD_RATE_06                     0x0C
-#define STD_RATE_5_5                    0x0B
-#define STD_RATE_02                     0x04
-#define STD_RATE_01                     0x02
+#define RX_BA_INDICATION		1
+#define RSI_TBL_SZ			40
+#define MAX_RETRIES			8
+#define RSI_IFTYPE_STATION		1
+
+#define STD_RATE_MCS7			0x07
+#define STD_RATE_MCS6			0x06
+#define STD_RATE_MCS5			0x05
+#define STD_RATE_MCS4			0x04
+#define STD_RATE_MCS3			0x03
+#define STD_RATE_MCS2			0x02
+#define STD_RATE_MCS1			0x01
+#define STD_RATE_MCS0			0x00
+#define STD_RATE_54			0x6c
+#define STD_RATE_48			0x60
+#define STD_RATE_36			0x48
+#define STD_RATE_24			0x30
+#define STD_RATE_18			0x24
+#define STD_RATE_12			0x18
+#define STD_RATE_11			0x16
+#define STD_RATE_09			0x12
+#define STD_RATE_06			0x0C
+#define STD_RATE_5_5			0x0B
+#define STD_RATE_02			0x04
+#define STD_RATE_01			0x02
 
 #define RSI_RF_TYPE                     1
 #define RSI_RATE_00                     0x00
@@ -138,11 +193,97 @@
 #define LONG_PREAMBLE			0x0000
 #define SHORT_PREAMBLE			0x0001
 
-#define RSI_SUPP_FILTERS	(FIF_ALLMULTI | FIF_PROBE_REQ |\
-				 FIF_BCN_PRBRESP_PROMISC)
+#define RSI_SUPP_FILTERS		(FIF_ALLMULTI | FIF_PROBE_REQ |\
+					 FIF_BCN_PRBRESP_PROMISC)
+
+#define ANTENNA_SEL_INT			0x02 /* RF_OUT_2 / Integerated */
+#define ANTENNA_SEL_UFL			0x03 /* RF_OUT_1 / U.FL */
+
+/* Power save handshake types */
+#define NO_HAND_SHAKE			0
+#define GPIO_HAND_SHAKE			1
+#define PACKET_HAND_SHAKE		2
+#define TA_GPIO				0
+#define ULP_GPIO			1
+#define RF_POWER_3_3			1
+#define RF_POWER_1_9			0
+
+/* Rx filter word definitions */
+#define PROMISCOUS_MODE			BIT(0)
+#define ALLOW_DATA_ASSOC_PEER		BIT(1)
+#define ALLOW_MGMT_ASSOC_PEER		BIT(2)
+#define ALLOW_CTRL_ASSOC_PEER		BIT(3)
+#define DISALLOW_BEACONS		BIT(4)
+#define ALLOW_CONN_PEER_MGMT_WHILE_BUF_FULL BIT(5)
+#define DISALLOW_BROADCAST_DATA		BIT(6)
+
+#define RSI_TXPOWER_MAX			30
+#define RSI_TXPOWER_MIN			-127
+
+#define DEEP_SLEEP			1
+#define CONNECTED_SLEEP			2
+
+#define SLEEP_REQUEST			1
+#define WAKEUP_REQUEST			2
+
+#define RSI_TXPOWER_MAX			30
+#define RSI_TXPOWER_MIN			-127
+
+#define IEEE80211_MARKALL_UAPSD_QUEUES \
+	(IEEE80211_WMM_IE_STA_QOSINFO_AC_VO | \
+	 IEEE80211_WMM_IE_STA_QOSINFO_AC_VI | \
+	 IEEE80211_WMM_IE_STA_QOSINFO_AC_BE | \
+	 IEEE80211_WMM_IE_STA_QOSINFO_AC_BK)
+
+/* Tx data frame format */
+#define MAC_BBP_INFO			BIT(0) 
+#define NO_ACK_IND			BIT(9)
+#define QOS_EN				BIT(12)
+/* frame type bit{11:10} */
+#define NORMAL_FRAME			0x00
+#define DTIM_BEACON_GATED_FRAME		BIT(10) 
+#define BEACON_FRAME			BIT(11)
+#define DTIM_BEACON			BIT(10) | BIT(11)
+#define INSERT_TSF			BIT(15)
+#define INSERT_SEQ_NO			BIT(2)
+
+#ifdef CONFIG_PM
+#define RSI_WOW_ANY			BIT(1)
+#define RSI_WOW_GTK_REKEY		BIT(3)
+#define RSI_WOW_MAGIC_PKT		BIT(4)
+#define RSI_WOW_DISCONNECT		BIT(5)
+#endif
+#define HOST_BG_SCAN_TRIG		BIT(4)
+#define TARGET_BOARD_CARACALLA		BIT(10)
+
 enum opmode {
+	UNKNOW_OPMODE = -1,
+	AP_OPMODE = 0,
 	STA_OPMODE = 1,
-	AP_OPMODE = 2
+	P2P_GO_OPMODE = 2,
+	P2P_CLIENT_OPMODE = 3
+};
+
+enum vap_status {
+	VAP_ADD = 1,
+	VAP_DELETE = 2,
+	VAP_UPDATE = 3
+};
+
+enum peer_type {
+	PEER_TYPE_AP,
+	PEER_TYPE_STA,
+	PEER_TYPE_P2P_GO,
+	PEER_TYPE_P2P_CLIENT,
+	PEER_TYPE_IBSS
+};
+
+/*
+ * Subtypes for RX_MISC_IND frame
+ * Frame sub types from LMAC to Host
+ */
+enum rx_misc_ind_subtype {
+	FW_UPGRADE_REQ
 };
 
 extern struct ieee80211_rate rsi_rates[12];
@@ -159,38 +300,72 @@ enum sta_notify_events {
 
 /* Send Frames Types */
 enum cmd_frame_type {
-	TX_DOT11_MGMT,
-	RESET_MAC_REQ,
-	RADIO_CAPABILITIES,
-	BB_PROG_VALUES_REQUEST,
-	RF_PROG_VALUES_REQUEST,
-	WAKEUP_SLEEP_REQUEST,
-	SCAN_REQUEST,
-	TSF_UPDATE,
-	PEER_NOTIFY,
-	BLOCK_HW_QUEUE,
-	SET_KEY_REQ,
-	AUTO_RATE_IND,
-	BOOTUP_PARAMS_REQUEST,
-	VAP_CAPABILITIES,
-	EEPROM_READ_TYPE ,
-	EEPROM_WRITE,
-	GPIO_PIN_CONFIG ,
-	SET_RX_FILTER,
-	AMPDU_IND,
-	STATS_REQUEST_FRAME,
-	BB_BUF_PROG_VALUES_REQ,
-	BBP_PROG_IN_TA,
-	BG_SCAN_PARAMS,
-	BG_SCAN_PROBE_REQ,
-	CW_MODE_REQ,
-	PER_CMD_PKT
+	TX_DOT11_MGMT = 0,
+	RESET_MAC_REQ, /* 0x1 */
+	RADIO_CAPABILITIES, /* 0x2 */
+	BB_PROG_VALUES_REQUEST, /* 0x3 */
+	RF_PROG_VALUES_REQUEST, /* 0x4 */
+	WAKEUP_SLEEP_REQUEST, /* 0x5 */
+	SCAN_REQUEST, /* 0x6 */
+	TSF_UPDATE, /* 0x7 */
+	PEER_NOTIFY, /* 0x8 */
+	BLOCK_HW_QUEUE, /* 0x9 */
+	SET_KEY_REQ, /* 0xA */
+	AUTO_RATE_IND, /* 0xB */
+	BOOTUP_PARAMS_REQUEST, /* 0xC */
+	VAP_CAPABILITIES, /* 0xD */
+	EEPROM_READ, /* 0xE */
+	EEPROM_WRITE, /* 0xF */
+	GPIO_PIN_CONFIG, /* 0x10 */
+	SET_RX_FILTER, /* 0x11 */
+	AMPDU_IND, /* 0x12 */
+	STATS_REQUEST, /* 0x13 */
+	BB_BUF_PROG_VALUES_REQ, /* 0x14 */
+	BBP_PROG_IN_TA, /* 0x15 */
+	BG_SCAN_PARAMS, /* 0x16 */
+	BG_SCAN_PROBE_REQ, /* 0x17 */
+	CW_MODE_REQ, /* 0x18 */
+	PER_CMD_PKT, /* 0x19 */
+	DEV_SLEEP_REQUEST, /* 0x1A */
+	DEV_WAKEUP_CNF,  /* 0x1B */
+	RF_LOOPBACK_REQ, /* 0x1C */
+	RF_LPBK_M3,  /* 0x1D */
+	RF_RESET_FRAME,  /* 0x1E */
+	LMAC_REG_OPS,  /* 0x1F */
+	ANT_SEL_FRAME, /* 0x20 */
+	CONFIRM, /* 0x21 */
+	WLAN_DE_REGISTER, /* 0x22 */
+	DEBUG_FRAME,  /* 0x23 */
+	HW_BMISS_HANDLE, /* 0x24 */
+	MULTICAST_ENABLE, /* 0x25 */
+	TX_MISC_IND, /* 0x26 */
+	VAP_DYNAMIC_UPDATE, /* 0x27 */
+	COMMON_DEV_CONFIG, /* 0x28 */
+	RADIO_PARAMS_UPDATE, /* 0x29 */
+	RADAR_REQUEST, /* 0x2A */
+	WOWLAN_CONFIG_PARAMS, /* 0x2B */
+	IAP_CONFIG, /* 0x2C */
+	RADIO_MEASUREMENT_REQ, /* 0x2D */
+	FEATURES_ENABLE = 0x33,
+	WOWLAN_WAKEUP_REASON = 0xc5 /* 0xC5 */
 };
 
+struct reg_class {
+	u8 op_class;
+	u8 bandwidth;
+	u16 chans[20];
+};
+
+/* RSI Command packet formats */
 struct rsi_mac_frame {
 	__le16 desc_word[8];
 } __packed;
 
+struct rsi_boot_params_9116 {
+	__le16 desc_word[8];
+	struct bootup_params_9116 bootup_params;
+} __packed;
+
 struct rsi_boot_params {
 	__le16 desc_word[8];
 	struct bootup_params bootup_params;
@@ -219,6 +394,39 @@ struct rsi_vap_caps {
 	__le32 default_data_rate;
 	__le16 beacon_interval;
 	__le16 dtim_period;
+	__le16 beacon_miss_threshold;
+} __packed;
+
+struct rsi_dynamic_s {
+	__le16 desc_word[8];
+
+	struct framebody {
+		__le16 data_rate;
+		__le16 mgmt_rate;
+		__le16 keep_alive_period;
+	} frame_body;
+} __packed;
+
+#define RSI_MAX_BGS_PROBEREQ_LEN	120
+struct rsi_bgscan_params {
+	__le16 desc_word[8];
+	__le16 bgscan_threshold;
+	__le16 roam_threshold;
+	__le16 bgscan_periodicity;
+	u8 num_bg_channels;
+	u8 two_probe;
+	__le16 active_scan_duration;
+	__le16 passive_scan_duration;
+	__le16 channels2scan[MAX_BGSCAN_CHANNELS];
+} __packed;
+
+struct rsi_bgscan_probe {
+	__le16 desc_word[8];
+	__le16 mgmt_rate;
+	__le16 flags;
+	__le16 channel_num;
+	__le16 channel_scan_time;
+	__le16 probe_req_length;
 } __packed;
 
 struct rsi_set_key {
@@ -261,6 +469,110 @@ struct rsi_radio_caps {
 	__le16 preamble_type;
 } __packed;
 
+struct rsi_ulp_gpio_vals {
+	u8 motion_sensor_gpio_ulp_wakeup : 1;
+	u8 sleep_ind_from_device : 1;
+	u8 ulp_gpio_2 :1;
+	u8 push_button_ulp_wakeup : 1;
+	u8 reserved : 4;
+} __packed;
+
+struct rsi_soc_gpio_vals {
+	u32 pspi_csn_0 : 1;
+	u32 pspi_csn_1 : 1;
+	u32 host_wakeup_intr :1;
+	u32 pspi_data_0 : 1;
+	u32 pspi_data_1 : 1;
+	u32 pspi_data_2 : 1;
+	u32 pspi_data_3 : 1;
+	u32 i2c_scl :1;
+	u32 i2c_sda   :1;
+	u32 uart1_rx :1;
+	u32 uart1_tx  :1;
+	u32 uart1_rts_i2s_clk :1;
+	u32 uart1_cts_i2s_ws :1;
+	u32 dbg_uart_rx_i2s_din :1;
+	u32 dbg_uart_tx_i2s_dout :1;
+	u32 lp_wakeup_boot_bypass :1;
+	u32 led_0 :1;
+	u32 btcoex_wlan_active_ext_pa_ant_sel_A :1;
+	u32 btcoex_bt_priority_ext_pa_ant_sel_B :1;
+	u32 btcoex_bt_active_ext_pa_on_off :1;
+	u32 rf_reset :1;
+	u32 sleep_ind_from_device :1;
+} __packed;
+
+struct rsi_config_vals {
+	u16 desc_word[8];
+	u8 lp_ps_handshake;
+	u8 ulp_ps_handshake;
+	u8 sleep_config_params; /* 0 for no handshake,
+				 * 1 for GPIO based handshake,
+				 * 2 packet handshake
+				 */
+	u8 unused_ulp_gpio;
+	u32 unused_soc_gpio_bitmap;
+	u8 ext_pa_or_bt_coex_en;
+	u8 opermode;
+	u8 wlan_rf_pwr_mode;
+	u8 bt_rf_pwr_mode;
+	u8 zigbee_rf_pwr_mode;
+	u8 driver_mode;
+	u8 region_code;
+	u8 antenna_sel_val;
+	u8 reserved[16];
+} __packed;
+
+struct rsi_request_ps {
+	u16 desc_word[8];
+	struct ps_sleep_params ps_sleep;
+	u8 ps_mimic_support;
+	u8 ps_uapsd_acs;
+	u8 ps_uapsd_wakeup_period;
+	u8 reserved;
+	u32 ps_listen_interval;
+	u32 ps_dtim_interval_duration;
+	u16 ps_num_dtim_intervals;
+} __packed;
+
+struct rsi_wowlan_req { 
+	__le16 desc_word[8];
+	u8 sourceid[ETH_ALEN];
+	u16 wow_flags;
+	u16 host_sleep_status;
+} __packed;
+
+struct rsi_bcn_meas_req {
+	__le16 desc_word[8];
+	u8 bssid[ETH_ALEN];
+	u8 ssid[32];
+	u8 rep_detail;
+	u8 meas_mode;
+	u8 bgscan_probe[0];
+} __packed;
+
+struct rsi_frame_meas_req {
+	__le16 desc_word[8];
+	u8 bssid[ETH_ALEN];
+	u8 frm_req_type;
+} __packed;
+
+#define RSI_DUTY_CYCLING	BIT(0)
+#define RSI_END_OF_FRAME	BIT(1)
+#define RSI_SIFS_TX_ENABLE	BIT(2)
+#define RSI_DPD			BIT(3)
+struct rsi_wlan_9116_features {
+	__le16 desc_word[8];
+	u8 pll_mode;
+	u8 rf_type;
+	u8 wireless_mode;
+	u8 enable_ppe;
+	u8 afe_type;
+	u8 reserved1;
+	__le16 reserved2;
+	__le32 feature_enable;
+};
+
 static inline u32 rsi_get_queueno(u8 *addr, u16 offset)
 {
 	return (le16_to_cpu(*(__le16 *)&addr[offset]) & 0x7000) >> 12;
@@ -287,17 +599,26 @@ static inline u8 rsi_get_channel(u8 *addr)
 }
 
 int rsi_mgmt_pkt_recv(struct rsi_common *common, u8 *msg);
-int rsi_set_vap_capabilities(struct rsi_common *common, enum opmode mode);
-int rsi_send_aggregation_params_frame(struct rsi_common *common, u16 tid,
-				      u16 ssn, u8 buf_size, u8 event);
-int rsi_hal_load_key(struct rsi_common *common, u8 *data, u16 key_len,
-		     u8 key_type, u8 key_id, u32 cipher);
-int rsi_set_channel(struct rsi_common *common, u16 chno);
+int rsi_set_vap_capabilities(struct rsi_common *common, enum opmode mode,
+			     u8 *mac_addr, u8 vap_id, u8 vap_status);
+int rsi_send_aggr_params_frame(struct rsi_common *common, u16 tid,
+			       u16 ssn, u8 buf_size, u8 event, u8 sta_id);
+int rsi_load_key(struct rsi_common *common, u8 *data, u16 key_len,
+		 u8 key_type, u8 key_id, u32 cipher, s16 sta_id);
+int rsi_set_channel(struct rsi_common *common,
+		    struct ieee80211_channel *channel);
+int rsi_send_vap_dynamic_update(struct rsi_common *common);
 int rsi_send_block_unblock_frame(struct rsi_common *common, bool event);
-void rsi_inform_bss_status(struct rsi_common *common, u8 status,
-			   const u8 *bssid, u8 qos_enable, u16 aid);
+void rsi_inform_bss_status(struct rsi_common *common, enum opmode opmode,
+			   u8 status, const u8 *bssid, u8 qos_enable, u16 aid,
+			   struct ieee80211_sta *sta, u16 sta_id, u16 assoc_cap);
+int rsi_send_sta_notify_frame(struct rsi_common *common, enum opmode opmode,
+			      u8 notify_event, const unsigned char *bssid,
+			      u8 qos_enable, u16 aid, u16 sta_id);
 void rsi_indicate_pkt_to_os(struct rsi_common *common, struct sk_buff *skb);
 int rsi_mac80211_attach(struct rsi_common *common);
+int rsi_send_bgscan_params(struct rsi_common *common, int enable);
+int rsi_send_bgscan_probe_req(struct rsi_common *common);
 void rsi_indicate_tx_status(struct rsi_hw *common, struct sk_buff *skb,
 			    int status);
 bool rsi_is_cipher_wep(struct rsi_common *common);
@@ -305,5 +626,40 @@ void rsi_indicate_tx_status(struct rsi_hw *common, struct sk_buff *skb,
 void rsi_core_xmit(struct rsi_common *common, struct sk_buff *skb);
 int rsi_send_mgmt_pkt(struct rsi_common *common, struct sk_buff *skb);
 int rsi_send_data_pkt(struct rsi_common *common, struct sk_buff *skb);
-int rsi_band_check(struct rsi_common *common);
+int rsi_send_beacon(struct rsi_common *common);
+int rsi_send_pkt(struct rsi_common *common, struct sk_buff *skb);
+int rsi_band_check(struct rsi_common *common, struct ieee80211_channel *chan);
+int rsi_send_rx_filter_frame(struct rsi_common *common, u16 rx_filter_word);
+int rsi_flash_read(struct rsi_hw *adapter);
+int rsi_program_bb_rf(struct rsi_common *common);
+int rsi_send_radio_params_update(struct rsi_common *common);
+void init_bgscan_params(struct rsi_common *common);
+int rsi_set_antenna(struct rsi_common *common, u8 antenna);
+int rsi_hci_attach(struct rsi_common *common);
+int rsi_handle_card_ready(struct rsi_common *common, u8 *msg);
+void rsi_validate_bgscan_channels(struct rsi_hw *adapter,
+				  struct bgscan_config_params *params);
+#ifdef CONFIG_RSI_WOW
+int rsi_send_wowlan_request(struct rsi_common *common, u16 flags,
+			    u16 sleep_status);
+#endif
+void rsi_scan_start(struct work_struct *data);
+#ifdef CONFIG_HW_SCAN_OFFLOAD
+int rsi_send_probe_request(struct rsi_common *common, 
+			   struct cfg80211_scan_request *scan_req, u8 n_ssid,
+			   u8 channel, u8 scan_type);
+#endif
+#ifdef CONFIG_CARACALLA_BOARD
+void rsi_apply_carcalla_power_values(struct rsi_hw *adapter,
+				     struct ieee80211_vif *vif,
+				     struct ieee80211_channel *channel);
+#endif
+#ifdef CONFIG_RSI_11K
+int rsi_get_channel_load_meas(struct rsi_common *common,
+			      struct rsi_meas_params params);
+int rsi_get_frame_meas(struct rsi_common *common,
+		       struct rsi_frame_meas_params params);
+int rsi_get_beacon_meas(struct rsi_common *common,
+			struct rsi_beacon_meas_params params);
+#endif
 #endif
diff --git a/drivers/net/wireless/rsi/rsi_ps.h b/drivers/net/wireless/rsi/rsi_ps.h
new file mode 100644
index 0000000..e10082c
--- /dev/null
+++ b/drivers/net/wireless/rsi/rsi_ps.h
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
+ *
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
+ *
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __RSI_PS_H__
+#define __RSI_PS_H__
+
+#define PS_CONFIRM_INDEX	12
+
+enum ps_state {
+	PS_NONE = 0,
+	PS_ENABLE_REQ_SENT = 1,
+	PS_DISABLE_REQ_SENT = 2,
+	PS_ENABLED = 3
+};
+
+struct ps_sleep_params {
+	u8 enable;
+	u8 sleep_type; //LP or ULP type
+	u8 connected_sleep;
+	u8 reserved1;
+	u16 num_bcns_per_lis_int;
+	u16 wakeup_type;
+	u32 sleep_duration;
+} __packed;
+
+struct rsi_ps_info {
+	u8 enabled;
+	u8 sleep_type;
+	u8 tx_threshold;
+	u8 rx_threshold;
+	u8 tx_hysterisis;
+	u8 rx_hysterisis;
+	u16 monitor_interval;
+	u32 listen_interval;
+	u16 num_bcns_per_lis_int;
+	u32 dtim_interval_duration;
+	u16 num_dtims_per_sleep;
+	u32 deep_sleep_wakeup_period;
+} __packed;
+
+char *str_psstate(enum ps_state state);
+void rsi_enable_ps(struct rsi_hw *adapter);
+void rsi_disable_ps(struct rsi_hw *adapter);
+int rsi_handle_ps_confirm(struct rsi_hw *adapter, u8 *msg);
+void rsi_default_ps_params(struct rsi_hw *hw);
+int rsi_send_ps_request(struct rsi_hw *adapter, bool enable);
+void rsi_conf_uapsd(struct rsi_hw *adapter);
+
+#endif
diff --git a/drivers/net/wireless/rsi/rsi_rrm.h b/drivers/net/wireless/rsi/rsi_rrm.h
new file mode 100644
index 0000000..b5dba69
--- /dev/null
+++ b/drivers/net/wireless/rsi/rsi_rrm.h
@@ -0,0 +1,220 @@
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
+ *
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
+ *
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __RSI_RRM_H__
+#define __RSI_RRM_H__
+
+#include "rsi_main.h"
+
+#define RRM_MIN_CHLOAD_FRM_LEN			6
+#define RRM_MIN_FRM_REQ_LEN			13
+#define RRM_MIN_BEACON_FRM_LEN			13
+
+#define MAX_RRM_REQ				5
+
+/* RRM FSM States */
+#define RRM_IDLE				0
+#define RRM_REQ_SENT				1
+#define RRM_RESP_RCVD				2
+
+#define MAX_OPT_SUB_ELM_SIZE			128
+#define DRV_HDR_SIZE				(FRAME_DESC_SZ + 64)
+
+#define WLAN_ACTION_RADIO_MEASUREMENT		5
+#define WLAN_ACTION_SPECTRUM_MANAGEMENT		0
+#define MEAS_REQ				38
+#define MEAS_RPT				39
+
+/* 11k Actions */
+#define IEEE80211_ACTION_RADIO_MEAS_REQ		0
+#define IEEE80211_ACTION_RADIO_MEAS_RPT		1
+#define IEEE80211_ACTION_LINK_MEAS_REQ		2
+#define IEEE80211_ACTION_LINK_MEAS_REP		3
+#define IEEE80211_ACTION_NG_RPT_REQ		4
+#define IEEE80211_ACTION_NG_RPT_RSP		5
+
+struct ieee80211_basic_hdr {
+	__le16 frame_control;
+	__le16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 addr3[ETH_ALEN];
+	__le16 seq_ctrl;
+} __packed;
+
+/* Radio Measurement types */
+#define RRM_TYPE_CHANNEL_LOAD			3
+#define RRM_TYPE_FRAME				6
+#define RRM_TYPE_BEACON				5
+
+/* Element ID Fields  */
+#define SSID_ELEM_ID				0
+#define SSID_LEN				32
+#define BEACON_REPORT_INFO			1
+#define REPORTING_DETAIL			2
+#define AP_CHANNEL_RPT				51
+#define VENDOR_SPECIFIC				221
+
+#define MAX_REGIONS				4
+#define MAX_REG_CLASS				255
+#define RSI_BW_5				5
+#define RSI_BW_10				10
+#define RSI_BW_20				20
+#define RSI_BW_25				25
+#define RSI_BW_40				40
+
+struct dot11_elem {
+	u8 elem_id;
+	u8 elem_len;
+	u8 elem_data[0];
+} __packed;
+
+struct wl_action {
+	u8 category;
+	u8 action;
+	u8 dialog_token;
+};
+
+struct wl_action_req {
+	u8 category;
+	u8 action;
+	u8 dialog_token;
+	u16 num_repetitions;
+} __packed;
+
+struct rm_element {
+	u8 element_id;
+	u8 length;
+	u8 token;
+	u8 mode;
+	u8 type;
+} __packed;
+
+struct dot11_radio_meas_req {
+	struct ieee80211_basic_hdr mac_hdr;
+	struct wl_action_req action_body;
+	struct rm_element rmelem;
+	u8 regulatory_class;
+	u8 channel_num;
+	u16 rand_int;
+	u16 meas_duration;
+} __packed;
+
+struct dot11_frame_meas_req {
+	struct ieee80211_basic_hdr mac_hdr;
+	struct wl_action_req action_body;
+	struct rm_element rmelem;
+	u8 regulatory_class;
+	u8 channel_num;
+	u16 rand_int;
+	u16 meas_duration;
+	u8 frame_req_type;
+	u8 macid[6];
+} __packed;
+
+struct dot11_beacon_meas_req {
+	struct ieee80211_basic_hdr mac_hdr;
+	struct wl_action_req action_body;
+	struct rm_element rmelem;
+	u8 regulatory_class;
+	u8 channel_num;
+	u16 rand_int;
+	u16 meas_duration;
+	u8 meas_mode;
+	u8 bssid[6];
+	u8 opt_elems[0];
+} __packed;
+
+struct channel_load_rpt {
+	struct ieee80211_basic_hdr mac_hdr;
+	struct wl_action action_body;
+	struct rm_element rmelem;
+	u8 regulatory_class;
+	u8 channel_num;
+	u64 actual_meas_start_time;
+	u16 meas_duration;
+	u8 channel_load;
+} __packed;
+
+struct frame_report {
+	struct ieee80211_basic_hdr mac_hdr;
+	struct wl_action action_body;
+	struct rm_element rmelem;
+	u8 regulatory_class;
+	u8 channel_num;
+	u64 actual_meas_start_time;
+	u16 meas_duration;
+
+	/* optional subelements */
+	u8 elem_id;
+	u8 length;
+	u8 tx_addr[6];
+	u8 bssid[6];
+	u8 phy_type;
+	u8 avg_rcpi;
+	u8 last_rsni;
+	u8 last_rcpi;
+	u8 ant_id;
+	u16 frame_count;
+} __packed;
+
+struct beacon_report {
+	struct ieee80211_basic_hdr mac_hdr;
+	struct wl_action action_body;
+	struct rm_element rmelem;
+	u8 regulatory_class;
+	u8 channel_num;
+	u64 actual_meas_start_time;
+	u16 meas_duration;
+	u8 reported_frame_info;
+	u8 rcpi;
+	u8 rsni;
+	u8 bssid[6];
+	u8 antenna_id;
+	u32 parent_tsf;
+} __packed;
+
+int rsi_rrm_send_channel_load_req(struct rsi_common *common);
+int rsi_rrm_send_frame_req(struct rsi_common *common);
+int rsi_rrm_send_beacon_req(struct rsi_common *common);
+int rsi_rrm_parse_radio_action_frame(struct rsi_common *common, u8 *rx_rrm,
+				     s32 msg_len);
+int rsi_rrm_parse_spectrum_action_frame(struct rsi_common *common,
+					struct ieee80211_hdr *tmp_hdr,
+					u8 *data);
+int rsi_rrm_parse_channel_load_req(struct rsi_common *common,
+				   struct sk_buff *skb,
+				   struct rsi_meas_params *params);
+int rsi_rrm_sched_req(struct rsi_common *common);
+void rsi_rrm_recv_cmd_frame(struct rsi_common *common, u8 *msg, int len);
+int rsi_prepare_channel_load_rpt(struct rsi_common *common, u8 *msg, int len);
+int rsi_prepare_frame_rpt(struct rsi_common *common, u8 *msg, int len);
+int rsi_prepare_beacon_rpt(struct rsi_common *common, u8 *msg, int len);
+#endif
diff --git a/drivers/net/wireless/rsi/rsi_sdio.h b/drivers/net/wireless/rsi/rsi_sdio.h
index c7e8f2b..44d56af 100644
--- a/drivers/net/wireless/rsi/rsi_sdio.h
+++ b/drivers/net/wireless/rsi/rsi_sdio.h
@@ -1,19 +1,31 @@
-/**
- * @section LICENSE
- * Copyright (c) 2014 Redpine Signals Inc.
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
  *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
  *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
  *
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
+ *
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #ifndef __RSI_SDIO_INTF__
@@ -28,38 +40,43 @@
 #include <linux/mmc/sdio_ids.h>
 #include "rsi_main.h"
 
-enum sdio_interrupt_type {
-	BUFFER_FULL         = 0x0,
-	BUFFER_AVAILABLE    = 0x2,
-	FIRMWARE_ASSERT_IND = 0x3,
-	MSDU_PACKET_PENDING = 0x4,
-	UNKNOWN_INT         = 0XE
-};
+/* SDIO VENDOR ID for RSI*/
+#define SDIO_VENDOR_ID_RSI              0x041B
+
+/* Device ID for RS9113 */
+#define SDIO_DEVICE_ID_RSI_9113         0x9330
+/* Device ID for RS9116 */
+#define SDIO_DEVICE_ID_RSI_9116         0x9116
 
-/* Buffer status register related info */
-#define PKT_BUFF_SEMI_FULL                      0
-#define PKT_BUFF_FULL                           1
-#define PKT_MGMT_BUFF_FULL                      2
-#define MSDU_PKT_PENDING                        3
 /* Interrupt Bit Related Macros */
-#define PKT_BUFF_AVAILABLE                      1
-#define FW_ASSERT_IND                           2
+#define PKT_BUFF_AVAILABLE		1
+#define FW_ASSERT_IND			2
+
+#define RSI_MASTER_REG_BUF_SIZE		12
 
-#define RSI_DEVICE_BUFFER_STATUS_REGISTER       0xf3
-#define RSI_FN1_INT_REGISTER                    0xf9
-#define RSI_SD_REQUEST_MASTER                   0x10000
+#define RSI_DEVICE_BUFFER_STATUS_REGISTER 0xf3
+#define RSI_FN1_INT_REGISTER		0xf9
+#define SD_REQUEST_MASTER		0x10000
 
 /* FOR SD CARD ONLY */
-#define SDIO_RX_NUM_BLOCKS_REG                  0x000F1
-#define SDIO_FW_STATUS_REG                      0x000F2
-#define SDIO_NXT_RD_DELAY2                      0x000F5
-#define SDIO_MASTER_ACCESS_MSBYTE               0x000FA
-#define SDIO_MASTER_ACCESS_LSBYTE               0x000FB
-#define SDIO_READ_START_LVL                     0x000FC
-#define SDIO_READ_FIFO_CTL                      0x000FD
-#define SDIO_WRITE_FIFO_CTL                     0x000FE
-#define SDIO_FUN1_INTR_CLR_REG                  0x0008
-#define SDIO_REG_HIGH_SPEED                     0x0013
+#define SDIO_RX_NUM_BLOCKS_REG		0x000F1
+#define SDIO_FW_STATUS_REG		0x000F2
+#define SDIO_NXT_RD_DELAY2		0x000F5
+#define SDIO_MASTER_ACCESS_MSBYTE	0x000FA
+#define SDIO_MASTER_ACCESS_LSBYTE	0x000FB
+#define SDIO_READ_START_LVL		0x000FC
+#define SDIO_READ_FIFO_CTL		0x000FD
+#define SDIO_WRITE_FIFO_CTL		0x000FE
+#define SDIO_WAKEUP_REG			0x000FF
+
+#define SDIO_FUN1_INTR_CLR_REG		0x0008
+#define SDIO_REG_HIGH_SPEED		0x0013
+#define TA_SOFT_RESET_REG		0x0004
+#define TA_TH0_PC_REG			0x0400
+#define TA_HOLD_THREAD_REG		0x0844       
+#define TA_RELEASE_THREAD_REG		0x0848
+#define TA_POLL_BREAK_STATUS_REG	0x085C
+
 
 #define RSI_GET_SDIO_INTERRUPT_TYPE(_I, TYPE)      \
 	{					   \
@@ -73,18 +90,27 @@ enum sdio_interrupt_type {
 	}
 
 /* common registers in SDIO function1 */
-#define TA_SOFT_RESET_REG            0x0004
-#define TA_TH0_PC_REG                0x0400
-#define TA_HOLD_THREAD_REG           0x0844
-#define TA_RELEASE_THREAD_REG        0x0848
-
-#define TA_SOFT_RST_CLR              0
-#define TA_SOFT_RST_SET              BIT(0)
-#define TA_PC_ZERO                   0
-#define TA_HOLD_THREAD_VALUE         cpu_to_le32(0xF)
-#define TA_RELEASE_THREAD_VALUE      cpu_to_le32(0xF)
-#define TA_BASE_ADDR                 0x2200
-#define MISC_CFG_BASE_ADDR           0x4105
+#define TA_SOFT_RESET_REG		0x0004
+#define TA_TH0_PC_REG			0x0400
+#define TA_HOLD_THREAD_REG		0x0844
+#define TA_RELEASE_THREAD_REG		0x0848
+#define TA_SDIO_WAKE_REQUEST		0x1
+
+#define TA_SOFT_RST_CLR			0
+#define TA_SOFT_RST_SET			BIT(0)
+#define TA_PC_ZERO			0
+#define TA_HOLD_THREAD_VALUE		0xF
+#define TA_RELEASE_THREAD_VALUE		0xF
+#define TA_BASE_ADDR			0x2200
+#define MISC_CFG_BASE_ADDR		0x4105
+
+enum sdio_interrupt_type {
+	BUFFER_FULL		= 0x0,
+	BUFFER_AVAILABLE	= 0x2,
+	FIRMWARE_ASSERT_IND	= 0x3,
+	MSDU_PACKET_PENDING	= 0x4,
+	UNKNOWN_INT		= 0XE
+};
 
 struct receive_info {
 	bool buffer_full;
@@ -101,9 +127,15 @@ struct receive_info {
 	u32 buf_available_counter;
 };
 
+#define RSI_SDIO_MAX_RX_PKTS	32
+struct rsi_sdio_rx_q {
+	u8 num_rx_pkts;
+	struct sk_buff_head head;
+};
+
 struct rsi_91x_sdiodev {
 	struct sdio_func *pfunction;
-	struct task_struct *in_sdio_litefi_irq;
+	struct task_struct *sdio_irq_task;
 	struct receive_info rx_info;
 	u32 next_read_delay;
 	u32 sdio_high_speed_enable;
@@ -112,18 +144,38 @@ struct rsi_91x_sdiodev {
 	u8 prev_desc[16];
 	u32 tx_blk_size;
 	u8 write_fail;
+	u8 buff_status_updated;
+	struct rsi_sdio_rx_q rx_q;
+	struct rsi_thread rx_thread;
 };
 
 void rsi_interrupt_handler(struct rsi_hw *adapter);
 int rsi_init_sdio_slave_regs(struct rsi_hw *adapter);
 int rsi_sdio_device_init(struct rsi_common *common);
 int rsi_sdio_read_register(struct rsi_hw *adapter, u32 addr, u8 *data);
-int rsi_sdio_host_intf_read_pkt(struct rsi_hw *adapter, u8 *pkt, u32 length);
 int rsi_sdio_write_register(struct rsi_hw *adapter, u8 function,
 			    u32 addr, u8 *data);
+int rsi_sdio_host_intf_read_pkt(struct rsi_hw *adapter, u8 *pkt, u32 length);
+int rsi_sdio_host_intf_write_pkt(struct rsi_hw *adapter, u8 *pkt, u32 len);
+int rsi_sdio_read_register_multiple(struct rsi_hw *adapter, u32 addr,
+				    u8 *data, u16 count);
 int rsi_sdio_write_register_multiple(struct rsi_hw *adapter, u32 addr,
-				     u8 *data, u32 count);
+				     u8 *data, u16 count);
+int rsi_sdio_master_access_msword(struct rsi_hw *adapter,
+				  u16 ms_word);
+int rsi_sdio_load_data_master_write(struct rsi_hw *adapter,
+				    u32 base_address, u32 instructions_sz,
+				    u16 block_size, u8 *ta_firmware);
+int rsi_sdio_master_reg_read(struct rsi_hw *adapter, u32 addr,
+			     u32 *read_buf, u16 size);
+int rsi_sdio_master_reg_write(struct rsi_hw *adapter,
+			      unsigned long addr,
+			      unsigned long data,
+			      u16 size);
+int rsi_sdio_reinit_device(struct rsi_hw *adapter);
 void rsi_sdio_ack_intr(struct rsi_hw *adapter, u8 int_bit);
 int rsi_sdio_determine_event_timeout(struct rsi_hw *adapter);
-int rsi_sdio_read_buffer_status_register(struct rsi_hw *adapter, u8 q_num);
+int rsi_sdio_check_buffer_status(struct rsi_hw *adapter, u8 q_num);
+int rsi_read_intr_status_reg(struct rsi_hw *adapter);
+void rsi_sdio_rx_thread(struct rsi_common *common);
 #endif
diff --git a/drivers/net/wireless/rsi/rsi_usb.h b/drivers/net/wireless/rsi/rsi_usb.h
index ebea0c4..fb52be5 100644
--- a/drivers/net/wireless/rsi/rsi_usb.h
+++ b/drivers/net/wireless/rsi/rsi_usb.h
@@ -1,18 +1,31 @@
-/**
- * @section LICENSE
- * Copyright (c) 2014 Redpine Signals Inc.
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
  *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
  *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
+ *
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
+ *
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #ifndef __RSI_USB_INTF__
@@ -22,47 +35,88 @@
 #include "rsi_main.h"
 #include "rsi_common.h"
 
-#define USB_INTERNAL_REG_1           0x25000
-#define RSI_USB_READY_MAGIC_NUM      0xab
+/* USB VENDOR ID for RSI*/
+#define USB_VENDOR_ID_RSI              0x1618
+
+/* Device ID for RS9113 */
+#define USB_DEVICE_ID_RSI_9113         0x9113
+/* Device ID for RS9116 */
+#define USB_DEVICE_ID_RSI_9116         0x9116
+
 #define FW_STATUS_REG                0x41050012
 
 #define USB_VENDOR_REGISTER_READ     0x15
 #define USB_VENDOR_REGISTER_WRITE    0x16
 #define RSI_USB_TX_HEAD_ROOM         128
 
+#define MAX_TX_URBS                  1
+#if defined (CONFIG_RSI_BT_ALONE) || defined(CONFIG_RSI_COEX)
+#define MAX_RX_URBS                  2
+#else
 #define MAX_RX_URBS                  1
+#endif
 #define MAX_BULK_EP                  8
 #define MGMT_EP                      1
 #define DATA_EP                      2
 
+struct rx_usb_ctrl_block {
+	u8 *data;
+	struct urb *rx_urb;
+	struct sk_buff *rx_skb;
+	u8 ep_num;
+};
+
+struct receive_info {
+	bool buffer_full;
+	bool semi_buffer_full;
+	bool mgmt_buffer_full;
+	u32 mgmt_buf_full_counter;
+	u32 buf_semi_full_counter;
+	u8 watch_bufferfull_count;
+	u32 buf_full_counter;
+	u32 buf_available_counter;
+};
+
 struct rsi_91x_usbdev {
+	void *priv;
+	struct receive_info rx_info;
 	struct rsi_thread rx_thread;
 	u8 endpoint;
 	struct usb_device *usbdev;
 	struct usb_interface *pfunction;
-	struct urb *rx_usb_urb[MAX_RX_URBS];
+	struct rx_usb_ctrl_block rx_cb[MAX_RX_URBS];
 	u8 *tx_buffer;
-	__le16 bulkin_size;
-	u8 bulkin_endpoint_addr;
+	u8 *saved_tx_buffer;
+	__le16 bulkin_size[MAX_BULK_EP];
+	u8 bulkin_endpoint_addr[MAX_BULK_EP];
 	__le16 bulkout_size[MAX_BULK_EP];
 	u8 bulkout_endpoint_addr[MAX_BULK_EP];
 	u32 tx_blk_size;
 	u8 write_fail;
+	struct sk_buff_head rx_q[MAX_RX_URBS]; 
 };
 
-static inline int rsi_usb_check_queue_status(struct rsi_hw *adapter, u8 q_num)
-{
-	/* In USB, there isn't any need to check the queue status */
-	return QUEUE_NOT_FULL;
-}
-
 static inline int rsi_usb_event_timeout(struct rsi_hw *adapter)
 {
 	return EVENT_WAIT_FOREVER;
 }
 
 int rsi_usb_device_init(struct rsi_common *common);
+int rsi_usb_read_register_multiple(struct rsi_hw *adapter, u32 addr,
+				   u8 *data, u16 count);
 int rsi_usb_write_register_multiple(struct rsi_hw *adapter, u32 addr,
-				    u8 *data, u32 count);
+				    u8 *data, u16 count);
 void rsi_usb_rx_thread(struct rsi_common *common);
+
+int rsi_usb_host_intf_write_pkt(struct rsi_hw *adapter, u8 *pkt, u32 len);
+int rsi_usb_master_reg_read(struct rsi_hw *adapter, u32 reg,
+			    u32 *value, u16 len);
+int rsi_usb_master_reg_write(struct rsi_hw *adapter, unsigned long reg,
+			     unsigned long value, u16 len);
+int rsi_usb_load_data_master_write(struct rsi_hw *adapter, u32 base_address,
+				   u32 instructions_sz,
+				   u16 block_size,
+				   u8 *ta_firmware);
+int rsi_usb_check_queue_status(struct rsi_hw *adapter, u8 q_num);
+int rsi_rx_urb_submit(struct rsi_hw *adapter, u8 ep_num);
 #endif
diff --git a/drivers/net/wireless/rsi/rsi_zigb.h b/drivers/net/wireless/rsi/rsi_zigb.h
new file mode 100755
index 0000000..70de66a
--- /dev/null
+++ b/drivers/net/wireless/rsi/rsi_zigb.h
@@ -0,0 +1,166 @@
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *	1. Redistributions of source code must retain the above copyright
+ *	   notice, this list of conditions and the following disclaimer.
+ *
+ *	2. Redistributions in binary form must reproduce the above copyright
+ *	   notice, this list of conditions and the following disclaimer in the
+ *	   documentation and/or other materials provided with the distribution.
+ *
+ *	3. Neither the name of the copyright holder nor the names of its
+ *	   contributors may be used to endorse or promote products derived from
+ *	   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __ONEBOX_COMMON_H__
+#define __ONEBOX_COMMON_H__
+
+#include <linux/netdevice.h>
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/init.h>
+#include <linux/etherdevice.h>
+#include <linux/if.h>
+#include <linux/wireless.h>
+#include <linux/version.h>
+#include <linux/vmalloc.h>
+#include <linux/mutex.h>
+#include <net/genetlink.h>
+#include <net/sock.h>
+
+#if((LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18))&& \
+    (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,23)))
+#include <linux/sdio/ctsystem.h>
+#include <linux/sdio/sdio_busdriver.h>
+#include <linux/sdio/_sdio_defs.h>
+#include <linux/sdio/sdio_lib.h>
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26))
+#include <linux/mmc/card.h>
+#include <linux/mmc/sdio_func.h>
+#include <linux/mmc/sdio_ids.h>
+#endif
+
+#ifndef __ONEBOX_ZB_IOCTL_H__
+#define __ONEBOX_ZB_IOCTL_H__
+
+#define RSI_ZIGB_SEND    SIOCIWLASTPRIV - 0x1
+#define RSI_ZIGB_RECV    SIOCIWLASTPRIV - 0x2
+int zigb_ioctl(struct net_device *dev,struct ifreq *ifr, int cmd);
+
+#endif
+
+static u8 device_mac_addr[6] = {0x00, 0x23, 0xa7, 0x27, 0x03, 0x99};
+
+#if 1
+/* Kernel version between and including a & b */
+#define KERNEL_VERSION_BTWN_2_6_(a,b) \
+  ((LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,a)) && \
+  (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,b)))
+
+#define KERNEL_VERSION_EQUALS_2_6_(a) \
+  (LINUX_VERSION_CODE == KERNEL_VERSION(2,6,a))
+
+/* Kernel version greater than equals */
+#define KERNEL_VERSION_GREATER_THAN_2_6_(a)  \
+ (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,a))
+
+/* Kernel version less than or equal to */
+#define KERNEL_VERSION_LESS_THAN_3_6(a)  \
+ (LINUX_VERSION_CODE <= KERNEL_VERSION(3,6,a))
+
+#define KERNEL_VERSION_LESS_THAN_3_12_(a) \
+ (LINUX_VERSION_CODE <= KERNEL_VERSION(3,12,a))
+#endif
+
+#ifndef IN
+#define IN
+#endif
+
+#ifndef OUT
+#define OUT
+#endif
+
+#define FRAME_DESC_SZ		16
+#define DWORD_ALIGN_SZ		64
+#define ZIGB_DEREGISTER		0xff
+
+#define GET_ADAPTER_FROM_GENLCB(gcb) \
+		(ZB_ADAPTER)(gcb->gc_drvpriv)
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(3, 6, 11)
+# define get_portid(_info) ((_info)->snd_pid)
+#else
+# define get_portid(_info) ((_info)->snd_portid)
+#endif
+
+enum {
+	RSI_USER_A_UNSPEC,
+	RSI_USER_A_MSG,
+	__RSI_USER_A_MAX,
+};
+
+enum {
+	RSI_USER_C_UNSPEC,
+	RSI_USER_C_CMD,
+	__RSI_USER_C_MAX,
+};
+
+struct genl_cb {
+	unsigned char gc_cmd, *gc_name;
+	int gc_seq, gc_pid;
+	int gc_done;
+	int gc_n_ops;
+	void  *gc_drvpriv;
+	struct nla_policy *gc_policy;
+	struct genl_family *gc_family;
+	struct genl_ops *gc_ops;
+	struct genl_info *gc_info;
+	struct sk_buff *gc_skb;
+};
+
+struct rsi_zigb_adapter {
+	struct rsi_common *priv;
+	struct genl_cb *gcb;
+};
+
+enum zb_fsm_state {
+	RSI_ZB_FSM_DEVICE_NOT_READY = 0,
+	RSI_ZB_FSM_DEVICE_READY,
+};
+
+struct rsi_zb_adapter
+{
+	struct net_device *dev; /* Stores the netdevice pointer */
+	struct rsi_common *priv;
+	u8     mac_addr[6];
+	u32    fsm_state;
+	struct genl_cb *gcb;
+};
+
+int rsi_zigb_attach(void *priv, struct rsi_proto_ops *ops);
+void rsi_zigb_detach(void *priv);
+int zigb_ioctl(struct net_device *dev,struct ifreq *ifr, int cmd);
+int zigb_xmit(struct sk_buff *skb, struct net_device *dev);
+int device_close(struct net_device *dev);
+int device_open(struct net_device *dev);
+int zigb_genl_recv(struct sk_buff *skb, struct genl_info *info);
+int rsi_zigb_recv_pkt(void *priv, u8 *pkt);
+int rsi_zigb_send_pkt(struct rsi_common *common, struct sk_buff *skb);
+int zigb_genl_send(struct genl_cb *gcb, struct sk_buff *skb);
+#endif
-- 
1.9.1

