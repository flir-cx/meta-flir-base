From e49a287b8ed82367a0f93884b1bd5f78d2a5e11c Mon Sep 17 00:00:00 2001
From: Peter Fitger <peter.fitger@flir.se>
Date: Wed, 7 Nov 2018 12:55:41 +0100
Subject: [PATCH] Avoid system hangup on MU_SendMessage failure

---
 drivers/rpmsg/imx_rpmsg.c   |  6 ++++--
 drivers/soc/imx/mu/mx8_mu.c | 26 ++++++++++++++++++++------
 include/linux/mx8_mu.h      |  2 +-
 3 files changed, 25 insertions(+), 9 deletions(-)

diff --git a/drivers/rpmsg/imx_rpmsg.c b/drivers/rpmsg/imx_rpmsg.c
index 66b237e..c845c18 100644
--- a/drivers/rpmsg/imx_rpmsg.c
+++ b/drivers/rpmsg/imx_rpmsg.c
@@ -117,14 +117,16 @@ static bool imx_rpmsg_notify(struct virtqueue *vq)
 {
 	unsigned int mu_rpmsg = 0;
 	struct imx_rpmsg_vq_info *rpvq = vq->priv;
+	bool ret = true;
 
 	mu_rpmsg = rpvq->vq_id << 16;
 	mutex_lock(&rpvq->rpdev->lock);
 	/* send the index of the triggered virtqueue as the mu payload */
-	MU_SendMessage(rpvq->rpdev->mu_base, 1, mu_rpmsg);
+	if (MU_SendMessage(rpvq->rpdev->mu_base, 1, mu_rpmsg) < 0)
+		ret = false;
 	mutex_unlock(&rpvq->rpdev->lock);
 
-	return true;
+	return ret;
 }
 
 static int imx_mu_rpmsg_callback(struct notifier_block *this,
diff --git a/drivers/soc/imx/mu/mx8_mu.c b/drivers/soc/imx/mu/mx8_mu.c
index 894c8fc..fe56227 100644
--- a/drivers/soc/imx/mu/mx8_mu.c
+++ b/drivers/soc/imx/mu/mx8_mu.c
@@ -84,22 +84,36 @@ void MU_EnableGeneralInt(void __iomem *base, uint32_t index)
 /*
  * Wait and send message to the other core.
  */
-void MU_SendMessage(void __iomem *base, uint32_t regIndex, uint32_t msg)
+int32_t MU_SendMessage(void __iomem *base, uint32_t regIndex, uint32_t msg)
 {
 	uint32_t mask = MU_SR_TE0_MASK1 >> regIndex;
+	uint32_t tmo = 0x100000;	/* 100 - 200 ms timeout */
+#ifdef DEBUG_MU_TMO
+	static uint32_t worst_tmo = 0x100000;
+#endif
 
 	if (unlikely(version == MU_VER_ID_V10)) {
 		/* Wait TX register to be empty. */
-		while (!(readl_relaxed(base + MU_V10_ASR_OFFSET1) & mask))
+		while (--tmo && !(readl_relaxed(base + MU_V10_ASR_OFFSET1) & mask))
 			;
-		writel_relaxed(msg, base + MU_V10_ATR0_OFFSET1
-			       + (regIndex * 4));
+		if (tmo)
+			writel_relaxed(msg, base + MU_V10_ATR0_OFFSET1
+					+ (regIndex * 4));
 	} else {
 		/* Wait TX register to be empty. */
-		while (!(readl_relaxed(base + MU_ASR_OFFSET1) & mask))
+		while (--tmo && !(readl_relaxed(base + MU_ASR_OFFSET1) & mask))
 			;
-		writel_relaxed(msg, base + MU_ATR0_OFFSET1  + (regIndex * 4));
+		if (tmo)
+			writel_relaxed(msg, base + MU_ATR0_OFFSET1  + (regIndex * 4));
 	}
+#ifdef DEBUG_MU_TMO
+	if (tmo < worst_tmo) {
+		worst_tmo = tmo;
+		pr_info ("rpmsg worst tmo %d\n", worst_tmo);
+	}
+#endif
+
+	return (tmo == 0) ? -ETIMEDOUT : 0;
 }
 
 
diff --git a/include/linux/mx8_mu.h b/include/linux/mx8_mu.h
index a26d2c6..b76bba2 100644
--- a/include/linux/mx8_mu.h
+++ b/include/linux/mx8_mu.h
@@ -38,7 +38,7 @@
 
 
 void MU_Init(void __iomem *base);
-void MU_SendMessage(void __iomem *base, uint32_t regIndex, uint32_t msg);
+int32_t MU_SendMessage(void __iomem *base, uint32_t regIndex, uint32_t msg);
 void MU_ReceiveMsg(void __iomem *base, uint32_t regIndex, uint32_t *msg);
 void MU_EnableGeneralInt(void __iomem *base, uint32_t index);
 void MU_EnableRxFullInt(void __iomem *base, uint32_t index);
-- 
1.9.1

