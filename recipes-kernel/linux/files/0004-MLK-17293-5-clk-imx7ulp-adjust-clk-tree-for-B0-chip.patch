From eeb05b7f2eace90c1eead1135887268263578c74 Mon Sep 17 00:00:00 2001
From: Anson Huang <Anson.Huang@nxp.com>
Date: Tue, 26 Dec 2017 20:18:41 +0800
Subject: [PATCH] MLK-17293-5 clk: imx7ulp: adjust clk tree for B0 chip

On i.MX7ULP B0 chip, snvs is located in M4 domain, remove
snvs clock from linux clock tree;

Use SMC PMCTRL RUNM field for ARM clock mux instead
of reserved register in SCG, as when CPU frequency changes,
RUNM field will switch between RUN and HSRUN, ARM clock
source will be changed accordingly, so RUNM can be used as
a clock mux.

Signed-off-by: Anson Huang <Anson.Huang@nxp.com>
Reviewed-by: Bai Ping <ping.bai@nxp.com>
---
 drivers/clk/imx/clk-imx7ulp.c | 10 +++++++---
 1 file changed, 7 insertions(+), 3 deletions(-)

diff --git a/drivers/clk/imx/clk-imx7ulp.c b/drivers/clk/imx/clk-imx7ulp.c
index 0de0b16..020a390 100644
--- a/drivers/clk/imx/clk-imx7ulp.c
+++ b/drivers/clk/imx/clk-imx7ulp.c
@@ -26,7 +26,7 @@ static const char *spll_sels[]		= { "spll", "spll_pfd_sel", };
 static const char *apll_pfd_sels[]	= { "apll_pfd0", "apll_pfd1", "apll_pfd2", "apll_pfd3", };
 static const char *apll_sels[]		= { "apll", "apll_pfd_sel", };
 static const char *sys_sels[]		= { "dummy", "osc", "sirc", "firc", "ckil", "apll_sel", "spll_sel", "upll", };
-static const char *arm_sels[]		= { "core_div", "hsrun_core", };
+static const char *arm_sels[]		= { "core_div", "dummy", "dummy", "hsrun_core", };
 static const char *ddr_sels[]		= { "apll_pfd_sel", "upll", };
 static const char *nic_sels[]		= { "firc", "ddr_div", };
 static const char *periph_plat_sels[]	= { "dummy", "nic1_bus", "nic1_div", "ddr_div", "apll_pfd2", "apll_pfd1", "apll_pfd0", "upll", };
@@ -65,6 +65,7 @@ static void __init imx7ulp_clocks_init(struct device_node *scg_node)
 {
 	struct device_node *np;
 	void __iomem *base;
+	void __iomem *smc_base;
 	int i;
 
 	clks[IMX7ULP_CLK_DUMMY]		= imx_clk_fixed("dummy", 0);
@@ -76,6 +77,10 @@ static void __init imx7ulp_clocks_init(struct device_node *scg_node)
 	clks[IMX7ULP_CLK_MIPI_PLL]	= of_clk_get_by_name(scg_node, "mpll");
 	clks[IMX7ULP_CLK_UPLL]		= of_clk_get_by_name(scg_node, "upll");
 
+	np = of_find_compatible_node(NULL, NULL, "fsl,imx7ulp-smc1");
+	smc_base = of_iomap(np, 0);
+	WARN_ON(!smc_base);
+
 	np = scg_node;
 	base = of_iomap(np, 0);
 	WARN_ON(!base);
@@ -115,7 +120,7 @@ static void __init imx7ulp_clocks_init(struct device_node *scg_node)
 	clks[IMX7ULP_CLK_HSRUN_CORE] = imx_clk_divider_flags("hsrun_core", "hsrun_sys_sel", base + 0x1c, 16, 4, CLK_SET_RATE_PARENT);
 	clks[IMX7ULP_CLK_PLAT_DIV] = imx_clk_divider("plat_div", "core_div", base + 0x14, 12, 4);
 	/* Fake mux */
-	clks[IMX7ULP_CLK_ARM] = imx_clk_mux_glitchless("arm", base + 0x14, 5, 1, arm_sels, ARRAY_SIZE(arm_sels));
+	clks[IMX7ULP_CLK_ARM] = imx_clk_mux_glitchless("arm", smc_base + 0x10, 8, 2, arm_sels, ARRAY_SIZE(arm_sels));
 
 	clks[IMX7ULP_CLK_DDR_DIV] = clk_register_divider(NULL, "ddr_div", "ddr_sel", CLK_SET_RATE_PARENT | CLK_SET_RATE_GATE, base + 0x30, 0, 3, CLK_DIVIDER_ONE_BASED, &imx_ccm_lock);
 	clks[IMX7ULP_CLK_NIC0_DIV] = imx_clk_divider("nic0_div", "nic_sel",  base + 0x40, 24, 4);
@@ -131,7 +136,6 @@ static void __init imx7ulp_clocks_init(struct device_node *scg_node)
 	clks[IMX7ULP_CLK_DMA1]		= imx_clk_gate("dma1", "nic1_bus", base + 0x20, 30);
 	clks[IMX7ULP_CLK_RGPIO2P1]	= imx_clk_gate("gpio", "nic1_bus", base + 0x3c, 30);
 	clks[IMX7ULP_CLK_DMA_MUX1]	= imx_clk_gate("dma_mux1", "nic1_bus",	base + 0x84, 30);
-	clks[IMX7ULP_CLK_SNVS]		= imx_clk_gate("snvs", "nic1_bus",	base + 0x8c, 30);
 	clks[IMX7ULP_CLK_CAAM]		= imx_clk_gate("caam", "nic1_div",	base + 0x90, 30);
 	clks[IMX7ULP_CLK_LPTPM4]	= imx_clk_composite("lptpm4",  periph_slow_sels, ARRAY_SIZE(periph_slow_sels), true, false, true, base + 0x94);
 	clks[IMX7ULP_CLK_LPTPM5]	= imx_clk_composite("lptmp5",  periph_slow_sels, ARRAY_SIZE(periph_slow_sels), true, false, true, base + 0x98);
-- 
2.9.2

