From 976abae29107094b1ef46b26672a5e58d3702993 Mon Sep 17 00:00:00 2001
From: Klas Malmborg <klas.malmborg@teledyneflir.com>
Date: Tue, 9 Nov 2021 10:56:03 +0100
Subject: [PATCH] Find empty buffer

---
 libs/v4l2_core/gstimxv4l2.c | 36 +++++++++++++++++++++++++++++-------
 1 file changed, 29 insertions(+), 7 deletions(-)
 mode change 100755 => 100644 libs/v4l2_core/gstimxv4l2.c

diff --git a/libs/v4l2_core/gstimxv4l2.c b/libs/v4l2_core/gstimxv4l2.c
old mode 100755
new mode 100644
index 24f8ff3..c0b02a7
--- a/libs/v4l2_core/gstimxv4l2.c
+++ b/libs/v4l2_core/gstimxv4l2.c
@@ -51,6 +51,7 @@ GST_DEBUG_CATEGORY (imxv4l2_debug);
 #define MX60_STREAMON_COUNT (1)
 
 #define MAX_BUFFER (32)
+#define MAX_V4L2_BUFFER (10)
 #define UPALIGNTO8(a) ((a + 7) & (~7))
 #define DOWNALIGNTO8(a) ((a) & (~7))
 
@@ -216,6 +217,7 @@ static guint g_camera_format_PXP[] = {
 
 static IMXV4l2DeviceMap g_device_maps[] = {
   {"/dev/video0", FALSE, "/dev/fb0"},
+  {"/dev/video1", FALSE, "/dev/fb0"},
   {"/dev/video16", TRUE, "/dev/fb0"},
   {"/dev/video17", FALSE, "/dev/fb0"},
   {"/dev/video18", TRUE, "/dev/fb2"},
@@ -1569,7 +1571,7 @@ static void * gst_imx_v4l2_find_buffer(gpointer v4l2handle, PhyMemBlock *memblk)
   IMXV4l2Handle *handle = (IMXV4l2Handle*)v4l2handle;
   gint i;
 
-  for(i=0; i<MAX_BUFFER; i++) {
+  for(i=0; i<handle->buffer_count; i++) {
     if (handle->buffer_pair[i].vaddr == memblk->vaddr)
       return &handle->buffer_pair[i].v4l2buffer;
   }
@@ -1612,21 +1614,35 @@ gint gst_imx_v4l2_set_buffer_count (gpointer v4l2handle, guint count, guint memo
   memset(&buf_req, 0, sizeof(buf_req));
 
   buf_req.type = handle->type;
-  buf_req.count = count;
+  buf_req.count = MAX_V4L2_BUFFER;
   handle->memory_mode = buf_req.memory = memory_mode;
   if (ioctl(handle->v4l2_fd, VIDIOC_REQBUFS, &buf_req) < 0) {
     GST_ERROR("Request %d buffers failed\n", count);
     return -1;
   }
-  handle->buffer_count = count;
+  handle->buffer_count = buf_req.count;
 
   return 0;
 }
 
+int gst_imx_v412_find_first_empty_buffer(gpointer v4l2handle)
+{
+  IMXV4l2Handle *handle = (IMXV4l2Handle*)v4l2handle;
+  gint index;
+  
+  for(index = 0; index < handle->buffer_count; index++) {
+    if (!handle->buffer_pair[index].vaddr)
+      return index;
+  }
+  
+  return -1;
+}
+
 gint gst_imx_v4l2_allocate_buffer (gpointer v4l2handle, PhyMemBlock *memblk)
 {
   IMXV4l2Handle *handle = (IMXV4l2Handle*)v4l2handle;
   struct v4l2_buffer *v4l2buf;
+  int empty_buffer_index;
 
   if (handle->memory_mode == V4L2_MEMORY_USERPTR) {
     GST_INFO ("USERPTR mode, needn't allocate memory.\n");
@@ -1637,12 +1653,18 @@ gint gst_imx_v4l2_allocate_buffer (gpointer v4l2handle, PhyMemBlock *memblk)
     GST_ERROR ("No more v4l2 buffer for allocating.\n");
     return -1;
   }
+  
+  empty_buffer_index = gst_imx_v412_find_first_empty_buffer(v4l2handle);
+  if(empty_buffer_index < 0) {
+    GST_ERROR ("Failed to find an empty slot in buffer_pair.\n");
+    return -1;
+  }
 
-  v4l2buf = &handle->buffer_pair[handle->allocated].v4l2buffer;
+  v4l2buf = &handle->buffer_pair[empty_buffer_index].v4l2buffer;
   memset (v4l2buf, 0, sizeof(struct v4l2_buffer));
   v4l2buf->type = handle->type;
   v4l2buf->memory = handle->memory_mode;
-  v4l2buf->index = handle->allocated;
+  v4l2buf->index = empty_buffer_index;
 
   if (ioctl(handle->v4l2_fd, VIDIOC_QUERYBUF, v4l2buf) < 0) {
     GST_ERROR ("VIDIOC_QUERYBUF error.");
@@ -1677,12 +1699,12 @@ gint gst_imx_v4l2_allocate_buffer (gpointer v4l2handle, PhyMemBlock *memblk)
   if (handle->invalid_paddr)
     memblk->paddr = NULL;
 
-  handle->buffer_pair[handle->allocated].vaddr = memblk->vaddr;
+  handle->buffer_pair[empty_buffer_index].vaddr = memblk->vaddr;
 
   handle->allocated ++;
 
   GST_DEBUG ("Allocated v4l2buffer(%p), type(%d), index(%d), memblk(%p), vaddr(%p), paddr(%p), size(%d).",
-      v4l2buf, v4l2buf->type, handle->allocated - 1, memblk, memblk->vaddr, memblk->paddr, memblk->size);
+      v4l2buf, v4l2buf->type, empty_buffer_index, memblk, memblk->vaddr, memblk->paddr, memblk->size);
 
   return 0;
 }
-- 
2.25.1

