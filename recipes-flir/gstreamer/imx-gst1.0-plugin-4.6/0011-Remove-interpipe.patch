From 09c7fb65b160560e0d91d1ca6e806ab17f771d31 Mon Sep 17 00:00:00 2001
From: Klas Malmborg <klas.malmborg@teledyneflir.com>
Date: Mon, 8 Aug 2022 15:03:45 +0200
Subject: [PATCH] Remove interpipe

Signed-off-by: Klas Malmborg <klas.malmborg@teledyneflir.com>
---
 libs/meson.build            |   1 +
 libs/v4l2_core/gstimxv4l2.c | 638 +++++++++++++++++++++++++++++++-----
 2 files changed, 566 insertions(+), 73 deletions(-)

diff --git a/libs/meson.build b/libs/meson.build
index 00db3d6..c3eea3c 100644
--- a/libs/meson.build
+++ b/libs/meson.build
@@ -43,6 +43,7 @@ endif
 if cc.has_header('linux/ipu.h') and build_ipu
   gstfsl_sources += ['device-2d/imx_2d_device_ipu.c']
   gstfsl_cflags += ['-DUSE_IPU']
+  gstfsl_ldflags += ['-lpthread']
 endif
 
 if cc.has_header('X11/Xlib.h')
diff --git a/libs/v4l2_core/gstimxv4l2.c b/libs/v4l2_core/gstimxv4l2.c
index c0b02a7..10243d2 100644
--- a/libs/v4l2_core/gstimxv4l2.c
+++ b/libs/v4l2_core/gstimxv4l2.c
@@ -23,6 +23,8 @@
 #include <sys/ioctl.h>
 #include <sys/mman.h>
 #include <string.h>
+#include <pthread.h>
+#include <semaphore.h>
 
 #include <linux/fb.h>
 #include <linux/mxcfb.h>
@@ -64,6 +66,9 @@ GST_DEBUG_CATEGORY (imxv4l2_debug);
 #define MXC_V4L2_CAPTURE_TVIN_VADC_NAME "vadc"
 #define PXP_V4L2_CAPTURE_NAME "csi_v4l2"
 
+#define MAX_FLOWS           6   // Max number of simultaneous flows
+#define SHARED_DEVICES      2   // Number of devices that share flows (=> src devices)
+
 typedef struct {
   struct v4l2_buffer v4l2buffer;
   PhyMemBlock *v4l2memblk;
@@ -142,6 +147,32 @@ typedef struct {
   const gchar *bg_fb_name;
 } IMXV4l2DeviceMap;
 
+struct V4LSrcCommonBuf
+{
+  struct v4l2_buffer v4l2buf;
+  int new;
+};
+
+enum flow_state {
+		 V4CIDLE=0,
+		 V4CWAIT,
+		 V4CRESTART
+};
+
+// Variables to synchronize between multiple flows
+typedef struct
+{
+    int activeFlows;                // Number of active flows
+    int rdBuf[MAX_FLOWS];           // Read buffer pointer
+    int wrBuf[MAX_FLOWS];           // Write buffer pointer
+    int fd_v4l[MAX_FLOWS];          // fd for /dev/video0
+    struct V4LSrcCommonBuf buf[MAX_FLOWS][MAX_BUFFER];
+    sem_t *sem[MAX_FLOWS];           // Semaphore to wait for buffer
+    GMutex lock;                     // Lock to protect this struct
+    enum flow_state state[MAX_FLOWS];    // Flow state
+    IMXV4l2BufferPair *buffer_pair[MAX_FLOWS];
+} MFWGstV4LSrcCommon;
+
 #define GST_VIDEO_CAPS_MAKE_BAYER(format)                               \
     "video/x-bayer, "                                                   \
     "format = (string) " format ", "                                    \
@@ -189,6 +220,7 @@ static IMXV4l2FmtMap g_imxv4l2fmt_maps_PXP[] = {
   {GST_VIDEO_CAPS_MAKE_BAYER("rggb"), V4L2_PIX_FMT_SRGGB8, GST_VIDEO_FORMAT_UNKNOWN, 8, 0},
 };
 
+/*
 static guint g_camera_format[] = {
   V4L2_PIX_FMT_YUV420,
   V4L2_PIX_FMT_NV12,
@@ -198,6 +230,7 @@ static guint g_camera_format[] = {
   V4L2_PIX_FMT_RGB32,
   0,
 };
+*/
 
 static guint g_camera_format_IPU[] = {
   V4L2_PIX_FMT_YUV420,
@@ -225,6 +258,13 @@ static IMXV4l2DeviceMap g_device_maps[] = {
   {"/dev/video20", TRUE, "/dev/fb4"}
 };
 
+int imx_v4l2_is_a_shared_device(IMXV4l2Handle *handle);
+int imx_v4l2_is_primary_flow(MFWGstV4LSrcCommon * v4lc, IMXV4l2Handle *handle);
+int imx_v4l2_find_flow_index_from_handle(MFWGstV4LSrcCommon * v4lc, IMXV4l2Handle *handle);
+void print_buffer_pair(IMXV4l2BufferPair *buffer_pair, int flow_index);
+
+static MFWGstV4LSrcCommon v4lCommon[SHARED_DEVICES];
+
 static IMXV4l2FmtMap * imx_v4l2_get_fmt_map(guint *map_size)
 {
   IMXV4l2FmtMap *fmt_map = NULL;
@@ -420,7 +460,6 @@ static gint
 imx_pxp_v4l2out_config_input (IMXV4l2Handle *handle, guint fmt, guint w, guint h, IMXV4l2Rect *crop)
 {
   struct v4l2_format v4l2fmt;
-  struct v4l2_rect icrop;
   int out_idx = 1;
 
   if (gst_imx_v4l2_reset_device ((gpointer)handle) < 0)
@@ -875,7 +914,6 @@ gst_imx_v4l2_support_deinterlace (gint type)
 static void
 gst_imx_v4l2output_set_default_res (IMXV4l2Handle *handle)
 {
-  struct fb_var_screeninfo fb_var;
   IMXV4l2Rect rect;
   gint i;
 
@@ -939,14 +977,17 @@ gst_imx_v4l2capture_config_usb_camera (IMXV4l2Handle *handle, guint fmt, guint w
   GST_INFO ("frame format: %c%c%c%c",	fmt & 0xff, (fmt >> 8) & 0xff,
       (fmt >> 16) & 0xff, (fmt >> 24) & 0xff);
 
-  v4l2_fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-  v4l2_fmt.fmt.pix.pixelformat = fmt;
-  v4l2_fmt.fmt.pix.width = w;
-  v4l2_fmt.fmt.pix.height = h;
+  if ((handle->device_map_id >= SHARED_DEVICES) ||
+      (v4lCommon[handle->device_map_id].fd_v4l[0] == handle->v4l2_fd)) {
+    v4l2_fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    v4l2_fmt.fmt.pix.pixelformat = fmt;
+    v4l2_fmt.fmt.pix.width = w;
+    v4l2_fmt.fmt.pix.height = h;
 
-  if (ioctl (handle->v4l2_fd, VIDIOC_S_FMT, &v4l2_fmt) < 0) {
-    GST_ERROR ("VIDIOC_S_FMT failed");
-    return -1;
+    if (ioctl (handle->v4l2_fd, VIDIOC_S_FMT, &v4l2_fmt) < 0) {
+      GST_ERROR ("VIDIOC_S_FMT failed");
+      return -1;
+    }
   }
 
   return 0;
@@ -968,14 +1009,17 @@ gst_imx_v4l2capture_config_pxp (IMXV4l2Handle *handle, guint fmt, guint w, guint
 static gint
 gst_imx_v4l2capture_config_camera (IMXV4l2Handle *handle, guint fmt, guint w, guint h, guint fps_n, guint fps_d)
 {
-  gint input = 1;
+  if ((handle->device_map_id >= SHARED_DEVICES) ||
+      (v4lCommon[handle->device_map_id].fd_v4l[0] == handle->v4l2_fd)) {
+    gint input = 1;
 
-  if (ioctl (handle->v4l2_fd, VIDIOC_S_INPUT, &input) < 0) {
-    GST_ERROR ("VIDIOC_S_INPUT failed");
-    return -1;
+    if (ioctl (handle->v4l2_fd, VIDIOC_S_INPUT, &input) < 0) {
+      GST_ERROR ("VIDIOC_S_INPUT failed");
+      return -1;
+    }
+    return gst_imx_v4l2capture_config_pxp (handle, fmt, w, h, fps_n, fps_d);
   }
-
-  return gst_imx_v4l2capture_config_pxp (handle, fmt, w, h, fps_n, fps_d);
+  return 0;
 }
 
 static gint
@@ -1010,7 +1054,7 @@ gst_imx_v4l2capture_set_function (IMXV4l2Handle *handle)
   }
 
   handle->is_tvin = FALSE;
-  if (!strcmp (cap.driver, MXC_V4L2_CAPTURE_NAME)) {
+  if (!strcmp ((char*)cap.driver, MXC_V4L2_CAPTURE_NAME)) {
     struct v4l2_dbg_chip_ident chip;
     if (ioctl(handle->v4l2_fd, VIDIOC_DBG_G_CHIP_IDENT, &chip)) {
       GST_ERROR ("VIDIOC_DBG_G_CHIP_IDENT failed.\n");
@@ -1033,7 +1077,7 @@ gst_imx_v4l2capture_set_function (IMXV4l2Handle *handle)
       GST_ERROR ("can't identify capture sensor type.\n");
       return -1;
     }
-  } else if (!strcmp (cap.driver, PXP_V4L2_CAPTURE_NAME)) {
+  } else if (!strcmp ((char*)cap.driver, PXP_V4L2_CAPTURE_NAME)) {
     struct v4l2_dbg_chip_ident chip;
     if (ioctl(handle->v4l2_fd, VIDIOC_DBG_G_CHIP_IDENT, &chip)) {
       GST_ERROR ("VIDIOC_DBG_G_CHIP_IDENT failed.\n");
@@ -1107,11 +1151,19 @@ void gst_imx_v4l2_get_display_resolution (gchar *device, gint *w, gint *h)
   return;
 }
 
+MFWGstV4LSrcCommon *
+imx_v4l2_get_v4lc(IMXV4l2Handle *handle)
+{
+  return &v4lCommon[handle->device_map_id];
+}
+
 gpointer gst_imx_v4l2_open_device (gchar *device, int type)
 {
   int fd;
   struct v4l2_capability cap;
+  MFWGstV4LSrcCommon * v4lc;
   IMXV4l2Handle *handle = NULL;
+  gint i;
 
   GST_DEBUG_CATEGORY_INIT (imxv4l2_debug, "imxv4l2", 0, "IMX V4L2 Core");
 
@@ -1152,6 +1204,32 @@ gpointer gst_imx_v4l2_open_device (gchar *device, int type)
   handle->streamon = FALSE;
   handle->v4l2_hold_buf_num = V4L2_HOLDED_BUFFERS;
 
+  for (i=0; i<sizeof(g_device_maps)/sizeof(IMXV4l2DeviceMap); i++) {
+    if (!strcmp (handle->device, g_device_maps[i].name)) {
+      handle->device_map_id = i;
+      break;
+    }
+  }
+
+  if (imx_v4l2_is_a_shared_device(handle)) {
+    v4lc = imx_v4l2_get_v4lc(handle);
+
+    /* No need to initialize statically allocated mutex */
+    g_mutex_lock(&v4lc->lock);
+    v4lc->fd_v4l[v4lc->activeFlows] = handle->v4l2_fd;
+
+    v4lc->sem[v4lc->activeFlows] = (sem_t *)g_slice_alloc(sizeof(sem_t));
+    sem_init(v4lc->sem[v4lc->activeFlows], 0, 0);
+
+    v4lc->state[v4lc->activeFlows] = V4CIDLE;
+    v4lc->rdBuf[v4lc->activeFlows] = 0;
+    v4lc->wrBuf[v4lc->activeFlows] = 0;
+    v4lc->buffer_pair[v4lc->activeFlows] = handle->buffer_pair;
+    v4lc->activeFlows++;
+    g_mutex_unlock(&v4lc->lock);
+    GST_INFO("Open %d (%d)\n", v4lCommon[handle->device_map_id].activeFlows, handle->v4l2_fd);
+  }
+
   if (type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {
     if (HAS_IPU()) {
       handle->dev_itf.v4l2out_config_input = (V4l2outConfigInput)imx_ipu_v4l2out_config_input;
@@ -1190,14 +1268,21 @@ gpointer gst_imx_v4l2_open_device (gchar *device, int type)
 
 gint gst_imx_v4l2_reset_device (gpointer v4l2handle)
 {
+  MFWGstV4LSrcCommon * v4lc;
   IMXV4l2Handle *handle = (IMXV4l2Handle*)v4l2handle;
   gint i;
 
   if (handle && handle->v4l2_fd) {
     if (handle->streamon) {
-      if (ioctl (handle->v4l2_fd, VIDIOC_STREAMOFF, &handle->type) < 0) {
-        GST_ERROR ("stream off failed\n");
-        return -1;
+
+      v4lc = imx_v4l2_get_v4lc(handle);
+
+      /* activeFlows <= 1? Why not just v4lc->activeFlows == 1? */
+      if (!imx_v4l2_is_a_shared_device(handle) || (v4lc->activeFlows <= 1)) {
+        if (ioctl (handle->v4l2_fd, VIDIOC_STREAMOFF, &handle->type) < 0) {
+          GST_ERROR ("stream off failed\n");
+          return -1;
+        }
       }
       handle->streamon = FALSE;
       GST_DEBUG ("V4L2 device is STREAMOFF.");
@@ -1219,29 +1304,104 @@ gint gst_imx_v4l2_reset_device (gpointer v4l2handle)
   return 0;
 }
 
+/* Must be called with the v4lc->lock lock. */
+gint
+imx_v4l2_remove_flow(MFWGstV4LSrcCommon *v4lc, IMXV4l2Handle *handle)
+{
+  int flow_to_remove;
+  enum flow_state current_flow_state;
+
+  flow_to_remove = imx_v4l2_find_flow_index_from_handle(v4lc, handle);
+  if(flow_to_remove < 0){
+    GST_ERROR("Failed to find flow");
+    return -1;
+  }
+
+  GST_DEBUG("Closing%s flow %d on %s fd %d, AF: %d",
+    flow_to_remove == 0 ? " PRIMARY" : "",
+    flow_to_remove,
+    g_device_maps[handle->device_map_id].name,
+    handle->v4l2_fd,
+    v4lc->activeFlows);
+
+  if (v4lc->state[flow_to_remove] == V4CWAIT) {
+    GST_ERROR("Closing flow %d that is in V4CWAIT", flow_to_remove);
+  }
+
+  sem_destroy(v4lc->sem[flow_to_remove]);
+  g_slice_free1(sizeof(sem_t), v4lc->sem[flow_to_remove]);
+
+  /* Shift all flows after the flow to remove one step back. */
+  for (int next_flow = flow_to_remove+1; next_flow < v4lc->activeFlows; next_flow++) {
+    v4lc->fd_v4l[next_flow-1]         = v4lc->fd_v4l[next_flow];
+    v4lc->sem[next_flow-1]            = v4lc->sem[next_flow];
+    v4lc->rdBuf[next_flow-1]          = v4lc->rdBuf[next_flow];
+    v4lc->wrBuf[next_flow-1]          = v4lc->wrBuf[next_flow];
+    v4lc->state[next_flow-1]          = v4lc->state[next_flow];
+    v4lc->buffer_pair[next_flow-1]    = v4lc->buffer_pair[next_flow];
+
+    for (int k=0; k<MAX_BUFFER; k++){
+      v4lc->buf[next_flow-1][k].v4l2buf = v4lc->buf[next_flow][k].v4l2buf;
+    }
+  }
+
+  /*
+   * If the removed flow was the primary flow we need to requeue all
+   * buffers that the new primary flow (formerly flow 1, now flow 0)
+   * has queued.  Set it to V4CRESTART state and release it if it is
+   * currently waiting.
+   */
+  if ((flow_to_remove == 0) && v4lc->activeFlows > 1) {
+    current_flow_state = v4lc->state[0];
+    v4lc->state[0] = V4CRESTART;
+
+    if (current_flow_state == V4CWAIT) {
+      GST_DEBUG("Waking up %d", 0);
+      sem_post(v4lc->sem[0]);
+    }
+  }
+
+  v4lc->activeFlows--;
+  return 0;
+}
+
 gint gst_imx_v4l2_close_device (gpointer v4l2handle)
 {
+  MFWGstV4LSrcCommon * v4lc;
   IMXV4l2Handle *handle = (IMXV4l2Handle*)v4l2handle;
 
-  if (handle) {
-    /*set global alpha to 255 when quit in case of overlay is already in use and
-     * part is transparent to UI*/
-    if (HAS_IPU() && handle->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {
-      gst_imx_v4l2out_config_alpha (handle, 255);
-    }
+  if(!handle){
+    return 0;
+  }
+
+  /*set global alpha to 255 when quit in case of overlay is already in use and
+   * part is transparent to UI*/
+  /* if (HAS_IPU() && handle->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {
+   * 	// This will inhibit video replay on HDMI for Rocky
+   * 	// gst_imx_v4l2out_config_alpha (handle, 255);
+   * } */
+
+  v4lc = &v4lCommon[handle->device_map_id];
 
-    if (handle->allocated) {
-      handle->pending_close = TRUE;
+  if (handle->allocated) {
+    handle->pending_close = TRUE;
+    return 0;
+  }
+
+  if (handle->v4l2_fd) {
+    if (imx_v4l2_is_a_shared_device(handle)) {
+      g_mutex_lock(&v4lc->lock);
+      imx_v4l2_remove_flow(v4lc, handle);
+      close (handle->v4l2_fd);
+      g_mutex_unlock(&v4lc->lock);
     } else {
-      if (handle->v4l2_fd) {
-        GST_DEBUG ("close V4L2 device.");
-        close (handle->v4l2_fd);
-        handle->v4l2_fd = 0;
-      }
-      g_slice_free1 (sizeof(IMXV4l2Handle), handle);
+      close (handle->v4l2_fd);
     }
+    handle->v4l2_fd = 0;
   }
 
+  g_slice_free1 (sizeof(IMXV4l2Handle), handle);
+
   return 0;
 }
 
@@ -1581,7 +1741,7 @@ static void * gst_imx_v4l2_find_buffer(gpointer v4l2handle, PhyMemBlock *memblk)
 
     if (handle->allocated >= MAX_BUFFER) {
       GST_ERROR ("No more v4l2 buffer for allocating.\n");
-      return -1;
+      return NULL;
     }
 
     v4l2buf = &handle->buffer_pair[handle->allocated].v4l2buffer;
@@ -1589,7 +1749,7 @@ static void * gst_imx_v4l2_find_buffer(gpointer v4l2handle, PhyMemBlock *memblk)
     v4l2buf->type = handle->type;
     v4l2buf->memory = handle->memory_mode;
     v4l2buf->index = handle->allocated;
-    v4l2buf->m.userptr = memblk->paddr;
+    v4l2buf->m.userptr = (unsigned long)memblk->paddr;
     v4l2buf->length = memblk->size;
     handle->buffer_pair[handle->allocated].vaddr = memblk->vaddr;
 
@@ -1600,7 +1760,7 @@ static void * gst_imx_v4l2_find_buffer(gpointer v4l2handle, PhyMemBlock *memblk)
     return v4l2buf;
   }
 
-  GST_ERROR ("Can't find the buffer 0x%08X.", memblk->paddr);
+  GST_ERROR ("Can't find the buffer 0x%08X.", (unsigned int)memblk->paddr);
   return NULL;
 }
 
@@ -1608,20 +1768,39 @@ gint gst_imx_v4l2_set_buffer_count (gpointer v4l2handle, guint count, guint memo
 {
   IMXV4l2Handle *handle = (IMXV4l2Handle*)v4l2handle;
   struct v4l2_requestbuffers buf_req;
+  MFWGstV4LSrcCommon * v4lc;
 
-  GST_DEBUG ("requeset for (%d) buffers.", count);
+  GST_DEBUG ("request for (%d) buffers.", count);
 
   memset(&buf_req, 0, sizeof(buf_req));
 
   buf_req.type = handle->type;
-  buf_req.count = MAX_V4L2_BUFFER;
+  buf_req.count = count;
   handle->memory_mode = buf_req.memory = memory_mode;
-  if (ioctl(handle->v4l2_fd, VIDIOC_REQBUFS, &buf_req) < 0) {
-    GST_ERROR("Request %d buffers failed\n", count);
+
+  v4lc = &v4lCommon[handle->device_map_id];
+
+  if (!imx_v4l2_is_a_shared_device(handle)){
+    if (ioctl(handle->v4l2_fd, VIDIOC_REQBUFS, &buf_req) < 0) {
+      GST_ERROR("Request %d buffers failed\n", count);
+      return -1;
+    }
+  } else if(imx_v4l2_is_primary_flow(v4lc, handle)) {
+      buf_req.count = MAX_V4L2_BUFFER;
+      if (ioctl(handle->v4l2_fd, VIDIOC_REQBUFS, &buf_req) < 0) {
+        GST_ERROR("Request %d buffers failed\n", count);
+        return -1;
+      }
+  }
+
+  if(buf_req.count < count){
+    GST_ERROR("Failed to setup v4l2 buffers, requested %d buffers but got %d, no memory",
+      count,
+      buf_req.count);
     return -1;
   }
-  handle->buffer_count = buf_req.count;
 
+  handle->buffer_count = buf_req.count;
   return 0;
 }
 
@@ -1672,10 +1851,10 @@ gint gst_imx_v4l2_allocate_buffer (gpointer v4l2handle, PhyMemBlock *memblk)
   }
 
   GST_DEBUG ("Allocated v4l2buffer(%p), type(%d), memblk(%p), paddr(%p), size(%d).",
-      v4l2buf, v4l2buf->type, memblk, v4l2buf->m.offset, v4l2buf->length);
+      v4l2buf, v4l2buf->type, memblk, (void*)v4l2buf->m.offset, v4l2buf->length);
 
   memblk->size = v4l2buf->length;
-  memblk->vaddr = mmap (NULL, v4l2buf->length, PROT_READ | PROT_WRITE, MAP_SHARED, handle->v4l2_fd, v4l2buf->m.offset);
+  memblk->vaddr = mmap (NULL, v4l2buf->length, PROT_READ | PROT_WRITE, MAP_SHARED, handle->v4l2_fd, (off_t)v4l2buf->m.offset);
   if (!memblk->vaddr) {
     GST_ERROR ("mmap v4lbuffer address failed\n");
     return -1;
@@ -1724,7 +1903,7 @@ gint gst_imx_v4l2_register_buffer (gpointer v4l2handle, PhyMemBlock *memblk)
   v4l2buf->type = handle->type;
   v4l2buf->memory = handle->memory_mode;
   v4l2buf->index = handle->allocated;
-  v4l2buf->m.userptr = memblk->paddr;
+  v4l2buf->m.userptr = (int)memblk->paddr;
   v4l2buf->length = memblk->size;
   handle->buffer_pair[handle->allocated].vaddr = memblk->vaddr;
 
@@ -1768,13 +1947,9 @@ gint gst_imx_v4l2_free_buffer (gpointer v4l2handle, PhyMemBlock *memblk)
     handle->allocated = 0;
   }
 
-  if (handle->allocated == 0 && handle->pending_close) {
+  if (!handle->allocated && handle->pending_close) {
     handle->pending_close = FALSE;
-    if (handle->v4l2_fd) {
-      close (handle->v4l2_fd);
-      handle->v4l2_fd = 0;
-    }
-    g_slice_free1 (sizeof(IMXV4l2Handle), handle);
+    gst_imx_v4l2_close_device(handle);
   }
 
   return 0;
@@ -1782,6 +1957,7 @@ gint gst_imx_v4l2_free_buffer (gpointer v4l2handle, PhyMemBlock *memblk)
 
 static gint imx_v4l2_do_queue_buffer (IMXV4l2Handle *handle, struct v4l2_buffer *v4l2buf)
 {
+  MFWGstV4LSrcCommon * v4lc;
   struct timeval queuetime;
 
   if (!v4l2buf) {
@@ -1789,14 +1965,96 @@ static gint imx_v4l2_do_queue_buffer (IMXV4l2Handle *handle, struct v4l2_buffer
     return -1;
   }
 
+  v4lc = &v4lCommon[handle->device_map_id];
+
   /*display immediately */
   gettimeofday (&queuetime, NULL);
   v4l2buf->timestamp = queuetime;
 
-  if (ioctl (handle->v4l2_fd, VIDIOC_QBUF, v4l2buf) < 0) {
-    GST_ERROR ("queue v4l2 buffer failed.");
+  if (!imx_v4l2_is_a_shared_device(handle) || imx_v4l2_is_primary_flow(v4lc, handle)) {
+    if (ioctl (handle->v4l2_fd, VIDIOC_QBUF, v4l2buf) < 0) {
+      GST_ERROR ("queue v4l2 buffer failed.");
+      return -1;
+    }
+  }
+
+  return 0;
+}
+
+void
+print_buffer_pair(IMXV4l2BufferPair *buffer_pair, int flow_index)
+{
+  for(int i = 0; i < MAX_BUFFER; i++){
+    if(!buffer_pair[i].gstbuffer){
+      continue;
+    }
+
+    GST_WARNING("Flow[%2d] : buffer_pair[%2d], "
+      "v4l2memblk: %10p, "
+      "gstbuffer: %10p, "
+      "vaddr: %10p",
+      flow_index,
+      i,
+      buffer_pair[i].v4l2memblk,
+      buffer_pair[i].gstbuffer,
+      buffer_pair[i].vaddr);
+  }
+}
+
+gint
+gst_imx_v4l2_query_buffer(IMXV4l2Handle *handle, struct v4l2_buffer *v4l2buf)
+{
+  if (ioctl(handle->v4l2_fd, VIDIOC_QUERYBUF, v4l2buf) < 0) {
+    GST_ERROR ("Failed to query v4l2 buffer. %s", strerror( errno ));
     return -1;
   }
+  return 0;
+}
+
+gint gst_imx_v4l2_restart(gpointer v4l2handle)
+{
+  struct v4l2_buffer * v4l2buf;
+  struct v4l2_buffer v4l2bufq;
+
+  PhyMemBlock *memblk;
+  IMXV4l2Handle *handle = (IMXV4l2Handle*)v4l2handle;
+
+  if(!handle){
+    GST_WARNING("Failed to restart, handle is null");
+    return 0;
+  }
+
+  for (int i = 0; i < MAX_BUFFER; i++) {
+    if (!handle->buffer_pair[i].gstbuffer) {
+      continue;
+    }
+
+    memblk = handle->buffer_pair[i].v4l2memblk;
+    v4l2buf = (struct v4l2_buffer *)gst_imx_v4l2_find_buffer(v4l2handle, memblk);
+    if(v4l2buf == NULL){
+	    GST_ERROR("Failed to find buffer");
+	    return -1;
+    }
+
+    memset(&v4l2bufq, 0, sizeof(struct v4l2_buffer));
+    v4l2bufq.index = v4l2buf->index;
+    v4l2bufq.type = v4l2buf->type;
+    v4l2bufq.memory = handle->memory_mode;
+
+    if (gst_imx_v4l2_query_buffer(handle, &v4l2bufq)) {
+        GST_ERROR("Failed to query buffer");
+        continue;
+    }
+      
+    if (v4l2bufq.flags & (V4L2_BUF_FLAG_QUEUED | V4L2_BUF_FLAG_DONE)) {
+        GST_INFO("Buffer %d is either in the driver's incoming or outgoing queue",
+                 v4l2bufq.index);
+    }
+    else if(v4l2bufq.flags & (V4L2_BUF_FLAG_MAPPED | V4L2_BUF_FLAG_PREPARED)) {
+        GST_INFO("Buffer %d is not queued, requeuing it", v4l2bufq.index);
+        imx_v4l2_do_queue_buffer(handle, v4l2buf);
+    }
+  }
 
   return 0;
 }
@@ -1804,12 +2062,15 @@ static gint imx_v4l2_do_queue_buffer (IMXV4l2Handle *handle, struct v4l2_buffer
 gint gst_imx_v4l2_queue_v4l2memblk (gpointer v4l2handle, PhyMemBlock *memblk, GstVideoFrameFlags flags)
 {
   IMXV4l2Handle *handle = (IMXV4l2Handle*)v4l2handle;
+  MFWGstV4LSrcCommon * v4lc;
   struct v4l2_buffer *v4l2buf;
   gint index;
 
   v4l2buf = (struct v4l2_buffer *)gst_imx_v4l2_find_buffer(v4l2handle, memblk);
-  if (!v4l2buf)
+  if (!v4l2buf) {
+    GST_WARNING ("Failed to find buffer");
     return -1;
+  }
 
   index = v4l2buf->index;
 
@@ -1850,9 +2111,12 @@ gint gst_imx_v4l2_queue_v4l2memblk (gpointer v4l2handle, PhyMemBlock *memblk, Gs
       }
     }
 
-    if (ioctl (handle->v4l2_fd, VIDIOC_STREAMON, &handle->type) < 0) {
-      GST_ERROR ("Stream on V4L2 device failed.\n");
-      return -1;
+    v4lc = imx_v4l2_get_v4lc(handle);
+    if (!imx_v4l2_is_a_shared_device(handle) || imx_v4l2_is_primary_flow(v4lc, handle)) {
+      if (ioctl (handle->v4l2_fd, VIDIOC_STREAMON, &handle->type) < 0) {
+        GST_ERROR ("Stream on V4L2 device failed.\n");
+        return -1;
+      }
     }
     handle->streamon = TRUE;
     GST_DEBUG ("V4L2 device is STREAMON.");
@@ -1861,6 +2125,7 @@ gint gst_imx_v4l2_queue_v4l2memblk (gpointer v4l2handle, PhyMemBlock *memblk, Gs
 
   if (imx_v4l2_do_queue_buffer (handle, v4l2buf) < 0) {
     handle->buffer_pair[v4l2buf->index].v4l2memblk = NULL;
+    GST_ERROR ("Failed to queue buffer");
     return -1;
   }
 
@@ -1903,8 +2168,10 @@ gint gst_imx_v4l2_queue_gstbuffer (gpointer v4l2handle, GstBuffer *buffer, GstVi
 
   GST_DEBUG ("queue gstbuffer(%p).", buffer);
   v4l2buf = (struct v4l2_buffer *) gst_imx_v4l2_find_buffer(v4l2handle, memblk);
-  if (!v4l2buf)
+  if (!v4l2buf) {
+    GST_WARNING ("Failed to find buffer");
     return -1;
+  }
 
   if (handle->buffer_pair[v4l2buf->index].gstbuffer) {
     if (handle->buffer_pair[v4l2buf->index].gstbuffer != buffer) {
@@ -1912,7 +2179,7 @@ gint gst_imx_v4l2_queue_gstbuffer (gpointer v4l2handle, GstBuffer *buffer, GstVi
           buffer, memblk, handle->buffer_pair[v4l2buf->index].gstbuffer);
     }
     GST_WARNING ("gstbuffer(%p) for (%p) not dequeued yet but queued again, index(%d).",
-        handle->buffer_pair[v4l2buf->index].gstbuffer, index);
+        buffer, handle->buffer_pair[v4l2buf->index].gstbuffer, (int)index);
   }
 
   if (gst_imx_v4l2_queue_v4l2memblk (v4l2handle, memblk, flags) < 0) {
@@ -1925,19 +2192,234 @@ gint gst_imx_v4l2_queue_gstbuffer (gpointer v4l2handle, GstBuffer *buffer, GstVi
   return 0;
 }
 
+/*
+ * Must be called with the v4l2c->lock.
+ *
+ * Iterates through a device's active secondary flows. If the flow is
+ * waiting for the buffer the v4l2buf is copied to the flows buffer
+ * array.
+ */
+int
+imx_v4l2_copy_buffer_to_secondary_flows(MFWGstV4LSrcCommon *v4lc, struct v4l2_buffer *v4l2buf)
+{
+  /* Notice that the loop starts at index 1. Position 0 is the
+   * primary flow and thus ignored. */
+  for (int i = 1; i < v4lc->activeFlows; i++) {
+
+    if (v4lc->buffer_pair[i][v4l2buf->index].v4l2memblk) {
+      GST_DEBUG("Copying %d to flow %d fd: %d", v4l2buf->index, i, v4lc->fd_v4l[i]);
+
+      v4lc->buf[i][v4lc->wrBuf[i]].v4l2buf = *v4l2buf;
+      v4lc->buf[i][v4lc->wrBuf[i]].new = 1;
+
+      if (++v4lc->wrBuf[i] >= MAX_BUFFER){
+        v4lc->wrBuf[i] = 0;
+      }
+      /* Signal the flow that a new buffer has been
+       * assigned to it. */
+      GST_DEBUG("Waking up %d, sem %p", i, v4lc->sem[i]);
+      if(sem_post(v4lc->sem[i])){
+        GST_ERROR ("Failed to post on sem %p, %s", v4lc->sem[i], strerror( errno ));
+        return -1;
+      }
+    }
+  }
+  return 0;
+}
+
 #define TRY_TIMEOUT (500000) //500ms
-#define TRY_INTERVAL (1000) //1ms
+#define TRY_INTERVAL (10000) //10ms
 #define MAX_TRY_CNT (TRY_TIMEOUT/TRY_INTERVAL)
 
+int
+xvidioc_dqbuf(int fd, struct v4l2_buffer *v4l2buf)
+{
+  gint trycnt;
+
+  trycnt = 0;
+  while (ioctl (fd, VIDIOC_DQBUF, v4l2buf) < 0) {
+    trycnt++;
+    if(trycnt >= MAX_TRY_CNT) {
+      return -1;
+    }
+    usleep (TRY_INTERVAL);
+  }
+  return 0;
+}
+
+/* Must be called with v4lc->lock */
+int
+imx_v4l2_find_flow_index_from_handle(MFWGstV4LSrcCommon * v4lc, IMXV4l2Handle *handle)
+{
+  for(int i=0; i<v4lc->activeFlows; i++){
+    if(v4lc->fd_v4l[i] == handle->v4l2_fd){
+      return i;
+    }
+  }
+  return -1;
+}
+
+int
+imx_v4l2_is_primary_flow(MFWGstV4LSrcCommon * v4lc, IMXV4l2Handle *handle)
+{
+  return handle->v4l2_fd == v4lc->fd_v4l[0];
+}
+
+int
+imx_v4l2_is_a_shared_device(IMXV4l2Handle *handle)
+{
+  return handle->device_map_id < SHARED_DEVICES;
+}
+
+gint
+imx_v4l2_dequeue_shared_device_memblk(IMXV4l2Handle *handle, struct v4l2_buffer *v4l2buf, PhyMemBlock **memblk)
+{
+  int dequeued_v4l2buf = 0;
+  int flow_index;
+  int readbuffer_index;
+
+  struct V4LSrcCommonBuf *readbuffer;
+  MFWGstV4LSrcCommon * v4lc;
+
+  while (!dequeued_v4l2buf) {
+    v4lc = &v4lCommon[handle->device_map_id];
+
+    g_mutex_lock(&v4lc->lock);
+
+    flow_index = imx_v4l2_find_flow_index_from_handle(v4lc, handle);
+
+    /* Restart flow by requeuing all buffers if requested */
+    if (v4lc->state[flow_index] == V4CRESTART) {
+        v4lc->state[flow_index] = V4CIDLE;
+        gst_imx_v4l2_restart(handle);
+    }
+
+    if (imx_v4l2_is_primary_flow(v4lc, handle)) {
+        if(xvidioc_dqbuf(handle->v4l2_fd, v4l2buf)){
+            GST_ERROR ("Dequeue buffer from v4l2 device failed.");
+            g_mutex_unlock(&v4lc->lock);
+            return -1;
+        }
+
+        imx_v4l2_copy_buffer_to_secondary_flows(v4lc, v4l2buf);
+
+        /* If the primary flow used to be a secondary flow there is a
+         * possibility that the dequeued v4l2 buffer is not a buffer
+         * that was queued with the v4l2 driver by the current primary
+         * flow. The buffer was queued by the previous primary flow
+         * and thus the current primary flow has no bookkeeping of
+         * this buffer in its buffer_pair. */
+        if(!handle->buffer_pair[v4l2buf->index].v4l2memblk){
+            GST_DEBUG("PRIMARY fd, %d, DQd buffer %d. Not for me",
+                      handle->v4l2_fd,
+                      v4l2buf->index);
+
+            g_mutex_unlock(&v4lc->lock);
+            continue;
+        }
+        dequeued_v4l2buf = 1;
+        g_mutex_unlock(&v4lc->lock);
+
+    } else {
+      sem_t * sem_p;
+      flow_index = imx_v4l2_find_flow_index_from_handle(v4lc, handle);
+      v4lc->state[flow_index] = V4CWAIT;
+      sem_p = v4lc->sem[flow_index];
+      g_mutex_unlock(&v4lc->lock);
+
+      /* Wait for the primary flow to copy a buffer to us, OR that
+       * the primary flow is removed and we are now the primary
+       * flow */
+      if(sem_wait(sem_p)){
+	GST_ERROR ("Failed to wait on sem %p, %s",
+		   sem_p,
+		   strerror( errno ));
+	return -1;
+      }
+
+      g_mutex_lock(&v4lc->lock);
+
+      /* Update the index of the flow. If a flow has been removed during
+       * the wait the flow's index has changed. */
+      flow_index = imx_v4l2_find_flow_index_from_handle(v4lc, handle);
+
+      readbuffer_index = v4lc->rdBuf[flow_index];
+      readbuffer = &v4lc->buf[flow_index][readbuffer_index];
+
+      /*
+       * Situations where the secondary flow is now the primary flow:
+       *
+       * 1. The primary flow was removed while the secondary flow was
+       * waiting. In this case it is the REMOVAL of the primary flow that
+       * released the flow. The secondary flow has been promoted to primary
+       * in a V4CRESTART state and needs to have all it's queued buffers
+       * requeued with the driver.  It does not have any new copied buffers
+       * from the (former) primary flow and must go to the next iteration
+       * in the while loop in order to dequeue a buffer for itself and
+       * every other flow on the device.
+       *
+       * 2. The primary flow has copied a buffer to the secondary flow and
+       * woken the secondary flow up. But before the secondary flow was
+       * able to get the lock again the primary flow was removed. The flow
+       * DOES have a buffer copied to it from the previous primary flow. It
+       * still needs to be restarted to get any remaining queued buffers
+       * requeued with the driver.
+       *
+       * We are checking for readbuffer->new here to determine whether the
+       * secondary flow has a buffer copied to it or not.
+       */
+      if(imx_v4l2_is_primary_flow(v4lc, handle)){
+	GST_DEBUG("Secondary flow with fd %d is now primary. Active Flows %d",
+		  handle->v4l2_fd,
+		  v4lc->activeFlows);
+
+	/* Case 1 */
+	if (v4lc->state[flow_index] == V4CRESTART) {
+	  g_mutex_unlock(&v4lc->lock);
+	  continue;
+	}
+
+	/* Case 2 */
+	if (readbuffer->new) {
+	  v4lc->state[flow_index] = V4CRESTART;
+	} else {
+	  GST_ERROR("New primary flow released without new buffer or RESTART state");
+	}
+      } else {
+	/* Normal path when still a secondary flow */
+	v4lc->state[flow_index] = V4CIDLE;
+      }
+
+      *v4l2buf = readbuffer->v4l2buf;
+      readbuffer->new = 0;
+
+      if (++v4lc->rdBuf[flow_index] >= MAX_BUFFER){
+        v4lc->rdBuf[flow_index]=0;
+      }
+
+      dequeued_v4l2buf = 1;
+      g_mutex_unlock(&v4lc->lock);
+    }
+  }
+
+  *memblk = handle->buffer_pair[v4l2buf->index].v4l2memblk;
+  handle->buffer_pair[v4l2buf->index].v4l2memblk = NULL;
+
+  if ((! *memblk) || (v4l2buf->m.offset != (__u32)(*memblk)->paddr)) {
+    GST_ERROR("memblk is NULL or Out of sync");
+    return -1;
+  }
+  return 0;
+}
+
 gint gst_imx_v4l2_dequeue_v4l2memblk (gpointer v4l2handle, PhyMemBlock **memblk,
     GstVideoFrameFlags * flags)
 {
   IMXV4l2Handle *handle = (IMXV4l2Handle*)v4l2handle;
   struct v4l2_buffer v4l2buf;
-  gint trycnt = 0;
 
-  if (handle->queued_count <= MAX(handle->v4l2_hold_buf_num, handle->streamon_count)) {
-    GST_DEBUG ("current queued %d", handle->queued_count);
+  if ( handle->queued_count <= MAX(handle->v4l2_hold_buf_num, handle->streamon_count)) {
+    GST_ERROR ("current queued %d", handle->queued_count);
     *memblk = NULL;
     return 0;
   }
@@ -1946,14 +2428,18 @@ gint gst_imx_v4l2_dequeue_v4l2memblk (gpointer v4l2handle, PhyMemBlock **memblk,
   v4l2buf.type = handle->type;
   v4l2buf.memory = handle->memory_mode;
 
-  while (ioctl (handle->v4l2_fd, VIDIOC_DQBUF, &v4l2buf) < 0) {
-    trycnt ++;
-    if(trycnt >= MAX_TRY_CNT) {
+  if (imx_v4l2_is_a_shared_device(handle)) {
+    if (imx_v4l2_dequeue_shared_device_memblk(handle, &v4l2buf, memblk) < 0) {
+      return -1;
+    }
+  } else {
+    if(xvidioc_dqbuf(handle->v4l2_fd, &v4l2buf)){
       GST_ERROR ("Dequeue buffer from v4l2 device failed.");
       return -1;
     }
 
-    usleep (TRY_INTERVAL);
+    *memblk = handle->buffer_pair[v4l2buf.index].v4l2memblk;
+    handle->buffer_pair[v4l2buf.index].v4l2memblk = NULL;
   }
 
   if (v4l2buf.field == V4L2_FIELD_INTERLACED) {
@@ -1976,16 +2462,13 @@ gint gst_imx_v4l2_dequeue_v4l2memblk (gpointer v4l2handle, PhyMemBlock **memblk,
     default: GST_WARNING("unknown field type"); break;
   }
 
-  *memblk = handle->buffer_pair[v4l2buf.index].v4l2memblk;
-
   GST_DEBUG ("deque v4l2buffer memblk (%p), paddr(%p), index (%d)",
       *memblk, (*memblk)->paddr, v4l2buf.index);
 
-  handle->buffer_pair[v4l2buf.index].v4l2memblk = NULL;
   handle->queued_count--;
 
   GST_DEBUG ("deque v4l2buffer memblk (%p), index (%d), flags (%d)",
-      v4l2buf.index, handle->buffer_pair[v4l2buf.index].v4l2memblk, *flags);
+      handle->buffer_pair[v4l2buf.index].v4l2memblk, v4l2buf.index, *flags);
 
   return 0;
 }
@@ -2006,12 +2489,21 @@ gint gst_imx_v4l2_dequeue_gstbuffer (gpointer v4l2handle, GstBuffer **buffer,
     return -1;
   }
 
-  if (!memblk)
+  if (!memblk) {
+    GST_WARNING ("Empty buffer received");
     return 0;
+  }
 
   v4l2buf = (struct v4l2_buffer *) gst_imx_v4l2_find_buffer(v4l2handle, memblk);
-  if (!v4l2buf)
+  if (!v4l2buf) {
+    GST_ERROR ("buffer not found");
+    return -1;
+  }
+
+  if(handle->buffer_pair[v4l2buf->index].gstbuffer == NULL){
+    GST_ERROR("gstbuffer for buffer_pair[%d] is NULL", v4l2buf->index);
     return -1;
+  }
 
   *buffer = handle->buffer_pair[v4l2buf->index].gstbuffer;
   handle->buffer_pair[v4l2buf->index].gstbuffer = NULL;
-- 
2.25.1

