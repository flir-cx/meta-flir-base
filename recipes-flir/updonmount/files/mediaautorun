#!/bin/sh
# To be called by inotify script
# $1: actual event (Expected to be "n")
# $2: supervised directory (or file) (Expected to be "/media")
# $3: name of subfile (in directory). (Expected to be "mmcblk1p1)"

GUI_EXIST=0
UGUIBIN=/tmp/bin
UGUILIB=/tmp/lib
QT5PLUGINS=/tmp/qt5

logger -p info -s "mediaautorun: called $1 $2 $3"

EVT=$1
SDIR=$2
SFILE=$3

# We need to sleep a little to let mount succeed
sleep 2

# Check that media is mmcblk1p1 (only supported device)

if [ "$SDIR" = "/dev/flirfs" ]; then
# auto mount active, use implicit mount point instead
    SDIR=/media/autofs
fi

if [ "$SDIR" != "/media/autofs" ]; then
    logger -p info -s "mediaautorun: not called with /media/autofs - aborts"
    exit 0
fi

if [ "$SFILE" != "mmcblk1p1" ]; then
    logger -p info -s "mediaautorun: not called with mmcblk1p1 - aborts"
    exit 0
fi

export LD_LIBRARY_PATH=/FLIR/usr/lib
UPDATE_DONE="${SDIR}/${SFILE}/update.don"
# rls (and other resource commands) might hang. Do not use in script
# SERIAL_NUMBER=$(/FLIR/usr/bin/rls .version.product.serial | awk '{print $2}' | sed 's/\"//g')

#if grep ^$SERIAL_NUMBER $UPDATE_DONE; then
if [ -f ${UPDATE_DONE} ]; then
    logger -p info -s "mediaautorun: already updated marker update.don exists - aborts"
    exit 0
fi

FILE=${SDIR}/${SFILE}/update.ful

if [ ! -e ${FILE} ]; then 
    logger -p info -s "mediaautorun: no $FILE exists - aborts"
    exit 0
fi

function clear_fb()
{
    if [ ! -z "${FBCLEARCMD}" ]; then
        # Run FBCLEARCMD if defined in systemd service unit file
        logger -p info -s "runs FBCLEARCMD:$FBCLEARCMD"
        $FBCLEARCMD
    fi
}

function wait_for_fwupdateui()
{
    while $(ps | grep -v grep | grep fwupdateui &>/dev/null)
    do
        sleep 1
    done
}

function install_fwupdategui()
{
    # We cannot run fwupdateui and libs from /FLIR/usr
    # We might want to update these files, so we need to run elsewhere
    mkdir -p $UGUIBIN
    cp /FLIR/usr/bin/fwupdateui $UGUIBIN
    if [ $? -ne 0 ]; then
        # No fwupdateui present, bail out
        logger -p warning -s "mediaautorun: NO fwupdategui present..."
        return 1;
    fi

    # This is tested with Qt5.3.0 and Qt5.6.2. Any other version will
    # likely crash and burn since components seem to move around
    # quite a bit. A better solution would be an updateui without
    # Qt...
    mkdir -p $UGUILIB
    cp /FLIR/usr/lib/libQt5Qml.so* $UGUILIB
    cp /FLIR/usr/lib/libQt5Quick.so* $UGUILIB
    cp /FLIR/usr/lib/libQt5Core.so* $UGUILIB
    cp /FLIR/usr/lib/libQt5Gui.so* $UGUILIB
    cp /FLIR/usr/lib/libQt5Network.so* $UGUILIB
    [ -f /FLIR/usr/lib/libQt5DBus.so.5 ] && \
        cp /FLIR/usr/lib/libQt5DBus.so.5* $UGUILIB
    [ -f /FLIR/usr/lib/libQt5EglDeviceIntegration.so.5 ] && \
        cp /FLIR/usr/lib/libQt5EglDeviceIntegration.so.5* $UGUILIB

    rm -rf /usr/local/Qt-5.3.0
    mkdir -p ${QT5PLUGINS}/lib ${QT5PLUGINS}/plugins/platforms ${QT5PLUGINS}/plugins/egldeviceintegrations
    ls -d /usr/local
    if [ $? -ne 0 ]; then
        # No /usr/local to generate link in
        CREATEDLOCAL=1
        mkdir -p /usr/local
    fi
    ln -s ${QT5PLUGINS} /usr/local/Qt-5.3.0
    ln -s ${QT5PLUGINS} /usr/local/Qt-5.6.2

    cp /FLIR/usr/lib/plugins/platforms/libqeglfs.so ${QT5PLUGINS}/plugins/platforms
    [ -f /FLIR/usr/lib/plugins/egldeviceintegrations/libqeglfs-viv-integration.so ] && \
        cp /FLIR/usr/lib/plugins/egldeviceintegrations/libqeglfs-viv-integration.so \
        ${QT5PLUGINS}/plugins/egldeviceintegrations

    cp -r /FLIR/usr/bin/qml ${QT5PLUGINS}/
    cp -r /FLIR/usr/lib/fonts ${QT5PLUGINS}/lib

    logger -p info -s "mediaautorun: fwupdategui copied to /tmp"
    GUI_EXIST=1
    return 0
}

function remove_fwupdateui()
{
    logger -p info -s "removes tmp fwupdategui/Qt installation"
    rm -rf $UGUIBIN $UGUILIB $QT5PLUGINS /usr/local/Qt-5.3.0
    if [ ! -z "$CREATEDLOCAL" ]; then
         rm -rf /usr/local
    fi

    clear_fb
}

function start_fwupdateui()
{
    rm /tmp/fwupdateui-retval 2>/dev/null
    rm /tmp/fwupdateui.cfg 2>/dev/null

    if [ $GUI_EXIST -ne 0 ]; then
        echo $1 >  /tmp/fwupdateui.cfg
        echo $2 >> /tmp/fwupdateui.cfg
        echo $3 >> /tmp/fwupdateui.cfg

        export LD_LIBRARY_PATH=$UGUILIB
        ${UGUIBIN}/fwupdateui /tmp/fwupdateui.cfg
        retval=$?
        echo $retval > /tmp/fwupdateui-retval
    fi
}

function right_button_pressed()
{
    if [ $GUI_EXIST -eq 0 ]
    then
        logger -p info -s "Checked right_button_pressed - no GUI"
        return 0
    fi

    if [ ! -f /tmp/fwupdateui-retval ]
    then
        logger -p info -s "Checked right_button_pressed - GUI still running"
        return 0
    fi

    value=$(cat /tmp/fwupdateui-retval)
    case "$value" in
        0)
            return 0
            ;;
        123)
            return 1
            ;;
        *)
            logger -p info -s "Checked right_button_pressed - GUI probabaly failed to start"
            return 0
            ;;
    esac
}

# update.ful exists, and no update.don
# Check signature

fulverify -s $SDIR/$SFILE
if [ $? -ne 0 ]; then
    logger -p info -s "mediaautorun: bad/missing signature in update - exits"
    exit 0
fi

# special xxxx
install_fwupdategui
if [ -f ${UGUIBIN}/fwupdateui ]; then
    GUI_EXIST=1
fi

THELISTFILE=/tmp/install_list
rm -f $THELISTFILE

FLIRID="#FLIRlistupdate 1.0"
while read line 
do
#   echo -e "line:$line";
    if [ "$line" == "$FLIRID" ]; then
#       echo "Is OK to install"
        INSTALLOK=OK
    fi

    if [ -z "$line" ]; then
        continue
    fi;

    echo $line | grep -qve "^#"
    if [ $? -eq 0 -a "$INSTALLOK" == "OK" ]; then
        echo $line >>$THELISTFILE
#       echo "$line marked as package"
        ANYFILE=OK
    fi
done < $FILE

if [ "$ANYFILE" != "OK" ]; then
    logger -p info -s "No files to install"
    echo `date`":No files to install" >> ${SDIR}/${SFILE}/update.out

    remove_fwupdateui
    exit 0
fi

# Check that install packages exists
while read package 
do
#   echo "checker - line:$package";
    if [ ! -f ${SDIR}/${SFILE}/$package ]; then
        # At least one bad package
        logger -p warning -s "Missing file: ${SDIR}/${SFILE}/$package - aborts"
        echo `date`":Missing file ${SDIR}/${SFILE}/$package - aborts" >> ${SDIR}/${SFILE}/update.out

        remove_fwupdateui
        exit -1
    fi
done < $THELISTFILE

echo "Packages scanned"

# We want facet/fwupdateui to display some kind of information about 
# the update...
# In newer .ful files, a row "# UPDNAME:<text>" Will exist
# <text> is to be extracted and shown to user (A short description of update)
UPDROW=$(grep UPDNAME $FILE)
if [ ! -z "${UPDROW}" ]; then
    UPDATE_INFO=${UPDROW##*UPDNAME:}
else
    # Old update.ful
    UPDATE_INFO="unspecified firmware update"
fi
echo UPDATE_INFO:$UPDATE_INFO

# Is facet replying to our update request?
FACET_UPDATE_REPLY="false"
# Does the user want to proceed with the update?
FACET_UPDATE_PROCEED="false"
# Should this script proceed and perform the update?
# Default to true.
PROCEED_WITH_UPDATE="true"
# Send an updateRequest to facet, capture return code and reply
DBUS_REPLY=$(dbus-send --system --type=method_call --print-reply=literal \
    --dest=se.flir.facet2.ui / se.flir.facet2.ui.updateRequest "string:${UPDATE_INFO}")
DBUS_RESULT=$?
FACET_UPDATE_REPLY=$(echo ${DBUS_REPLY} | cut -d" " -f2)
# If we couldn't talk to facet, we assume facet is dead. If we
# can talk to facet, we give the user 60 seconds to confirm to
# proceed with the update. If we don't get a reply, we don't
# perform an update.
if [ ${DBUS_RESULT} -eq 0 -a "$FACET_UPDATE_REPLY" == "true" ]; then
    for i in `seq 1 60`; do
        # Use --print-reply=literal to only capture the string itself
        DBUS_REPLY=$(dbus-send --system --type=method_call --print-reply=literal \
            --dest=se.flir.facet2.ui / se.flir.facet2.ui.updateReply)
        FACET_UPDATE_PROCEED=$(echo ${DBUS_REPLY})

        if [ "$FACET_UPDATE_PROCEED" == "update" ]; then
            echo "Got update"
            FACET_UPDATE_PROCEED="true"
            PROCEED_WITH_UPDATE="true"
            break
        elif [ "$FACET_UPDATE_PROCEED" == "cancel" ]; then
            echo "Got cancel"
            FACET_UPDATE_PROCEED="false"
            PROCEED_WITH_UPDATE="false"
            break
        elif [ "$FACET_UPDATE_PROCEED" == "wait" ]; then
            :
        else
            # API error
            break
        fi
        sleep 1
    done
else
    echo "Couldn't talk to facet or didn't get a positive answer to updateRequest"
    PROCEED_WITH_UPDATE="true"
fi

if [ "$PROCEED_WITH_UPDATE" != "true" ]; then
    echo "Aborting update"
    echo "MESSAGE:Update canceled by user" >> /tmp/fwupdateui.cfg.tmp
    # Mark update.ful as installed
    #    echo "$SERIAL_NUMBER" `date`":cancelled" >> $UPDATE_DONE
    echo `date`":cancelled" >> $UPDATE_DONE
    remove_fwupdateui
    sync
    exit 0
fi

# If we have reached this point, it either means that facet was
# not running or that facet was running and the user has accepted
# to update. In either case, we can kill flirapp.

systemctl status flirapp | grep -q "Active: active (running)"
if [ $? -eq 0 ]
then
    logger -p info -s "stops flirapp"
    systemctl stop flirapp
    sleep 5
    STOPPEDAPP=yes
fi

# If we never got a reply from facet, it means that the user
# hasn't been asked whether to upgrade or not. Let's do it.
if [ "$FACET_UPDATE_REPLY" != "true" ]; then
    start_fwupdateui "TITLE:New firmware ready to install" "MESSAGE:A firmware ($UPDATE_INFO) is found on the SD card. Do you wish to update the current camera firmware?" "STATUS:TIMEDQUERY:Cancel:Update" &

    # Without this sleep, the wonderful message passing doesn't work.
    sleep 1

    wait_for_fwupdateui

    if ! right_button_pressed; then

        echo "MESSAGE:Update canceled by user" >> /tmp/fwupdateui.cfg.tmp
        # Mark update.ful as installed
        #    echo "$SERIAL_NUMBER" `date`":cancelled" >> $UPDATE_DONE
        echo `date`":cancelled" >> $UPDATE_DONE
        remove_fwupdateui
        sync

        if [ "$STOPPEDAPP" == "yes" ]; then
            logger -p info -s "starts flirapp"
            systemctl start flirapp
        fi
        clear_fb
        exit 1
    fi
fi

start_fwupdateui "TITLE:Updating camera firmware" "MESSAGE:The camera firmware is currently being updated. This might take a while. Please do not turn off or reboot the camera during this time." "STATUS:UPDATING" &


REBOOT=0
FAILED_PKG=""
while read package 
do
    PKG_REBOOT=0
#   echo "handler - line:$package";
#   echo "calls: flir-updater.sh -f ${SDIR}/${SFILE}/$package -e -i /tmp/flir-update-laststatus"
    EXTEN="${package##*.}"
    case $EXTEN in
        opk|fuf)
            # These packages might fail. In that case, try remove+reinstall
            flir-updater.sh -f ${SDIR}/${SFILE}/$package -e  -i /tmp/flir-update-laststatus
            if [ $? -ne 0 ]; then
                logger -p warning -s "first install of $package failed, tries reinstall" 
                # remove
                flir-updater.sh -f ${SDIR}/${SFILE}/$package -r do
                flir-updater.sh -f ${SDIR}/${SFILE}/$package -e  -i /tmp/flir-update-laststatus
                if [ $? -ne 0 ]; then
                    logger -p warning -s "Still failure after reinstall"
                    if [ -z "$FAILED_PKG" ]; then
                        FAILED_PKG="$package"
                    fi
                fi
            fi
            ;;
           
        *)
            # All other types
            flir-updater.sh -f ${SDIR}/${SFILE}/$package -e  -i /tmp/flir-update-laststatus
            if [ $? -ne 0 ]; then
                logger -p warning -s "install of $package failed"
                if [ -z "$FAILED_PKG" ]; then
                    FAILED_PKG="$package"
                fi
            fi
            ;;
    esac
    grep -q reboot /tmp/flir-update-laststatus
    if [ $? -eq 0 ]; then
        PKG_REBOOT=1
        REBOOT=1
    fi
    echo `date`":Installed ${SDIR}/${SFILE}/$package:reboot-$PKG_REBOOT" >> ${SDIR}/${SFILE}/update.out
done < $THELISTFILE

if [ -z "$FAILED_PKG" ]; then
    # Mark update.ful as installed
    #echo "$SERIAL_NUMBER" $(date) >> $UPDATE_DONE
    echo $(date) >> $UPDATE_DONE
    sync
    echo "TITLE:Firmware update complete" > /tmp/fwupdateui.cfg.tmp
    if [ $REBOOT -eq 1 ];
    then
        echo "MESSAGE:The firmware was successfully installed. Reboot to finalize the upgrade or continue using the current firmware until you've restared the camera.." >> /tmp/fwupdateui.cfg.tmp
        echo "STATUS:TIMEDQUERY:Continue:Reboot:20" >> /tmp/fwupdateui.cfg.tmp
    else
        echo "MESSAGE:The firmware was successfully installed." >> /tmp/fwupdateui.cfg.tmp
        echo "STATUS:SHUTDOWN:10:OK" >> /tmp/fwupdateui.cfg.tmp
    fi
else
    # Don't mark as installed, allowing user to try again
    echo "TITLE:Firmware update failed" > /tmp/fwupdateui.cfg.tmp
    if [ $REBOOT -eq 1 ];
    then
        echo "MESSAGE:The firmware update failed for $FAILED_PKG. Reboot camera to use partial upgrade or continue using the current firmware until you've restared the camera.." >> /tmp/fwupdateui.cfg.tmp
        echo "STATUS:TIMEDQUERY:Continue:Reboot:20" >> /tmp/fwupdateui.cfg.tmp
    else
        echo "MESSAGE:The firmware update failed for $FAILED_PKG." >> /tmp/fwupdateui.cfg.tmp
        echo "STATUS:SHUTDOWN:10:OK" >> /tmp/fwupdateui.cfg.tmp
    fi
fi

cat /tmp/fwupdateui.cfg.tmp > /tmp/fwupdateui.cfg
wait_for_fwupdateui
remove_fwupdateui
if [ $REBOOT -eq 1 ] && right_button_pressed ; then
    logger -p warning -s "reboots system"
    reboot
fi

if [ "$STOPPEDAPP" == "yes" ]; then
    logger -p info -s "starts flirapp"
    systemctl start flirapp
fi

clear_fb
