From 4780c61f4aa3030ed8a87f07e47ec21726ad068a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ulf=20Palm=C3=A9r?= <ulf.palmer@teledyneflir.com>
Date: Wed, 18 May 2022 13:07:13 +0200
Subject: [PATCH] Added mod_dynamicfile

---
 src/Makefile.am       |   5 +
 src/mod_dynamicfile.c | 344 ++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 349 insertions(+)
 create mode 100644 src/mod_dynamicfile.c

diff --git a/src/Makefile.am b/src/Makefile.am
index 24915ae..55edb7b 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -233,6 +233,11 @@ mod_staticfile_la_SOURCES = mod_staticfile.c
 mod_staticfile_la_LDFLAGS = $(common_module_ldflags)
 mod_staticfile_la_LIBADD = $(common_libadd)
 
+lib_LTLIBRARIES += mod_dynamicfile.la
+mod_dynamicfile_la_SOURCES = mod_dynamicfile.c
+mod_dynamicfile_la_LDFLAGS = $(common_module_ldflags)
+mod_dynamicfile_la_LIBADD = $(common_libadd)
+
 lib_LTLIBRARIES += mod_dirlisting.la
 mod_dirlisting_la_SOURCES = mod_dirlisting.c
 mod_dirlisting_la_LDFLAGS = $(common_module_ldflags)
diff --git a/src/mod_dynamicfile.c b/src/mod_dynamicfile.c
new file mode 100644
index 0000000..48d68a8
--- /dev/null
+++ b/src/mod_dynamicfile.c
@@ -0,0 +1,344 @@
+#include "first.h"
+
+#include "request.h"
+#include "array.h"
+#include "buffer.h"
+#include "log.h"
+
+#include "plugin.h"
+
+#include <stdlib.h>
+#include <string.h>
+
+#include <ctype.h>
+#include "stat_cache.h"
+#include "http_date.h"
+#include "http_etag.h"
+#include "http_chunk.h"
+#include "http_header.h"
+
+#include "response.h"
+
+#include <ctype.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <errno.h>
+
+/**
+ * lighttpd plugin for serving frequently changing files
+ *
+ */
+
+
+//#define VALIDATE_READ_COMPLETE
+//#define USE_FOPEN
+
+/* plugin config for all request/connections */
+
+typedef struct {
+        const array *include_ext;
+	int retries;
+} plugin_config;
+
+typedef struct {
+	PLUGIN_DATA;
+        plugin_config defaults;
+	plugin_config conf;
+} plugin_data;
+
+/* init the plugin data */
+INIT_FUNC(mod_dynamicfile_init) {
+        return calloc(1, sizeof(plugin_data));
+}
+
+/* handle plugin config and check values */
+
+static void mod_dynamicfile_merge_config_cpv(plugin_config * const pconf, const config_plugin_value_t * const cpv) {
+    switch (cpv->k_id) { /* index into static config_plugin_keys_t cpk[] */
+      case 0: /* dynamicfile.array */
+        pconf->include_ext = cpv->v.a;
+        break;
+    case 1:   /* dynamicfile.retries */
+        pconf->retries = cpv->v.u;
+	
+    default:/* should not happen */
+        return;
+    }
+}
+
+static void mod_dynamicfile_merge_config(plugin_config * const pconf, const config_plugin_value_t *cpv) {
+    do {
+        mod_dynamicfile_merge_config_cpv(pconf, cpv);
+    } while ((++cpv)->k_id != -1);
+}
+
+static void mod_dynamicfile_patch_config(request_st * const r, plugin_data * const p) {
+    p->conf = p->defaults; /* copy small struct instead of memcpy() */
+    /*memcpy(&p->conf, &p->defaults, sizeof(plugin_config));*/
+    for (int i = 1, used = p->nconfig; i < used; ++i) {
+        if (config_check_cond(r, (uint32_t)p->cvlist[i].k_id))
+            mod_dynamicfile_merge_config(&p->conf, p->cvlist+p->cvlist[i].v.u2[0]);
+    }
+}
+
+/* handle plugin config and check values */
+
+SETDEFAULTS_FUNC(mod_dynamicfile_set_defaults) {
+  static const config_plugin_keys_t cpk[] = {
+      { CONST_STR_LEN("dynamic-file.include-extensions"),
+        T_CONFIG_ARRAY_VLIST,
+        T_CONFIG_SCOPE_CONNECTION }
+     ,{ CONST_STR_LEN("dynamic-file.retries"),
+        T_CONFIG_INT,
+        T_CONFIG_SCOPE_CONNECTION }
+     ,{ NULL, 0,
+        T_CONFIG_UNSET,
+        T_CONFIG_SCOPE_UNSET }
+    };
+
+    plugin_data * const p = p_d;
+    if (!config_plugin_values_init(srv, p, cpk, "mod_dynamicfile"))
+        return HANDLER_ERROR;
+
+    /* initialize p->defaults from global config context */
+    if (p->nconfig > 0 && p->cvlist->v.u2[1]) {
+        const config_plugin_value_t *cpv = p->cvlist + p->cvlist->v.u2[0];
+        if (-1 != cpv->k_id)
+            mod_dynamicfile_merge_config(&p->defaults, cpv);
+    }
+
+    return HANDLER_GO_ON;
+}    
+
+URIHANDLER_FUNC(mod_dynamicfile_subrequest) {
+	plugin_data *p = p_d;
+	int k;
+	stat_cache_entry *sce = NULL;
+	//buffer *mtime = NULL;
+	data_string *ds;
+	int is_dynamic_extension = 0, ret = -1;
+#ifdef USE_FOPEN
+	FILE *fp = NULL;
+#endif
+	int fd;
+	char *mem_buffer = NULL;
+	size_t file_length = 0, mem_length = 0;
+
+	/* get module config for request */
+	mod_dynamicfile_patch_config(r, p);
+
+	/* someone else has done a decision for us */
+	if (r->http_status != 0) return HANDLER_GO_ON;
+	if (buffer_string_is_empty(&r->uri.path)) return HANDLER_GO_ON;
+	if (buffer_string_is_empty(&r->physical.path)) return HANDLER_GO_ON;
+	/* someone else has handled this request */
+	if (NULL != r->handler_module) return HANDLER_GO_ON;
+
+	/* we only handle GET */
+	switch(r->http_method) {
+	case HTTP_METHOD_GET:
+		break;
+	default:
+		return HANDLER_GO_ON;
+	}
+
+	/* process certain extensions */
+	for (k = 0; k < p->conf.include_ext->used; k++) {
+		ds = (data_string *)p->conf.include_ext->data[k];
+
+		if (ds->value.used == 0) continue;
+
+		if (buffer_is_equal_right_len(&r->physical.path, &ds->value, ds->value.used - 1)) {
+			is_dynamic_extension = 1;
+			break;
+		}
+	}
+
+	if (!is_dynamic_extension) {
+		if (r->conf.log_request_handling) {
+			log_error(r->conf.errh, __FILE__, __LINE__, "-- NOT handling file as dynamic file, extension forbidden");
+		}
+		return HANDLER_GO_ON;
+	}
+
+
+	if (r->conf.log_request_handling) {
+		log_error(r->conf.errh, __FILE__, __LINE__,  "-- handling file as dynamic file");
+	}
+
+	sce = stat_cache_get_entry(&r->physical.path);
+	if (NULL == sce ) {
+
+		r->http_status = 403;
+
+		log_error(r->conf.errh, __FILE__, __LINE__, 
+				"not a regular file: %s -> %s", r->uri.path,
+				r->physical.path.ptr);
+
+		return HANDLER_FINISHED;
+	}
+
+	if (!S_ISREG(sce->st.st_mode)) {
+		r->http_status = 404;
+
+		if (r->conf.log_file_not_found) {
+			log_error(r->conf.errh, __FILE__, __LINE__,
+					"not a regular file: %s -> %s", r->uri.path, sce->name);
+		}
+
+		return HANDLER_FINISHED;
+	}
+
+	/* mod_compress might set several data directly, don't overwrite them */
+
+	/* set response content-type, if not set already */
+	const buffer * const h =
+	  http_header_response_get(r,HTTP_HEADER_CONTENT_TYPE, CONST_STR_LEN("Content-Type"));
+
+	if (NULL == h) {
+		if (buffer_string_is_empty(&sce->content_type)) {
+			/* we are setting application/octet-stream, but also announce that
+			 * this header field might change in the seconds few requests 
+			 *
+			 * This should fix the aggressive caching of FF and the script download
+			 * seen by the first installations
+			 */
+		  http_header_response_set(r, HTTP_HEADER_CONTENT_TYPE,
+					   CONST_STR_LEN("Content-Type"),
+					   CONST_STR_LEN("application/octet-stream"));
+		} else {
+			 http_header_response_set(r, HTTP_HEADER_CONTENT_TYPE,
+						  CONST_STR_LEN("Content-Type"),
+						  CONST_BUF_LEN(&sce->content_type));
+		}
+	}
+	/* if we are still here, prepare body */
+
+	/* once file is opened, hold it open until done with it to make sure it 
+	 * doesn't get switched to a new file between getting size and reading data */
+	for (k = 0; k <= p->conf.retries; k++) {
+		struct stat st;
+
+		if (r->conf.log_request_handling) {
+			if (k) log_error(r->conf.errh, __FILE__, __LINE__,  "-- retry open %d of %d", k, p->conf.retries);
+		}
+#ifdef USE_FOPEN
+		fp = fopen(r->physical.path.ptr, "r");
+		if (NULL == fp) {
+			if (r->conf.log_request_handling) {
+				log_error(r->conf.errh, __FILE__, __LINE__, "-- retry open %d", k+1);
+			}
+			usleep(1000);  // 1ms
+			continue;
+		}
+		fd = fileno(fp);
+#else
+		char *path = r->physical.path.ptr;
+		// fprintf(stderr, "uffe: to open %s\n", path);
+		fd = open(path, O_RDONLY /* | O_NOATIME */ );
+		if (fd < 0) {
+			if (r->conf.log_request_handling) {
+				log_error(r->conf.errh, __FILE__, __LINE__,  "-- retry open %d", k+1);
+			}
+			// fprintf(stderr, "uffe: open %s failed, errno %d\n", path, errno);
+			usleep(1000);  // 1ms
+			continue;
+		}
+		// fprintf(stderr, "uffe: opened %s (fd = %d)\n", path, fd);
+
+#endif
+		
+    /* track 2 different sizes because the chunk code assumes memory segments 
+     * are null terminated: buffer has 1 extra byte over actual file size */
+		st.st_size = 0;
+		if (fstat(fd, &st)) {
+			log_error(r->conf.errh, __FILE__, __LINE__, "-- fstat failed %s", strerror(errno));
+			return HANDLER_ERROR;
+		}
+
+		file_length = st.st_size;
+		mem_length = file_length + 1; 
+		mem_buffer = calloc(1, mem_length);
+		if (!mem_buffer) {
+			log_error(r->conf.errh, __FILE__, __LINE__, "-- failed to calloc %d", mem_length);
+			close(fd);
+		} else {
+#ifdef USE_FOPEN
+			if (1 != (ret = fread(mem_buffer, file_length, 1, fp))) {
+#else
+                            if (file_length != (size_t)(ret = read(fd, mem_buffer, file_length))) {
+#endif
+#ifdef VALIDATE_READ_COMPLETE
+#ifdef USE_FOPEN
+				if (ferror(fp))
+					log_error(r->conf.errh, __FILE__, __LINE__,  "-- file read failed: %s, size %d", strerror(errno), file_length);
+				if (feof(fp))
+					log_error(r->conf.errh, __FILE__, __LINE__,  "-- file read failed: EOF, size %d, pos %d", file_length, ftell(fp));
+#endif
+#endif
+// fprintf(stderr, "uffe: closes (fd = %d) A\n", fd);
+				close(fd);
+				free(mem_buffer);
+				//r->http_status = 409;
+				//return HANDLER_FINISHED;
+			} else {
+#ifdef VALIDATE_READ_COMPLETE
+				char c;
+				// force a final read, which had better fail and set EOF
+				if (1 != fread(&c, 1, 1, fp)) {
+					if (ferror(fp)) {
+						log_error(r->conf.errh, __FILE__, __LINE__,  "-- final file read failed: %s, size %d", strerror(errno), file_length);
+					} else if (feof(fp)) {
+						if (k) log_error(r->conf.errh, __FILE__, __LINE__,  "-- recovered after retry %d, size %d", k, file_length);
+						//else log_error(srv, __FILE__, __LINE__,  "-- final file read failed, but, OKAY...at EOF: size %d", file_length);
+						break;
+					} else {
+						log_error(r->conf.errh, __FILE__, __LINE__,  "-- final file read failed, but not at EOF:  size %d", file_length);
+					}
+				} else {
+					log_error(r->conf.errh, __FILE__, __LINE__, "-- final file read did NOT fail, must not be at EOF:  size %d", file_length);
+				}
+				close(fd);
+				free(mem_buffer);
+#else
+				break;
+#endif
+			}
+		}
+		fd = -1;
+	}	// for
+
+	if (0 > fd) {
+		r->http_status = 404;
+		r->resp_body_finished = 1;
+
+		//if (r->conf.log_file_not_found) {
+			log_error(r->conf.errh, __FILE__, __LINE__,  "-- failed to open file ");
+		//}
+		return HANDLER_FINISHED;
+	}
+	close(fd);
+	http_chunk_append_mem(r, mem_buffer, mem_length);
+	free(mem_buffer);
+
+	r->http_status = 200;
+	r->resp_body_finished = 1;
+
+	return HANDLER_FINISHED;
+}
+
+/* this function is called at dlopen() time and inits the callbacks */
+
+int mod_dynamicfile_plugin_init(plugin *p);
+int mod_dynamicfile_plugin_init(plugin *p) {
+	p->version     = LIGHTTPD_VERSION_ID;
+	p->name	= "dynamicfile";
+
+	p->init	= mod_dynamicfile_init;
+	p->handle_subrequest_start = mod_dynamicfile_subrequest;
+	p->set_defaults  = mod_dynamicfile_set_defaults;
+	p->handle_uri_clean     = mod_dynamicfile_subrequest;
+
+	return 0;
+}
-- 
2.25.1

